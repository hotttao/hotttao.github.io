<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>LoveIt</title>
        <link>https://hotttao.github.io/</link>
        <description>宋涛的个人博客</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>1556824234@qq.com (宋涛)</managingEditor>
            <webMaster>1556824234@qq.com (宋涛)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Mon, 21 Jul 2025 22:00:00 &#43;0800</lastBuildDate>
            <atom:link href="https://hotttao.github.io/index.xml" rel="self" type="application/rss+xml" />
        <item>
    <title>LangChain Context 和 RunnableConfig</title>
    <link>https://hotttao.github.io/posts/program/python/langchain/02_context_config/</link>
    <pubDate>Mon, 21 Jul 2025 22:00:00 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://hotttao.github.io/posts/program/python/langchain/02_context_config/</guid>
    <description><![CDATA[上一篇我们讲到了 RunnableSequence invoke 方法。这个方法里调用的 config_with_context 方法比较难理解。所以在讲解 invoke 方法之前，我们先来了解一下 langchain 中的 Context 和 RunnableConfig。 1.]]></description>
</item><item>
    <title>langchain-core 核心对象</title>
    <link>https://hotttao.github.io/posts/program/python/langchain/01_core_base/</link>
    <pubDate>Sun, 20 Jul 2025 22:00:00 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://hotttao.github.io/posts/program/python/langchain/01_core_base/</guid>
    <description><![CDATA[本周开始学习 langchain，大约经历了如下的过程: 简单阅读了 langchain 文档，学习了 LCEL，LCEL 的基本接口是 Runnable 读到 astream_log 方法时候，感觉模棱两可，]]></description>
</item><item>
    <title>Java 变量、流程控制与数据类型</title>
    <link>https://hotttao.github.io/posts/program/java/grammar/01_vars/</link>
    <pubDate>Mon, 01 May 2023 22:00:00 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://hotttao.github.io/posts/program/java/grammar/01_vars/</guid>
    <description><![CDATA[1. 变量定义和声明 问: 以表格的方式，对比 java 和go 中变量声明的方式，包括变量推导的声明语法 变量声明方式 Java Go 声明变量 int x; String name; var x int; var name string; 声明并初始]]></description>
</item><item>
    <title>Go 的常见“陷阱”</title>
    <link>https://hotttao.github.io/posts/program/go/expert/go_export/expert_31/</link>
    <pubDate>Fri, 13 Jan 2023 22:00:00 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://hotttao.github.io/posts/program/go/expert/go_export/expert_31/</guid>
    <description><![CDATA[这个系列我们开始学习 go 语言的第二部分-go语言进阶]]></description>
</item><item>
    <title>Go generate</title>
    <link>https://hotttao.github.io/posts/program/go/expert/go_export/expert_26/</link>
    <pubDate>Thu, 12 Jan 2023 22:00:00 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://hotttao.github.io/posts/program/go/expert/go_export/expert_26/</guid>
    <description><![CDATA[1. go generate 1.1 简介 项目构建，通常我们会依赖一些构建管理工具，比如shell脚本、make等。通过 make 我们可以在编译和构建 Go 代码之前，完成诸如 protobuf 文件生]]></description>
</item><item>
    <title>Go 常用工具</title>
    <link>https://hotttao.github.io/posts/program/go/expert/go_export/expert_27/</link>
    <pubDate>Thu, 12 Jan 2023 22:00:00 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://hotttao.github.io/posts/program/go/expert/go_export/expert_27/</guid>
    <description><![CDATA[go 原生提供的工具，在 gopath 和 module-ware 两种模式上存在一些行为差异。接下来我们会分别介绍 go 原生工具在这两种模式下的使用。 1. go get go get 用于获取 Go 包及其依赖包 常]]></description>
</item><item>
    <title>Go cgo</title>
    <link>https://hotttao.github.io/posts/program/go/expert/go_export/expert_19/</link>
    <pubDate>Wed, 11 Jan 2023 22:00:00 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://hotttao.github.io/posts/program/go/expert/go_export/expert_19/</guid>
    <description><![CDATA[这个系列我们开始学习 go 语言的第二部分-go语言进阶]]></description>
</item><item>
    <title>Go reflect</title>
    <link>https://hotttao.github.io/posts/program/go/expert/go_export/expert_18/</link>
    <pubDate>Tue, 10 Jan 2023 22:00:00 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://hotttao.github.io/posts/program/go/expert/go_export/expert_18/</guid>
    <description><![CDATA[1. 反射 Go在标准库中提供的reflect包让Go程序具备运行时的反射能力（reflection，又称为自省）。反射是程序在运行时访问、检测和]]></description>
</item><item>
    <title>Go unsafe包的安全使用模式</title>
    <link>https://hotttao.github.io/posts/program/go/expert/go_export/expert_17/</link>
    <pubDate>Mon, 09 Jan 2023 22:00:00 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://hotttao.github.io/posts/program/go/expert/go_export/expert_17/</guid>
    <description><![CDATA[1. 类型安全 在Go语言中，我们是无法通过常规语法手段穿透Go在类型系统层面对内存数据的保护的： 1 2 3 4 5 6 7 8 9 10 11 12 func main() { a := 0x12345678 fmt.Printf(&#34;0x%x\n&#34;, a) var p *byte =]]></description>
</item><item>
    <title>Go 网络编程</title>
    <link>https://hotttao.github.io/posts/program/go/expert/go_export/expert_16/</link>
    <pubDate>Sun, 08 Jan 2023 22:00:00 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://hotttao.github.io/posts/program/go/expert/go_export/expert_16/</guid>
    <description><![CDATA[Go是自带运行时的跨平台编程语言，Go中暴露给语言使用者的TCP Socket接口是建立在操作系统原生TCP Socket接口之上的。由于Go运]]></description>
</item></channel>
</rss>
