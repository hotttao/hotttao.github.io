<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>go 并发 - 标签 - LoveIt</title>
        <link>https://hotttao.github.io/tags/go-%E5%B9%B6%E5%8F%91/</link>
        <description>go 并发 - 标签 - LoveIt</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>1556824234@qq.com (宋涛)</managingEditor>
            <webMaster>1556824234@qq.com (宋涛)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Tue, 11 May 2021 22:00:00 &#43;0800</lastBuildDate><atom:link href="https://hotttao.github.io/tags/go-%E5%B9%B6%E5%8F%91/" rel="self" type="application/rss+xml" /><item>
    <title>Atomic 原子操作</title>
    <link>https://hotttao.github.io/posts/program/go/sync/go_sync_12/</link>
    <pubDate>Tue, 11 May 2021 22:00:00 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://hotttao.github.io/posts/program/go/sync/go_sync_12/</guid>
    <description><![CDATA[1. Atomic 概述 1.1 原子操作 Package sync/atomic 实现了同步算法底层的原子的内存操作原语。之所以叫原子操作，是因为一个原子在执行的时候，其它线程不会看到执行一半的操作结]]></description>
</item><item>
    <title>Channel 使用与实现</title>
    <link>https://hotttao.github.io/posts/program/go/sync/go_sync_13/</link>
    <pubDate>Tue, 11 May 2021 22:00:00 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://hotttao.github.io/posts/program/go/sync/go_sync_13/</guid>
    <description><![CDATA[1. Channel 概述 1.1 CSP 模型 要想了解 Channel，我们要先追溯到 CSP 模型。CSP 是 Communicating Sequential Process 的简称，中文直译为通信顺序进程，或者叫做交换信息的循序进程，是用]]></description>
</item><item>
    <title>go Context</title>
    <link>https://hotttao.github.io/posts/program/go/sync/go_sync_11/</link>
    <pubDate>Mon, 10 May 2021 22:00:00 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://hotttao.github.io/posts/program/go/sync/go_sync_11/</guid>
    <description><![CDATA[1. Context 概述 所谓上下文指的是在 API 之间或者方法调用之间，所传递的除了业务参数之外的额外信息，比如服务追踪。Go 标准库中的 Context 不仅仅传递上下文信息还提]]></description>
</item><item>
    <title>go Pool</title>
    <link>https://hotttao.github.io/posts/program/go/sync/go_sync_10/</link>
    <pubDate>Sun, 09 May 2021 22:00:00 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://hotttao.github.io/posts/program/go/sync/go_sync_10/</guid>
    <description><![CDATA[1. Pool 概述 Go 是一个自动垃圾回收的编程语言，采用三色并发标记算法标记对象并回收。但是，如果你想使用 Go 开发一个高性能的应用程序的话，就必须考虑垃圾]]></description>
</item><item>
    <title>线程安全的 map</title>
    <link>https://hotttao.github.io/posts/program/go/sync/go_sync_9/</link>
    <pubDate>Sat, 08 May 2021 22:00:00 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://hotttao.github.io/posts/program/go/sync/go_sync_9/</guid>
    <description><![CDATA[线程安全的 map 1. 线程安全的 map 概述 1.1 map 的基本使用 键类型 Go 内建的 map 类型如下： 1 map[K]V 其中，key 类型的 K 必须是可比较的（comparable），在 Go 语]]></description>
</item><item>
    <title>Once 实现单例</title>
    <link>https://hotttao.github.io/posts/program/go/sync/go_sync_8/</link>
    <pubDate>Fri, 07 May 2021 22:00:00 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://hotttao.github.io/posts/program/go/sync/go_sync_8/</guid>
    <description><![CDATA[Once 有且仅有一次执行 1. Once 概述 Once 可以用来执行且仅仅执行一次动作：Once 常常用来初始化单例资源，或者并发访问只需初始化一次的共享资源，或者在测试]]></description>
</item><item>
    <title>Cond 条件变量</title>
    <link>https://hotttao.github.io/posts/program/go/sync/go_sync_7/</link>
    <pubDate>Thu, 06 May 2021 22:00:00 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://hotttao.github.io/posts/program/go/sync/go_sync_7/</guid>
    <description><![CDATA[Cond 条件变量 1. Cond 概述 Go 标准库提供 Cond 原语的目的是，为等待 / 通知场景下的并发问题提供支持。Cond 通常应用于等待某个条件的一组 goroutine，]]></description>
</item><item>
    <title>WaitGroup</title>
    <link>https://hotttao.github.io/posts/program/go/sync/go_sync_6/</link>
    <pubDate>Wed, 05 May 2021 22:00:00 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://hotttao.github.io/posts/program/go/sync/go_sync_6/</guid>
    <description><![CDATA[WaitGroup 任务编排 1. WaitGroup 使用 WaitGroup 很简单，就是 package sync 用来做任务编排的一个并发原语。它要解决的就是并发 - 等待的问题: goroutine A 等待一组 goroutine 全部完成。 很多操作系统和编程]]></description>
</item><item>
    <title>RWMutex</title>
    <link>https://hotttao.github.io/posts/program/go/sync/go_sync_5/</link>
    <pubDate>Tue, 04 May 2021 22:00:00 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://hotttao.github.io/posts/program/go/sync/go_sync_5/</guid>
    <description><![CDATA[读写锁 RWMutex 1. RWMutex 使用 标准库中的 RWMutex 是一个 reader/writer 互斥锁，用来解决并发读写问题，特别适用于读多写少的场景。RWMutex 在某一时刻只能由任意数量的 reader 持有，]]></description>
</item><item>
    <title>Mutex 扩展</title>
    <link>https://hotttao.github.io/posts/program/go/sync/go_sync_4/</link>
    <pubDate>Mon, 03 May 2021 22:00:00 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://hotttao.github.io/posts/program/go/sync/go_sync_4/</guid>
    <description><![CDATA[如何基于 Mutex 实现一个可重入锁 1. Mutex 的扩展 上一节我们介绍了 Mutex 的实现原理，这一节我们来看看如何基于标准库的 Mutex 来扩展 Mutex 提供的并发原语，包括: 实现一个可]]></description>
</item></channel>
</rss>
