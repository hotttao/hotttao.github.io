[{"categories":["个人总结"],"content":"规整一下博客的内容","date":"2022-02-17","objectID":"/blog_content/","tags":["个人总结"],"title":"要写点什么","uri":"/blog_content/"},{"categories":["个人总结"],"content":"写博客也挺久了，是时候重构一下博客的内容了。 ","date":"2022-02-17","objectID":"/blog_content/:0:0","tags":["个人总结"],"title":"要写点什么","uri":"/blog_content/"},{"categories":["个人总结"],"content":"1. 新的博客 有段时间没更新自己的博客了，最开始写博客还是刚开始学编程的时候，跟着马哥学 Linux，把每天学习的内容都整理到博客上。后来博客成了自己的\"笔记本\"，几乎所有学到的东西都会整理在博客上。时间久了，内容就越来越多，越来越杂。2023 年准备从北京回老家了，想规划一下自己的未来。心里做了计划，准备继续在博客上写写笔记，却突然发现不知道应该把内容放在博客哪了。就跟代码一样，时间一长博客也变得杂乱无章。所以这段时间准备把博客好好规整一番，算是对知识再一次的总结和回顾。 ","date":"2022-02-17","objectID":"/blog_content/:1:0","tags":["个人总结"],"title":"要写点什么","uri":"/blog_content/"},{"categories":["个人总结"],"content":"2. 博客写那些内容 根据自己的知识结构和以后想学的东西，我把博客的内容做了下面的分类: Program: 编程语言，这个分类会记录所学的编程语言，以及与语言密切相关的周边知识包括: Python Golang C JavaScript Rust 数据结构与算法 设计模式 Linux: 操作系统，这个分类包含了所有与操作系统相关的底层知识，包括: 汇编语言，包括 x86 汇编以及 gcc asm 内联汇编 程序的编译、连接和加载 操作系统的实现 Linux 的基础使用 Linux 的源码解析 Linux 性能优化 profiling/epbf 网络的基本原理 容器和云的网络架构 Distribution: 分布式系统，这个部分包含了分布式系统相关的理论研究 Architecture: 架构，这部分包含了当前流行的开源组件和数据库的原理和使用，包括: k8s etcd mysql redis elasticsearch kafka flink …. Browser: 前端，这个部分包含的是前端的知识体系，包括: 浏览器的实现原理 html/css Vue React Hacker: 黑客，这部分会包含渗透相关的知识 Investment: 投资，这部分会记录学习量化投资相关的知识 Thinking: 记录自己的思考和感悟 tool: 记录平时用到的好用的工具 框架很大，内容很多，也不一定都会去学去写，先占个位置，什么时候想学了就往里面填一笔。学习应该成为一种乐趣。 ","date":"2022-02-17","objectID":"/blog_content/:2:0","tags":["个人总结"],"title":"要写点什么","uri":"/blog_content/"},{"categories":["个人总结"],"content":"3. 如何去学习一门语言 如何学习一门编译语言这是一个很大，也经常有大佬会谈的一个话题。我不是大佬，没法从类型系统，编译原理等各个层面去高度抽象的总结我们应该怎么学习一门语言。但是我想总结的是: 如果我们去学一门语言，我们到底要学些什么。 你可能经常也听身边的大佬说，我花了多少个小时学习了什么什么语言，这个语言怎么怎么样。如果说只是语法，花个几个小时的确就能很容易学会，但是要成为一个语言的开发者，仅仅了解一个语言的语法是远远不够的。我觉得从浅入深至少要学习下面这些内容: 语法: 学会了语法代表你已经踏入了这个语言的领域 惯例: 惯例包括了这个语言特有的最佳实践，最适合的设计模式等等，了解了这个语言惯例你才能写出这个语言纯正的代码，而不是把 go 写的像 java 实现: 了解一个语言底层实现，才能让你成为这个语言的专家 并发: 实现一个高性能的程序，离不开对并发的深入理解 库: 包括标准库和第三方库，掌握常用库的用法，编码才能更加高效 框架: 框架代表这个语言的技术生态和最佳实践 周边工具: 包括单元测试，这个语言提供的性能分析工具等等，对这些工具的使用能从侧面反映你对这个语言的熟练程度 所以，对于博客里面出现的编程语言，我都会按照上面的分块，由浅入深分步去学习。 ","date":"2022-02-17","objectID":"/blog_content/:3:0","tags":["个人总结"],"title":"要写点什么","uri":"/blog_content/"},{"categories":["个人总结"],"content":"4. 内容组织 上面经过一些简单的划分，其实是将知识划分了多个相对独立的模块，在这个博客里每个知识模块都对应着一个系列。每个系列我会选择一本书或多本书作为我们学习的核心内容，在核心内容之后，我会把我看到的好的与这个知识模块密切相关的文章整理更新在核心内容之后，以此来不断完善对这个知识的理解。 ","date":"2022-02-17","objectID":"/blog_content/:4:0","tags":["个人总结"],"title":"要写点什么","uri":"/blog_content/"},{"categories":["Go"],"content":"go 语言的自省","date":"2021-01-09","objectID":"/go_9/","tags":["go 语法"],"title":"go reflect","uri":"/go_9/"},{"categories":["Go"],"content":"go 反射机制 ","date":"2021-01-09","objectID":"/go_9/:0:0","tags":["go 语法"],"title":"go reflect","uri":"/go_9/"},{"categories":["Go"],"content":"1. 反射机制 反射是一个复杂的内省技术。所谓内省即可以动态获取变量的类型，值，以及方法属性等元数据。需要反射的根本原因是，很多时候我们在编程时，并不能确定输入的具体类型，需要我们动态去判断。 Go语言提供的反射机制，能够让我们在运行时更新变量和检查它们的值、调用它们的方法和它们支持的内在操作，而不需要在编译时就知道这些变量的具体类型。也可以让我们将类型本身作为第一类的值类型处理。 GO 中有两个至关重要的API是使用反射机制实现： fmt包提供的字符串格式功能 类似encoding/json和encoding/xml提供的针对特定协议的编解码功能。 本节我们就来看看如何使用 Go 的反射机制，以及上述两个包使用 reflect 的方式。 ","date":"2021-01-09","objectID":"/go_9/:1:0","tags":["go 语法"],"title":"go reflect","uri":"/go_9/"},{"categories":["Go"],"content":"2. Reflect API 反射是由 reflect 包提供的。 它定义了两个重要的类型, Type 和 Value ","date":"2021-01-09","objectID":"/go_9/:2:0","tags":["go 语法"],"title":"go reflect","uri":"/go_9/"},{"categories":["Go"],"content":"2.1 Type Type 是一个接口类型，唯一能反映 reflect.Type 实现的是接口的类型描述信息。 我们在接口一节说过，接口的值，由两个部分组成，一个具体的类型和那个类型的值。它们被称为接口的动态类型和动态值。对于像Go语言这种静态类型的语言，类型是编译期的概念；因此一个类型不是一个值。在我们的概念模型中，一些提供每个类型信息的值被称为类型描述符，比如类型的名称和方法。在一个接口值中，类型部分代表与之相关类型的描述符。而 reflect.Type 的实现方式就与接口中的类型描述符类似。 reflect.Type 有许多办法来区分类型以及检查它们的组成部分, 例如一个结构体的成员或一个函数的参数等。 TypeOf reflect.TypeOf 接受任意的 interface{} 类型, 并以reflect.Type形式返回一个动态类型的接口值。reflect.Type 满足 fmt.Stringer 接口。 fmt.Printf 提供的 %T 参数, 内部就是使用 reflect.TypeOf 来输出接口的动态类型。 t := reflect.TypeOf(3) // a reflect.Type fmt.Println(t.String()) // \"int\" fmt.Println(t) // \"int\" fmt.Printf(\"%T\\n\", 3) // \"int\" ","date":"2021-01-09","objectID":"/go_9/:2:1","tags":["go 语法"],"title":"go reflect","uri":"/go_9/"},{"categories":["Go"],"content":"2.2 Value reflect.Value 可以装载任意类型的值。函数 reflect.ValueOf 接受任意的 interface{} 类型, 并返回一个装载着其动态值的 reflect.Value。和 reflect.Type 类似, reflect.Value 也满足 fmt.Stringer 接口, 但是除非 Value 持有的是字符串, 否则 String 方法只返回其类型. 而使用 fmt 包的 %v 标志参数会对 reflect.Values 特殊处理. v := reflect.ValueOf(3) // a reflect.Value fmt.Println(v) // \"3\" fmt.Printf(\"%v\\n\", v) // \"3\" fmt.Println(v.String()) // NOTE: \"\u003cint Value\u003e\" 对 Value 调用 Type 方法将返回具体类型所对应的 reflect.Type: t := v.Type() // a reflect.Type fmt.Println(t.String()) // \"int\" ","date":"2021-01-09","objectID":"/go_9/:2:2","tags":["go 语法"],"title":"go reflect","uri":"/go_9/"},{"categories":["Go"],"content":"2.3 Value 与 interface reflect.ValueOf 的逆操作是 reflect.Value.Interface 方法. 它返回一个 interface{} 类型，装载着与 reflect.Value 相同的具体值。 v := reflect.ValueOf(3) // a reflect.Value x := v.Interface() // an interface{} i := x.(int) // an int fmt.Printf(\"%d\\n\", i) // \"3 reflect.Value 和 interface{} 都能装载任意的值. 所不同的是, 一个空的接口隐藏了值内部的表示方式和所有方法, 因此只有我们知道具体的动态类型才能使用类型断言来访问内部的值(就像上面那样),内部值我们没法访问. 相比之下, 一个 Value 则有很多方法来检查其内容, 无论它的具体类型是什么。 与 switch x := x.(type) 相比 reflect.Value.Kind 返回的数据类型是有限的: Bool, String 和 所有数字类型的基础类型 Array 和 Struct 对应的聚合类型; Chan, Func, Ptr, Slice, 和 Map 对应的引用类型; interface 类型; 还有表示空值的 Invalid 类型 (空的 reflect.Value 的 kind 即为 Invalid.) Kind 只关心底层表示, 所有的具名类型都会归属到对应的原始类型之上。 ","date":"2021-01-09","objectID":"/go_9/:2:3","tags":["go 语法"],"title":"go reflect","uri":"/go_9/"},{"categories":["Go"],"content":"2.4 示例 func Display(name string, x interface{}) { fmt.Printf(\"Display %s (%T):\\n\", name, x) display(name, reflect.ValueOf(x)) } func formatAtom(v reflect.Value) string { switch v.Kind() { case reflect.Invalid: return \"invalid\" case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64: return strconv.FormatInt(v.Int(), 10) case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr: return strconv.FormatUint(v.Uint(), 10) // ...floating‐point and complex cases omitted for brevity... case reflect.Bool: return strconv.FormatBool(v.Bool()) case reflect.String: return strconv.Quote(v.String()) case reflect.Chan, reflect.Func, reflect.Ptr, reflect.Slice, reflect.Map: return v.Type().String() + \" 0x\" + strconv.FormatUint(uint64(v.Pointer()), 16) default: // reflect.Array, reflect.Struct, reflect.Interface return v.Type().String() + \" value\" } } func display(path string, v reflect.Value) { switch v.Kind() { case reflect.Invalid: fmt.Printf(\"%s = invalid\\n\", path) case reflect.Slice, reflect.Array: for i := 0; i \u003c v.Len(); i++ { display(fmt.Sprintf(\"%s[%d]\", path, i), v.Index(i)) } case reflect.Struct: for i := 0; i \u003c v.NumField(); i++ { fieldPath := fmt.Sprintf(\"%s.%s\", path, v.Type().Field(i).Name) display(fieldPath, v.Field(i)) } case reflect.Map: for _, key := range v.MapKeys() { display(fmt.Sprintf(\"%s[%s]\", path, formatAtom(key)), v.MapIndex(key)) } case reflect.Ptr: if v.IsNil() { fmt.Printf(\"%s = nil\\n\", path) } else { display(fmt.Sprintf(\"(*%s)\", path), v.Elem()) } case reflect.Interface: if v.IsNil() { fmt.Printf(\"%s = nil\\n\", path) } else { fmt.Printf(\"%s.type = %s\\n\", path, v.Elem().Type()) display(path+\".value\", v.Elem()) } default: // basic types, channels, funcs fmt.Printf(\"%s = %s\\n\", path, formatAtom(v)) } } ","date":"2021-01-09","objectID":"/go_9/:2:4","tags":["go 语法"],"title":"go reflect","uri":"/go_9/"},{"categories":["Go"],"content":"go 程序包组织结构和程序管理工具箱","date":"2021-01-09","objectID":"/go_11/","tags":["go 语法"],"title":"go 包和管理工具","uri":"/go_11/"},{"categories":["Go"],"content":"go 程序包组织结构和程序管理工具箱 ","date":"2021-01-09","objectID":"/go_11/:0:0","tags":["go 语法"],"title":"go 包和管理工具","uri":"/go_11/"},{"categories":["Go"],"content":"1. 包简介 包和模块的概念几乎存在于所有的编程语言之中，它的存在是为了简化大型程序的设计和维护工作。通过将一组相关的特性放进一个独立的单元以便于理解和更新，这种特性提供诸多益处: 每个包可以被其它的不同项目共享和重用 包提供了一个独立的命名空间，减少了与其他部分的命名冲突 通过控制包内名字的可见性和是否导出来实现封装 Go 通过使用名字的开头字母的大小写决定了名字在包外的可见性，小写字符开头包成员不会导出，在包外不可见。通过这种方式可以严格的隐藏包内实现的 API，通过强制用户使用特定函数来访问和更新内部变量，可以保证内部变量的一致性和并发时的互斥约束。 当我们修改了一个源文件，我们必须重新编译该源文件对应的包和所有依赖该包的其他包。即使是从头构建，Go语言编译器的编译速度也明显快于其它编译语言。Go语言的闪电般的编译速度主要得益于三个语言特性: 第一点，所有导入的包必须在每个文件的开头显式声明，这样的话编译器就没有必要读取和分析整个源文件来判断包的依赖关系 第二点，禁止包的环状依赖，因为没有循环依赖，包的依赖关系形成一个有向无环图，每个包可以被独立编译，而且很可能是被并发编译 第三点，编译后包的目标文件不仅仅记录包本身的导出信息，目标文件同时还记录了包的依赖关系。因此，在编译一个包的时候，编译器只需要读取每个直接导入包的目标文件，而不需要遍历所有依赖的的文件。 本节我们就来学习与 Go 语言包相关的内容。 ","date":"2021-01-09","objectID":"/go_11/:1:0","tags":["go 语法"],"title":"go 包和管理工具","uri":"/go_11/"},{"categories":["Go"],"content":"2. Go 程序包 ","date":"2021-01-09","objectID":"/go_11/:2:0","tags":["go 语法"],"title":"go 包和管理工具","uri":"/go_11/"},{"categories":["Go"],"content":"2.1 包声明 Go 语言的源码也是以代码包为基本组织单位的。在文件系统中，这些代码包其实是与目录一一对应的。由于目录可以有子目录，所以代码包也可以有子包。一个代码包中可以包含任意个以.go 为扩展名的源码文件，这些源码文件都需要被声明属于同一个代码包。 在每个Go语言源文件的开头都必须有包声明语句。包声明语句的主要目的是确定当前包被其它包导入时默认的标识符（也称为包名）。代码包的名称一般会与源码文件所在的目录同名。如果不同名，那么在构建、安装的过程中会以代码包名称为准。 通常来说，默认的包名就是包导入路径名的最后一段，因此即使两个包的导入路径不同，它们依然可能有一个相同的包名。例如，math/rand包和crypto/rand包的包名都是rand。这也有三种例外情况。 第一个例外，包对应一个可执行程序，也就是main包，这时候main包本身的导入路径是无关紧要的。名字为main的包是给go build 构建命令一个信息，这个包编译完之后必须调用连接器生成一个可执行程序。 第二个例外，包所在的目录中可能有一些文件名是以 _test.go为后缀的Go源文件（译注：前面必须有其它的字符，因为以 _前缀的源文件是被忽略的），并且这些源文件声明的包名也是以_test为后缀名的。这种目录可以包含两种包：一种普通包，加一种则是测试的外部扩展包。所有以_test为后缀包名的测试外部扩展包都由go test命令独立编译，普通包和测试的外部扩展包是相互独立的。测试的外部扩展包一般用来避免测试代码中的循环导入依赖，具体细节我们将在下一章讲解。 第三个例外，一些依赖版本号的管理工具会在导入路径后追加版本号信息，例如\"gopkg.in/yaml.v2\"。这种情况下包的名字并不包含版本号后缀，而是yaml ","date":"2021-01-09","objectID":"/go_11/:2:1","tags":["go 语法"],"title":"go 包和管理工具","uri":"/go_11/"},{"categories":["Go"],"content":"2.2 包的导入 每个包是由一个全局唯一的字符串所标识的导入路径定位。在实际使用程序实体之前，我们必须先导入其所在的代码包。在工作区中，一个代码包的导入路径实际上就是从 src 子目录，到该包的实际存储位置的相对路径。而导入时包可以被重命名，被隐藏。下面是包导入时常用的语法: package package_name import fmt import ( \"crypto/rand\" mrand \"math/rand\" // 包导入重命名，避免冲突 import _ \"image/png\" // 匿名导入 ) 需要注意的事: 包的导入必须在包声明语句之后，其它非导入声明语句之前 每个导入声明语句都明确指定了当前包和被导入包之间的依赖关系。如果遇到包循环导入的情况，Go语言的构建工具将报告错误。 Go语言的规范并没有指明包的导入路径字符串的具体含义，导入路径的具体含义是由构建工具来解释的，当使用Go语言自带的go工具箱时，一个导入路径代表一个包在文件系统的路径 ","date":"2021-01-09","objectID":"/go_11/:2:2","tags":["go 语法"],"title":"go 包和管理工具","uri":"/go_11/"},{"categories":["Go"],"content":"2.3 包的初始化 每个包在解决依赖的前提下，包会以导入声明的顺序初始化，包的初始化首先是解决包级变量的依赖顺序，然后按照包级变量声明出现的顺序依次初始化： var a = b + c // a 第三个初始化, 为 3 var b = f() // b 第二个初始化, 为 2, 通过调用 f (依赖c) var c = 1 // c 第一个初始化, 为 1 func f() int { return c + 1 } 如果包中含有多个.go源文件，它们将按照发给编译器的顺序进行初始化，Go语言的构建工具首先会将.go文件根据文件名排序，然后依次调用编译器编译。 每个包只会被初始化一次。因此，如果一个p包导入了q包，那么在p包初始化的时候可以认为q包必然已经初始化过了。初始化工作是自下而上进行的，main包最后被初始化。以这种方式，可以确保在main函数执行之前，所有依赖的包都已经完成初始化工作了。 对于在包级别声明的变量，如果有初始化表达式则用表达式初始化，还有一些没有初始化表达式的，例如某些表格数据初始化并不是一个简单的赋值过程。在这种情况下，我们可以用一个特殊的init初始化函数来简化初始化工作。每个文件都可以包含多个init初始化函数 func init() { /* ... */ } 这样的init初始化函数除了不能被调用或引用外，其他行为和普通函数类似。在每个文件中的init初始化函数，在程序开始执行时按照它们声明的顺序被自动调用。 匿名导入 如果只是导入一个包而并不使用导入的包将会导致一个编译错误。但是有时候我们只是想利用导入包而产生的副作用：计算包级变量的初始化表达式和执行导入包的init初始化函数。我们可以用下划线 _来重命名导入的包。像往常一样，下划线 _为空白标识符，并不能被访问。 ","date":"2021-01-09","objectID":"/go_11/:2:3","tags":["go 语法"],"title":"go 包和管理工具","uri":"/go_11/"},{"categories":["Go"],"content":"包文档 Go语言中包文档注释一般是完整的句子，第一行是包的摘要说明，注释后仅跟着包声明语句。包注释可以出现在任何一个源文件中。如果包的注释内容比较长，一般会放到一个独立的源文件中；fmt包注释就有300行之多。这个专门用于保存包文档的源文件通常叫doc.go。 ","date":"2021-01-09","objectID":"/go_11/:2:4","tags":["go 语法"],"title":"go 包和管理工具","uri":"/go_11/"},{"categories":["Go"],"content":"内部包 有时候，一个中间的状态可能也是有用的，对于一小部分信任的包是可见的，但并不是对所有调用者都可见。例如，当我们计划将一个大的包拆分为很多小的更容易维护的子包，但是我们并不想将内部的子包结构也完全暴露出去。同时，我们可能还希望在内部子包之间共享一些通用的处理包，或者我们只是想实验一个新包的还并不稳定的接口，暂时只暴露给一些受限制的用户使用 为了满足这些需求，Go语言的构建工具对包含internal名字的路径段的包导入路径做了特殊处理。这种包叫internal包，一个internal包只能被和internal目录有同一个父目录的包所导入。例如，net/http/internal/chunked内部包只能被net/http/httputil或net/http包导入，但是不能被net/url包导入。不过net/url包却可以导入net/http/httputil包。 net/http net/http/internal/chunked net/http/httputil net/url ","date":"2021-01-09","objectID":"/go_11/:2:5","tags":["go 语法"],"title":"go 包和管理工具","uri":"/go_11/"},{"categories":["Go"],"content":"go 命令使用 go get 使用命令 go get可以下载一个单一的包或者用 …下载整个子目录里面的每个包。Go语言工具箱的go命令同时计算并下载所依赖的每个包，一旦 go get命令下载了包，然后就是安装包或包对应的可执行的程序 go get命令支持当前流行的托管网站GitHub、Bitbucket和Launchpad，可以直接向它们的版本控制系统请求代码。对于其它的网站，你可能需要指定版本控制系统的具体路径和协议，例如 Git或Mercurial。 go get github.com/golang/lint/golint cd $GOPATH/src/golang.org/x/net git remote ‐v origin https://go.googlesource.com/net (fetch) origin https://go.googlesource.com/net (push) 需要注意的是导入路径含有的网站域名和本地Git仓库对应远程服务地址并不相同，真实的Git地址是go.googlesource.com。这其实是Go语言工具的一个特性，可以让包用一个自定义的导入路径，但是真实的代码却是由更通用的服务提供，例如googlesource.com或github.com。因为页面 https://golang.org/x/net/html 包含了如下的元数据，它告诉Go语言的工具当前包真实的Git仓库托管地址： \u003cmeta name=\"go‐import\" content=\"golang.org/x/net git https://go.googlesource.com/net\"\u003e 如果指定 ‐u命令行标志参数， go get命令将确保所有的包和依赖的包的版本都是最新的，然后重新编译和安装它们。如果不包含该标志参数的话，而且如果包已经在本地存在，那么代码那么将不会被自动更新。 ","date":"2021-01-09","objectID":"/go_11/:2:6","tags":["go 语法"],"title":"go 包和管理工具","uri":"/go_11/"},{"categories":["Go"],"content":"go build go build命令编译命令行参数指定的每个包。如果包是一个库，则忽略输出结果；这可以用于检测包的可以正确编译的。如果包的名字是main， go build将调用连接器在当前目录创建一个可执行程序；以导入路径的最后一段作为可执行程序的名字 默认情况下， go build命令构建指定的包和它依赖的包，然后丢弃除了最后的可执行文件之外所有的中间编译结果。 go install命令和 go build命令很相似，但是它会保存每个包的编译成果，而不是将它们都丢弃。被编译的包会被保存到$GOPATH/pkg目录下，目录路径和 src目录路径对应，可执行程序被保存到$GOPATH/bin目录。 goinstall命令和 go build命令都不会重新编译没有发生变化的包，这可以使后续构建更快捷。为了方便编译依赖的包， go build ‐i命令将安装每个目标所依赖的包。 因为编译对应不同的操作系统平台和CPU架构， go install命令会将编译结果安装到GOOS和GOARCH对应的目录。例如，在Mac系统，golang.org/x/net/html包将被安装到$GOPATH/pkg/darwin_amd64目录下的golang.org/x/net/html.a文件。 针对不同操作系统或CPU的交叉构建也是很简单的。只需要设置好目标对应的GOOS和GOARCH，然后运行构建命令即可。下面交叉编译的程序将输出它在编译时操作系统和CPU类型：有些包可能需要针对不同平台和处理器类型使用不同版本的代码文件，以便于处理底层的可移植性问题或提供为一些特定代码提供优化。如果一个文件名包含了一个操作系统或处理器类型名字，例如net_linux.go或asm_amd64.s，Go语言的构建工具将只在对应的平台编译这些文件。还有一个特别的构建注释注释可以提供更多的构建过程控制。例如，文件中可能包含下面的注释： // +build linux darwin 在包声明和包注释的前面，该构建注释参数告诉 go build只在编译程序对应的目标操作系统是Linux或Mac OS X时才编译这个文件。下面的构建注释则表示不编译这个文件 // +build ignore 更多细节，可以参考go/build包的构建约束部分的文档 ","date":"2021-01-09","objectID":"/go_11/:2:7","tags":["go 语法"],"title":"go 包和管理工具","uri":"/go_11/"},{"categories":["Go"],"content":"go doc go doc命令，该命令打印包的声明和每个成员的文档注释，该命令并不需要输入完整的包导入路径或正确的大小写 go doc time go doc time.Since go doc time.Duration.Seconds go doc json.decode godoc，它提供可以相互交叉引用的HTML页面，但是包含和 go doc命令相同以及更多的信息。godoc的在线服务 https://godoc.org ，包含了成千上万的开源包的检索工具。你也可以在自己的工作区目录运行godoc服务。运行下面的命令，然后在浏览器查看 http://localhost:8000/pkg 页面： $ godoc ‐http :8000 其中 ‐analysis=type和 ‐analysis=pointer命令行标志参数用于打开文档和代码中关于静态分析的结果 ","date":"2021-01-09","objectID":"/go_11/:2:8","tags":["go 语法"],"title":"go 包和管理工具","uri":"/go_11/"},{"categories":["Go"],"content":"go list go list命令可以查询可用包的信息。其最简单的形式，可以测试包是否在工作区并打印它的导入路径，还可以用 “…“表示匹配任意的包的导入路径。我们可以用它来列表工作区中的所有包： $ go list github.com/go‐sql‐driver/mysql github.com/go‐sql‐driver/mysql $ go list gopl.io/ch3/... $ go list ...xml... go list命令还可以获取每个包完整的元信息，而不仅仅只是导入路径，这些元信息可以以不同格式提供给用户。其中 ‐json命令行参数表示用JSON格式打印每个包的元信息。命令行参数 ‐f则允许用户使用text/template包（§4.6）的模板语言定义输出文本的格式。 go list ‐json hash go list ‐f '{{join .Deps \" \"}}' strconv go list ‐f '{{.ImportPath}} ‐\u003e {{join .Imports \" \"}}' compress/... ","date":"2021-01-09","objectID":"/go_11/:2:9","tags":["go 语法"],"title":"go 包和管理工具","uri":"/go_11/"},{"categories":["Go"],"content":"goroutines 和 channel","date":"2021-01-08","objectID":"/go_8/","tags":["go 语法"],"title":"go 并发编程","uri":"/go_8/"},{"categories":["Go"],"content":"Go 并发编程原语，Goroutines和Channels ","date":"2021-01-08","objectID":"/go_8/:0:0","tags":["go 语法"],"title":"go 并发编程","uri":"/go_8/"},{"categories":["Go"],"content":"1. GO 并发编程简介 上一篇我们讲解了 Go 语言中的接口，至此对于 Go 语言的类型系统我们基本上讲的差不都了。接下来我们将深入了解 Go 最为人推广的特性并发编程。对于那些完全独立的子问题，并发是简单的，但是真正复杂的是处理那些存在资源共享的多进程多线程并发问题。我们需要有效的通信机制来处理程序中的竞争条件，同时避免可能出现的死锁问题。 Go 之所以在并发编程中被人推广，是因为它提供的 goroutine 和 channel 支持“顺序通信进程”(communicating sequential processes)简称为CSP，这是一种现代的并发编程模型。CSP的具体原理我也不是很懂，但是 Go 有一句口头禅“不要使用共享数据来通信；使用通信来共享数据” 。学完这部分内容，你就能理解这句话的含义了。 没有一招鲜吃遍天的技术，每个模型都是特定的假设条件和使用情景，CSP 也不例外。相比于 GSP 传统的并发模型：多线程共享内存，可能更容易出错(竞争条件和死锁)，但是也更加灵活。所以要想写出正确的并发程序，对操作系统提供的锁，信号量等进程间通信的底层机制的了解必不可少。我们将分为三节来介绍这些并发编程的技巧，本节我们先来学习 goroutine 和 channel。 ","date":"2021-01-08","objectID":"/go_8/:1:0","tags":["go 语法"],"title":"go 并发编程","uri":"/go_8/"},{"categories":["Go"],"content":"2. Goroutine 在Go语言中，每一个并发的执行单元叫作一个goroutine。当一个程序启动时，其主函数即在一个单独的goroutine中运行，我们叫它main goroutine 。 ","date":"2021-01-08","objectID":"/go_8/:2:0","tags":["go 语法"],"title":"go 并发编程","uri":"/go_8/"},{"categories":["Go"],"content":"2.1 goroutine 创建 新的goroutine会用go语句来创建。在语法上，go语句是一个普通的函数或方法调用前加上关键字go。go语句会使其语句中的函数在一个新创建的goroutine中运行。而go语句本身会迅速地完成。 f() // call f(); wait for it to return go f() // create a new goroutine that calls f(); don't wait ","date":"2021-01-08","objectID":"/go_8/:2:1","tags":["go 语法"],"title":"go 并发编程","uri":"/go_8/"},{"categories":["Go"],"content":"2.2 goroutine 退出与回收 通常goroutine在执行完毕时会自动回收，当主函数返回时，所有未执行完毕的 goroutine 会被直接打断，程序退出。如果 goroutine 因为阻塞永远被卡住，我们称发生了goroutine泄漏，和垃圾变量不同，泄漏的goroutines并不会被自动回收，因此确保每个不再需要的goroutine能正常退出是重要的。 ","date":"2021-01-08","objectID":"/go_8/:2:2","tags":["go 语法"],"title":"go 并发编程","uri":"/go_8/"},{"categories":["Go"],"content":"2.3 goroutine 中断 除了从主函数退出或者直接终止程序之外，没有其它的编程方法能够让一个goroutine来打断另一个的执行。但是通过 goroutine 之间的通信机制，可以实现让一个 goroutine 在收到其它的 goroutine 特定信号时终止退出。这个必须得等到我们讲完 channel 时才能继续说明。 ","date":"2021-01-08","objectID":"/go_8/:2:3","tags":["go 语法"],"title":"go 并发编程","uri":"/go_8/"},{"categories":["Go"],"content":"3. channels 如果说goroutine是Go语言程序的并发体的话，那么 channels 则是它们之间的通信机制。一个 channels 可以让一个 goroutine 通过它给另一个 goroutine 发送值信息。 每个channel都有一个特殊的类型，也就是channels可发送数据的类型。和其它的引用类型一样，channel的零值也是nil，因此channel 可以与 nil 值比较。两个相同类型的channel可以使用==运算符比较。如果两个channel引用的是相通的对象，那么比较的结果为真。 ","date":"2021-01-08","objectID":"/go_8/:3:0","tags":["go 语法"],"title":"go 并发编程","uri":"/go_8/"},{"categories":["Go"],"content":"3.1 channel 创建 创建 channel 最简单的方式是使用 make 函数，第二个可选参数，用于指定 channel 的容量。 ch = make(chan int) // 无缓存 channel ch = make(chan int, 0) // 无缓存 channel ch = make(chan int, 3) // 待缓存的 channel cap(ch) // 获取 channel 容量 len(ch) // 返回 channel 中有效元素个数 channel 与并发的先进先出队列极其相似: 发送在队尾插入元素，接收从队首删除元素 当 channel 空时，从 channel 接收值的 goroutine 将被阻塞，直至另一个 goroutine 向 channel 发送值 当 channel 满时，向 channel 发送值的 goroutine 将被阻塞，直至另一个 goroutine 从 channel 接收值 特别的对于无缓存 channels 的发送和接收操作将导致两个goroutine做一次同步操作，需要注意的是当通过一个无缓存 channels 发送数据时，接收者收到数据发生在唤醒发送者 goroutine 之前。 ","date":"2021-01-08","objectID":"/go_8/:3:1","tags":["go 语法"],"title":"go 并发编程","uri":"/go_8/"},{"categories":["Go"],"content":"3.2 发送与接收 channel有发送和接受两种操作: ch \u003c‐ x // 向 channel 发送一个值 x = \u003c‐ch // 从 channel 接收值 \u003c‐ch // 从 channel 接收值，但丢弃 close(ch) // 关闭 channel 为了防止 channel 被乱用，Go语言还提供了单方向的 channel 类型，即只发送或只接收的channel。 // 只发送和只接受的 channel 类型 chan\u003c‐ int // 只发送int的channel，不能接收 \u003c‐chan int // 只接收int的channel，不能发送 func squarer(out chan\u003c‐ int, in \u003c‐chan int) {} 任何双向channel向单向channel变量的赋值操作都将导致该隐式转换。但是没有反向转换的语法，即不能将类似 chan\u003c‐ int类型的单向型的channel转换为 chan int类型的双向型的channel。 因为关闭操作只用于断言不再向channel发送新的数据，所以只有在发送者所在的 goroutine 才会调用close函数，因此对一个只接收的channel调用 close 将是一个编译错误。 ","date":"2021-01-08","objectID":"/go_8/:3:2","tags":["go 语法"],"title":"go 并发编程","uri":"/go_8/"},{"categories":["Go"],"content":"3.3 关闭 channel还支持close操作，用于关闭channel，对于接收方和发送方，关闭channel之后的操作是不同的: 发送方: 对一个关闭的 channel 的任何发送操作都将导致panic异常，因此关闭操作只能由发送方执行 接收方: 在 channel 关闭之后依然可以接受到之前已经成功发送的数据；如果channel中已经没有数据，后续的接收操作也不会再阻塞，而是立即返回一个零值。稍后我们就会利用这个特性，通过关闭 channel实现一种广播机制。 所以对于下面这个例子，即使 naturals变量对应的channel 被关闭，循环也不会终止，它依然会收到一个永无休止的零值序列。 // Squarer go func() { for { x := \u003c‐naturals squares \u003c‐ x * x } }() 没有办法直接测试一个channel是否被关闭，但是接收操作有一个变体形式：它多接收一个结果，多接收的第二个结果是一个布尔值ok，ture表示成功从channels接收到值，false表示channels已经被关闭并且里面没有值可接收。range 可以简化对 channels 的读取和关闭测试，下面是一些代码示例: // 通过可选的第二个参数，在接收方判断 channel 是否关闭 go func() { for { x, ok := \u003c‐naturals if !ok { break // channel was closed and drained } squares \u003c‐ x * x } close(squares) }() // range循环可直接在channels上迭代，当channel被关闭并且没有值可接收时跳出循环 go func() { for x := range naturals { squares \u003c‐ x * x } close(squares) }() 最后，试图关闭一个nil值的channel也将导致panic异常。 ","date":"2021-01-08","objectID":"/go_8/:3:3","tags":["go 语法"],"title":"go 并发编程","uri":"/go_8/"},{"categories":["Go"],"content":"4. select 多路复用 有些时候，我们需要同时监听多个 channel 的接收和发送操作，并选择第一个可执行 channel 进行操作。此时我们就需要 select 多路复用。select 与 和 switch 语句稍微有点相似，select 也会有几个 case和最后的default选择分支。每一个case代表一个通信操作(在某个channel上进行发送或者接收)并且会包含一些语句组成的一个语句块。 select { case \u003c‐ch1: // ... case x := \u003c‐ch2: // ...use x... case ch3 \u003c‐ y: // ... default: // ... } select会等待case中的 channel 操作，直至出现一个可通信的 channel 时，执行通信并选择对应的 case 执行；这时候其它通信是不会执行的。一个没有任何case的select语句写作select{}，会永远地等待下去。如果多个case同时就绪时，select会随机地选择一个执行，这样来保证每一个channel都有平等的被select的机会。 对一个nil的channel发送和接收操作会永远阻塞，在select语句中操作nil的channel永远都不会被select到。这使得我们可以用nil来激活或者禁用case，来达成处理其它输入或输出事件时超时和取消的逻辑。 ","date":"2021-01-08","objectID":"/go_8/:4:0","tags":["go 语法"],"title":"go 并发编程","uri":"/go_8/"},{"categories":["Go"],"content":"5. goroutine 的中断 有了上面的铺垫，我们回头来看如何中断一个 goroutine 的执行。现在我们知道，当一个被关闭的 channel 被消费掉了所有已发送的值之后，对channel 的任何操作会立即被执行，并且产生零值。我们将代表取消操作的 channel 作为 select 的一个分支，一个立刻返回的分支；通过关闭 channel 让所有操作该 channel 的代码都可以立马执行，从而 select 会选择退出分支，让 goroutine 立刻终止。通过 channel 的取消操作，我们实现了一种广播机制。下面是一个简单的代码示例: # 广播机制 var done = make(chan struct{}) func cancelled() bool { select { case \u003c‐done: // channel 被关闭后，立马就会执行 return true default: return false } } # 监听用户的取消操作 go func() { os.Stdin.Read(make([]byte, 1)) // read a single byte close(done) // 通过关闭 channel，进行消息广播 }() func walkDir(dir string, n *sync.WaitGroup, fileSizes chan\u003c‐ int64) { defer n.Done() if cancelled() { // 发现用户取消，立刻终止 return } for _, entry := range dirents(dir) { // ... } } ","date":"2021-01-08","objectID":"/go_8/:5:0","tags":["go 语法"],"title":"go 并发编程","uri":"/go_8/"},{"categories":["Go"],"content":"6. 使用示例 接下来，我们将探究一个生成缩略图的问题来作为 goroutine 和 channel 的使用示例。下面是一个顺序执行的版本。 // makeThumbnails makes thumbnails of the specified files. func makeThumbnails(filenames []string) { for _, f := range filenames { # 缩略图执行的函数，具体代码省略 if _, err := thumbnail.ImageFile(f); err != nil { log.Println(err) } } } 显然，我们可以使用并发来加快程序的执行速度。 // NOTE: incorrect! func makeThumbnails2(filenames []string) { for _, f := range filenames { go thumbnail.ImageFile(f) // NOTE: ignoring errors } } 然而上面面的程序是有问题的，makeThumbnails(下称主函数)在 go 创建的 goroutine(下称 work goroutine) 还没有完成工作之前就已经返回了。我们需要主函数等待 work goroutine 完成。我们可以使用 channel 进行同步。 func makeThumbnails4(filenames []string) error { errors := make(chan error) for _, f := range filenames { go func(f string) { _, err := thumbnail.ImageFile(f) errors \u003c‐ err }(f) } for range filenames { if err := \u003c‐errors; err != nil { return err // NOTE: incorrect: goroutine leak! } } return nil } 这个程序有一个微秒的bug。当它遇到第一个非nil的error时会直接将error返回到调用方，使得没有一个goroutine去排空errors channel。这样剩下的worker goroutine在向这个channel中发送值时，都会永远地阻塞下去，并且永远都不会退出。即出现goroutine泄露，可能会导致整个程序卡住或者跑出out of memory的错误。 最简单的解决办法就是用一个具有合适大小的buffered channel(c\rh := make(chan item, len(filenames)))，这样这些worker goroutine向channel中发送错误时就不会被阻塞。另一个可选的解决办法是创建一个另外的goroutine，当maingoroutine返回第一个错误的同时去排空channel。 此外，如果文件过多，程序可能会创建成百上千的 goroutine，我们需要用计数信号量来限制并发的数量。 // 限制并发数的信号量 var sema = make(chan struct{}, 20) go func(f string) { sema \u003c‐ struct{}{} // 执行前获取 token defer func() { \u003c‐sema }() // 执行结束后释放 token _, err := thumbnail.ImageFile(f) errors \u003c‐ err }(f) ","date":"2021-01-08","objectID":"/go_8/:6:0","tags":["go 语法"],"title":"go 并发编程","uri":"/go_8/"},{"categories":["Go"],"content":"7. 使用局限 至此，我们已经掌握了goroutine 和 channel的基本使用，但是还远远不够。我们无法解决像下面这些问题: 1. ","date":"2021-01-08","objectID":"/go_8/:7:0","tags":["go 语法"],"title":"go 并发编程","uri":"/go_8/"},{"categories":["Go"],"content":"go 接口的定义、使用以及类型断言","date":"2021-01-07","objectID":"/go_7/","tags":["go 语法"],"title":"go 接口","uri":"/go_7/"},{"categories":["Go"],"content":"Go 的泛型编程 ","date":"2021-01-07","objectID":"/go_7/:0:0","tags":["go 语法"],"title":"go 接口","uri":"/go_7/"},{"categories":["Go"],"content":"1. 接口概述 接口是 Go 语言提供的泛型的核心概念。所谓泛型就是允许程序员在强类型程序设计语言中编写代码时使用一些以后才指定的类型，目的是增加函数的通用性。当然我们没必要去纠结概念，最重要的是搞明白，Go 如何通过接口来提高程序的灵活性。 在学习接口之前，我们需要对它有如下一个整体的认识，以把握住接口的整体脉络: Go 的接口类型是抽象类型，与 Python 中鸭子类型类似，通过类型支持的方法来约束对象的适用范围。我们将学些如何在 Go 定义接口，如何判断一个具体类型实现了哪些接口。 接口不仅是对类型的抽象和限定，也代表了将接口作为参数的函数和函数调用者之间的一个约定(正是通过这种约定提高了函数的可用性): 调用者需要提供符合接口的具体类型作为参数 函数在接受任何满足接口的值时都可以工作，函数不会调用接口限定之外的任何其他方法 有了上面的铺垫，我们将按照下面的顺序介绍接口的相关内容: 接口类型 接口的定义 接口归属判断 接口的约定 接口值 类型断言 ","date":"2021-01-07","objectID":"/go_7/:1:0","tags":["go 语法"],"title":"go 接口","uri":"/go_7/"},{"categories":["Go"],"content":"2. 接口类型 ","date":"2021-01-07","objectID":"/go_7/:2:0","tags":["go 语法"],"title":"go 接口","uri":"/go_7/"},{"categories":["Go"],"content":"2.1 接口定义 接口类型是一种抽象的类型，与字符串，整数这些具体类型相比，我们并不知道接口类型代表的具体值；它只包含方法声明，描述了一系列方法的集合。下面是 Go 接口类型的定义示例: package io type Reader interface { Read(p []byte) (n int, err error) } type Closer interface { Close() error } type Writer interface { Write(p []byte) (n int, err error) } type ReadWriter interface { Reader Writer } 与结构体嵌入类似，我们也可以通过类似的方式进行接口内嵌，实现接口组合。在接口的定义中方法的定义顺序没有影响，唯一重要的是接口内的方法集合。 ","date":"2021-01-07","objectID":"/go_7/:2:1","tags":["go 语法"],"title":"go 接口","uri":"/go_7/"},{"categories":["Go"],"content":"2.2 接口归属判断 如果一个类型拥有一个接口需要的所有方法，那么这个类型就实现了这个接口，我们称这个具体类型是这个接口类型的实例。正如我们在 go 方法一章所描述的，一个自定义数据类型的方法集合中仅会包含它的所有值方法，而该类型的指针类型的方法集合却囊括了所有值方法和所有指针方法。因此对于一个自定义类型，他的类型和他的指针类型实现的接口并不相同。 // 1. 表达一个类型属于某个接口只要这个类型实现这个接口 var rwc io.ReadWriteCloser rwc = os.Stdout // OK: *os.File has Read, Write, Close methods rwc = new(bytes.Buffer) // compile error: *bytes.Buffer lacks Close method // 2. 接口归属的判断同样适合接口之间 w = rwc // OK: io.ReadWriteCloser has Write method rwc = w // compile error: io.Writer lacks Close method // 3. 类型 与 类型的指针类型，实现的接口并不相同，后者可能实现了更多的接口 type IntSet struct { /* ... */ } func (*IntSet) String() string var _ fmt.Stringer = \u0026s // OK var _ fmt.Stringer = s // compile error: IntSet lacks String method 每一个具体类型的组基于它们相同的行为可以表示成一个接口类型。接口不止是一种有用的方式来分组相关的具体类型和表示他们之间的共同特定。在Go语言中我们可以在需要的时候定义一个新的抽象或者特定特点的组，而不需要修改具体类型的定义。 ","date":"2021-01-07","objectID":"/go_7/:2:2","tags":["go 语法"],"title":"go 接口","uri":"/go_7/"},{"categories":["Go"],"content":"2.3 接口的约定 正如我们开篇所说的，接口类型不仅是对类型的约束，也代表着函数和调用者之间的约定。 type Writer interface { Write(p []byte) (n int, err error) } func Fprintf(w io.Writer, format string, args ...interface{}) (int, error) type ByteCounter int func (c *ByteCounter) Write(p []byte) (int, error) { *c += ByteCounter(len(p)) // convert int to ByteCounter return len(p), nil } var c ByteCounter c.Write([]byte(\"hello\")) fmt.Println(c) // \"5\", = len(\"hello\") c = 0 // reset the counter var name = \"Dolly\" fmt.Fprintf(\u0026c, \"hello, %s\", name) fmt.Println(c) // \"12\", = len(\"hello, Dolly\") 如上例所述，io.Writer 接口约定了，函数调用者必须提供实现了 io.Writer 接口的具体类型作为函数参数，而 Fprintf 函数只能调用 io.Writer 接口暴露出来的方法，即使具体类型有其它的方法也不能调用。 ","date":"2021-01-07","objectID":"/go_7/:2:3","tags":["go 语法"],"title":"go 接口","uri":"/go_7/"},{"categories":["Go"],"content":"2.4 空接口 interface{}被称为空接口，空接口类型是不可或缺的。因为空接口类型对实现它的类型没有要求，所以我们可以将任意一个值赋给空接口类型。当然我们不能直接对它持有的值做操作，因为interface{}没有任何方法。我们会在稍后介绍一种用类型断言来获取interface{}中值的方法。 var any interface{} any = true any = 12.34 any = \"hello\" any = map[string]int{\"one\": 1} any = new(bytes.Buffer) ","date":"2021-01-07","objectID":"/go_7/:2:4","tags":["go 语法"],"title":"go 接口","uri":"/go_7/"},{"categories":["Go"],"content":"3. 接口的值 ","date":"2021-01-07","objectID":"/go_7/:3:0","tags":["go 语法"],"title":"go 接口","uri":"/go_7/"},{"categories":["Go"],"content":"3.1 接口赋值 概念上讲一个接口的值，由两个部分组成，一个具体的类型和那个类型的值。它们被称为接口的动态类型和动态值。对于像Go语言这种静态类型的语言，类型是编译期的概念；因此一个类型不是一个值。在我们的概念模型中，一些提供每个类型信息的值被称为类型描述符，比如类型的名称和方法。在一个接口值中，类型部分代表与之相关类型的描述符。 我们通过下面一个赋值的示例来了解接口的值 var w io.Writer w = os.Stdout w = new(bytes.Buffer) w = nil var w io.Writer 定义了变量w，变量总是被一个定义明确的值初始化，即使接口类型也不例外。对于一个接口的零值就是它的类型和值的部分都是nil。一个接口值仅基于它的动态类型被描述为空或非空，因此一个不包含任何值的nil接口值和一个刚好包含nil指针的接口值是不同的，后者不为 nil。 你可以通过使用w==nil或者w!=nil来判读接口值是否为空。调用一个空接口值上的任意方法都会产生panic。调用一个包含 nil 指针的接口上的方法是否会报错，取决于接口内包含的动态类型。 // w，f 都是特定类型的空值，将他们赋值给 w 都将得到一个 包含nil指针的接口值 var w io.Writer var f *os.File var buf *bytes.Buffer // 对 *os.File的类型，nil是一个有效的接收者，所以不会报错 w = f w.Writer() // (*bytes.Buffer).Write方法的接收者必须非空，调用会报错 w = buf buf，Writer() w = os.Stdout 这个赋值过程调用了一个具体类型到接口类型的隐式转换，这和显式的使用io.Writer(os.Stdout)是等价的。此时这个接口值的动态类型被设为*os.File指针的类型描述符，它的动态值持有os.Stdout的拷贝； w = nil 这个重置将它所有的部分都设为nil值，把变量w恢复到和它之前定义时的状态。 一个接口值可以持有任意大的动态值。从概念上讲，不论接口值多大，动态值总是可以容下它。（这只是一个概念上的模型；具体的实现可能会非常不同） ","date":"2021-01-07","objectID":"/go_7/:3:1","tags":["go 语法"],"title":"go 接口","uri":"/go_7/"},{"categories":["Go"],"content":"3.2 接口比较 接口值可以使用==和!＝来进行比较。两个接口值相等仅当它们都是nil值或者它们的动态类型相同并且动态值也根据这个动态类型的==操作相等。因为接口值是可比较的，所以它们可以用在map的键或者作为switch语句的操作数。 然而，如果两个接口值的动态类型相同，但是这个动态类型是不可比较的（比如切片），将它们进行比较就会失败并且panic: var x interface{} = []int{1, 2, 3} fmt.Println(x == x) // panic: comparing uncomparable type []int 考虑到这点，接口类型是非常与众不同的。其它类型要么是安全的可比较类型（如基本类型和指针）要么是完全不可比较的类型（如切片，映射类型，和函数），但接口的可比性取决接口包含的动态类型。但是在比较接口值或者包含了接口值的聚合类型时，我们必须要意识到潜在的panic。同样的风险也存在于使用接口作为map的键或者switch的操作数。只能比较你非常确定它们的动态值是可比较类型的接口值。 通过 fmt包的%T 动作，我们可以获取接口值的动态类型，在fmt包内部，使用反射来获取接口动态类型的名称。关于反射，我们后面在详述。 var w io.Writer fmt.Printf(\"%T\\n\", w) // \"\u003cnil\u003e\" w = os.Stdout fmt.Printf(\"%T\\n\", w) // \"*os.File\" w = new(bytes.Buffer) fmt.Printf(\"%T\\n\", w) // \"*bytes.Buffer\" ","date":"2021-01-07","objectID":"/go_7/:3:2","tags":["go 语法"],"title":"go 接口","uri":"/go_7/"},{"categories":["Go"],"content":"4. 类型断言 类型断言是我们使用 Go 语言中接口的另一种方式。前面的第一个方式中，一个接口的方法表达了实现这个接口的具体类型间的相似性，但是隐藏了代表的细节和这些具体类型本身的操作。重点在于方法上，而不是具体的类型上。 第二种使用方式利用了一个接口值可以持有各种具体类型值的能力并且将这个接口认为是这些类型的 union（联合）。类型断言用来动态地区别出接口包含的每一个类型，做不同处理。在这个方式中，重点在于具体的类型满足这个接口，而不是在于接口的方法（如果它确实有一些的话），并且没有任何的信息隐藏。我们将以这种方式使用的接口描述为discriminated unions（可辨识联合）。 通过类型断言，我们至少可以实现下面这些目标: 区别错误类型 判断对象是否支持特定的方法 ","date":"2021-01-07","objectID":"/go_7/:4:0","tags":["go 语法"],"title":"go 接口","uri":"/go_7/"},{"categories":["Go"],"content":"4.1 语法 x.(T): x - 表示待判断的接口类型，T - 表示断言的类型 如果 T 是一个具体类型，类型断言检查 x 的动态类型是否和T相同，相同，返回 x 的动态值 如果 T 是一个接口类型，类型断言检查 x 的动态类型是否满足T，满足，返回包含 x 动态类型和动态值的接口 T 的值 // 具体类型断言 var w io.Writer w = os.Stdout rw := w.(io.ReadWriter) // success: *os.File has both Read and Write w = new(ByteCounter) rw = w.(io.ReadWriter) // panic: *ByteCounter has no Read method， 断言失败触发 panic // 接口类型断言 var w io.Writer = os.Stdout f, ok := w.(*os.File) // success: ok, f == os.Stdout b, ok := w.(*bytes.Buffer) // failure: !ok, b == nil // 通过第二个变量接受断言是否成功，替代断言失败时的异常 if w, ok := w.(*os.File); ok { // if 引出了新的作用域，因此这里发生的是对变量名的重新，发生了变量的覆盖，不是变量的重新赋值。 // ...use w... } 换句话说，对一个接口类型的断言改变了类型的表述方式，改变了可以获取的方法集合（通常更大），我们几乎不需要对一个更少限制性的接口类型（更少的方法集合）做断言，因为它表现的就像赋值操作一样，除了对于nil接口值的情况。如果断言操作的对象是一个nil接口值，那么不论被断言的类型是什么这个类型断言都会失败。 // 对更小的接口无需断言，可直接赋值 w = rw // io.ReadWriter is assignable to io.Writer w = rw.(io.Writer) // fails only if rw == nil ","date":"2021-01-07","objectID":"/go_7/:4:1","tags":["go 语法"],"title":"go 接口","uri":"/go_7/"},{"categories":["Go"],"content":"4.2 类型开关 类型断言有一个 Switch 的便捷语法，称为类型开关，一个类型开关像普通的switch语句一样，它的运算对象是x.(type)－它使用了关键词字面量type－并且每个case有一到多个类型。一个类型开关基于这个接口值的动态类型使一个多路分支有效。一个使用示例如下所示: func sqlQuote(x interface{}) string { switch x := x.(type) { case nil: return \"NULL\" case int, uint: return fmt.Sprintf(\"%d\", x) // x has type interface{} here. case bool: if x { return \"TRUE\" } return \"FALSE\" case string: return sqlQuoteString(x) // (not shown) default: panic(fmt.Sprintf(\"unexpected type %T: %v\", x, x)) } } 这个示例还展示了，类型开关语句的一个扩展的形式，它可以将提取的值绑定到一个在每个case范围内的新变量 switch x := x.(type) { /* ... */ }。在这个版本的函数中，在每个单一类型的case内部，变量x和这个case的类型相同。例如: 变量 x 在bool的case中是bool类型和string的case中是string类型 在所有其它的情况中，变量x是 switch 运算对象的类型（接口）；在这个例子中运算对象是一个interface{} 当多个 case 需要相同的操作时，比如int和uint的情况，类型开关可以很容易的合并这些情况 ","date":"2021-01-07","objectID":"/go_7/:5:0","tags":["go 语法"],"title":"go 接口","uri":"/go_7/"},{"categories":["Go"],"content":"使用 struct 实现对象组合和类型嵌套","date":"2021-01-06","objectID":"/go_6/","tags":["go 语法"],"title":"go 的结构体和方法","uri":"/go_6/"},{"categories":["Go"],"content":"Go 的对象组合技术 ","date":"2021-01-06","objectID":"/go_6/:0:0","tags":["go 语法"],"title":"go 的结构体和方法","uri":"/go_6/"},{"categories":["Go"],"content":"1. 内容概要 方法是面向对象编程(OOP)中的概念。有关 OOP 的定义我也说不清楚。但是与概念相比，更重要的是OOP的两个关键点:封装和组合。我们的目的是看看 Go 语言如何通过结构体嵌入等技术实现这两个关键点。 Go 语言中的方法和接口密切相关，接口是 Go 语言提供的用来支持泛型编程的核心组件，我们会在下一章详细讨论。现在我们只需要明白: 方法是与特定类型关联的函数，可以被声明到任意命名类型，包括 Go 的内置类型;但不能是一个指针或者一个接口类型 方法分为值方法和指针方法两类，这会影响到类型是否属于特定接口的判断 ","date":"2021-01-06","objectID":"/go_6/:1:0","tags":["go 语法"],"title":"go 的结构体和方法","uri":"/go_6/"},{"categories":["Go"],"content":"2. 方法 ","date":"2021-01-06","objectID":"/go_6/:2:0","tags":["go 语法"],"title":"go 的结构体和方法","uri":"/go_6/"},{"categories":["Go"],"content":"2.1 方法声明 在函数声明时，在其名字之前放上一个变量，即是一个方法。这个附加的参数会将该函数附加到这种类型上，即相当于为这种类型定义了一个独占的方法。 type Point struct{ X, Y float64 } // 1. 为 Point 定义一个值方法 // 参数p，叫做方法的接收器(receiver) func (p Point) Distance(q Point) float64 { return math.Hypot(q.X‐p.X, q.Y‐p.Y) } // 2. 调用方法 p := Point{1, 2} q := Point{4, 6} fmt.Println(p.Distance(q)) // \"5\", method call 从上面的示例可以看出来，在方法的定义和调用等行为上，Go 与 Python 并没有什么太大差别。有一点不同的是，当出现命名冲突时，Python 的默认行为是覆盖，而 Go 在编译阶段就直接失败。此外需要注意的是方法和属性在同一命名空间，因此它们之间的命名冲突也是不允许的。 ","date":"2021-01-06","objectID":"/go_6/:2:1","tags":["go 语法"],"title":"go 的结构体和方法","uri":"/go_6/"},{"categories":["Go"],"content":"2.2 值方法与指针方法 前面函数的部分我们说过，Go 中实参通过值的方式传递。类似的，传递给方法接收器的对象也是按值传递。在上面的 Distance 内接收器 p 是外部 p 对象的拷贝。相对应的我们可以像下面这样，用其指针而不是对象来声明方法。 func (p *Point) ScaleBy(factor float64) { p.X *= factor p.Y *= factor } ","date":"2021-01-06","objectID":"/go_6/:2:2","tags":["go 语法"],"title":"go 的结构体和方法","uri":"/go_6/"},{"categories":["Go"],"content":"2.3 接收器限制 只有类型(Point)和指向他们的指针(*Point)，才是可能会出现在接收器声明里的两种接收器。为了避免歧义，在声明方法时，如果一个类型名本身是一个指针的话，是不允许其出现在接收器中的，比如下面这个例子。即我们不能为指针定义方法。 type P *int func (P) f() { /* ... */ } // compile error: invalid receiver type ","date":"2021-01-06","objectID":"/go_6/:2:3","tags":["go 语法"],"title":"go 的结构体和方法","uri":"/go_6/"},{"categories":["Go"],"content":"2.4 方法调用中的隐式转换 原则上，类型 Point只能调用其值方法，*Point只能调用其指针方法。这样在方法的调用中会有很多转换操作。幸运的是，Go 为我们提供了隐示的转换，就像我们直接通过指针去访问结构的成员变量一样。 p := Point{1, 2} pptr := \u0026p // type --\u003e *type p.ScaleBy(2) // 等同于 (\u0026p).ScaleBy(2) // *type --\u003e type pptr.Distance(q) // 等同于 (*pptr).Distance(q) 需要特别注意的是 type --\u003e *type 转换的前提是对象是可取址的。我们不能通过一个无法取到地址的接收器来调用指针方法，比如临时变量： Point{1, 2}.ScaleBy(2) // compile error: can't take address of Point literal ","date":"2021-01-06","objectID":"/go_6/:2:4","tags":["go 语法"],"title":"go 的结构体和方法","uri":"/go_6/"},{"categories":["Go"],"content":"2.5 类型的方法集合 如上所述，正因为我们总是可以通过对一个地址解引用(*)来获取变量，但是却不一定能获取一个对象的地址(临时对象)，所以一个自定义数据类型的方法集合中仅会包含它的所有值方法，而该类型的指针类型的方法集合却囊括了前者的所有方法，包括所有值方法和所有指针方法。 //1. pkg 包内定义 animal 和 Dog package pkg type animal struct { Name string } type Dog struct { animal Weight int } func NewDog() Dog { return Dog{animal{\"aaa\"}, 100} } func (g Dog) GetName() string { return g.Name } func (g *Dog) GetWeight() int { return g.Weight } // 2 mian 包内使用 package main import ( \"fmt\" \"mygo/pkg\" ) func main() { g := pkg.NewDog() fmt.Printf(\"%T, %#v\\n\", g, g) fmt.Println(g.Weight) // 注意: 此处我们可以直接访问 g.Weight fmt.Println(g.Name) fmt.Printf(\"%T\\n\", (*pkg.Dog).GetName) // func(*pkg.Dog) string fmt.Printf(\"%T\\n\", (*pkg.Dog).GetWeight) // func(*pkg.Dog) int fmt.Printf(\"%T\\n\", pkg.Dog.GetName) // func(pkg.Dog) string // fmt.Printf(\"%T\\n\", pkg.Dog.GetWeight) } 在上面的示例中: 通过结构体直接访问方法，我们将获取一个方法值，值方法是一个函数，其接受的参数与调用的方式有关，以结构体调用，返回的函数需要接受结构体，以结构体指针调用，返回的函数需要接受结构体的指针 所有的值方法可以通过结构体，也可以通过结构体的指针进行访问，所有的指针方法只能通过结构体指针进行访问 这里也反应出一个自定义数据类型的方法集合中仅会包含它的所有值方法，而该类型的指针类型的方法集合却囊括了前者的所有方法，包括所有值方法和所有指针方法。 ","date":"2021-01-06","objectID":"/go_6/:2:5","tags":["go 语法"],"title":"go 的结构体和方法","uri":"/go_6/"},{"categories":["Go"],"content":"3. 结构体嵌入 ","date":"2021-01-06","objectID":"/go_6/:3:0","tags":["go 语法"],"title":"go 的结构体和方法","uri":"/go_6/"},{"categories":["Go"],"content":"3.1 结构体嵌入与类的继承 在结构体一节中，我们就已经提到了，结构体中通过匿名字段嵌入的不仅仅是结构体的成员还是其方法。以下面嵌入了 Point 的 ColoredPoint 为例，我们可以把ColoredPoint类型当作接收器来调用Point里的方法，即使ColoredPoint里没有声明这些方法。 import \"image/color\" type Point struct{ X, Y float64 } type ColoredPoint struct { Point Color color.RGBA } red := color.RGBA{255, 0, 0, 255} blue := color.RGBA{0, 0, 255, 255} var p = ColoredPoint{Point{1, 1}, red} var q = ColoredPoint{Point{5, 4}, blue} fmt.Println(p.Distance(q.Point)) // \"5\" p.ScaleBy(2) q.ScaleBy(2) fmt.Println(p.Distance(q.Point)) // \"10\" 这种行为看起来跟 OOP 类的继承一样，但是有本质区别。最明显的地方是，在类的继承中，子类的实例也是基类的实例，但是在结构体嵌入中，ColoredPoint 类型的\"实例\"，并不是 Point 的\"实例\"。 请注意上面例子中对Distance方法的调用。尽管q有着Point这个内嵌类型，但是q并不是一个Point类，我们必须要显式地选择它。 p.Distance(q.Point) // right p.Distance(q) // compile error: cannot use q (ColoredPoint) as Point 在 Go 的结构体嵌入中，我们只能说 ColoredPoint has a Point 而不能说 ColoredPoint 继承自 Point。内嵌可以使我们将复杂类型的定义拆分，将字段先按小类型分组，然后定义小类型的方法，之后再把它们组合起来。 ","date":"2021-01-06","objectID":"/go_6/:3:1","tags":["go 语法"],"title":"go 的结构体和方法","uri":"/go_6/"},{"categories":["Go"],"content":"3.2 嵌入命名类型的指针 在类型中内嵌的匿名字段也可能是一个命名类型的指针，添加这一层间接关系让我们可以共享通用的结构并动态地改变对象之间的关系。 type ColoredPoint struct { *Point Color color.RGBA } p := ColoredPoint{\u0026Point{1, 1}, red} q := ColoredPoint{\u0026Point{5, 4}, blue} // 注意访问 *q.Point 的区别 fmt.Println(p.Distance(*q.Point)) // \"5\" q.Point = p.Point // p and q now share the same Point p.ScaleBy(2) fmt.Println(*p.Point, *q.Point) // \"{2 2} {2 2}\" ","date":"2021-01-06","objectID":"/go_6/:3:2","tags":["go 语法"],"title":"go 的结构体和方法","uri":"/go_6/"},{"categories":["Go"],"content":"3.3 多匿名字段的查找顺序 如果结构体中嵌入了多个匿名字段，将遵循下面的字段和方法查找顺序: 直接定义在类型里方法 内嵌字段引入的方法 内嵌字段的内嵌字段引入的方法，然后一直递归向下找 如果在同一级里有两个同名的方法，编译器会报错 上面说的同一级可以理解为，由内嵌所构成的树的同一层。 type A struct { A1 } type A1 struct { } type B struct { B1 } type B1 struct{ } func (a A1) name() { fmt.Println(\"a1\") } func (b B1) name() { fmt.Println(\"b1\") } type C struct { A B } c := C{} // 同一级的 A1，B1 的 同名 name 方法导致编译错误 c.name() // ambiguous selector c.name ","date":"2021-01-06","objectID":"/go_6/:3:3","tags":["go 语法"],"title":"go 的结构体和方法","uri":"/go_6/"},{"categories":["Go"],"content":"4. 封装 一个对象的变量或者方法如果对调用方是不可见的话，一般就被定义为“封装”。封装有时候也被叫做信息隐藏，同时也是面向对象编程最关键的一个方面。 Go语言只有一种控制可见性的手段：大写首字母的标识符会从定义它们的包中被导出，小写字母的则不会。这种限制包内成员的方式同样适用于struct或者一个类型的方法。因而如果我们想要封装一个对象，我们必须将其定义为一个struct。 这种基于名字的手段使得在语言中最小的封装单元是package。一个struct类型的字段对同一个包的所有代码都有可见性，无论你的代码是写在一个函数还是一个方法里。 ","date":"2021-01-06","objectID":"/go_6/:4:0","tags":["go 语法"],"title":"go 的结构体和方法","uri":"/go_6/"},{"categories":["Go"],"content":"go 函数的使用","date":"2021-01-05","objectID":"/go_5/","tags":["go 语法"],"title":"go 函数","uri":"/go_5/"},{"categories":["Go"],"content":"函数，代码封装的基本单元 ","date":"2021-01-05","objectID":"/go_5/:0:0","tags":["go 语法"],"title":"go 函数","uri":"/go_5/"},{"categories":["Go"],"content":"1. 函数 函数通常使用起来并不复杂，定义或声明函数后，直接使用即可。但是为了函数更加易用，编程语言会为函数添加很多特性。在 Python 和 Go 中，函数都是一等\"公民\"，即函数可以用在任何变量可以使用的地方，并且具有类型。因此接下来我们按照下面的顺序来讲解 Go 函数的相关内容: 第一部分: Go 函数作为基础数据类型的特性: 函数声明 函数的类型 函数的零值 第二部分: Go 函数语言层的特性 匿名函数与闭包 异常处理 Deferred ","date":"2021-01-05","objectID":"/go_5/:0:1","tags":["go 语法"],"title":"go 函数","uri":"/go_5/"},{"categories":["Go"],"content":"2. 函数 ","date":"2021-01-05","objectID":"/go_5/:1:0","tags":["go 语法"],"title":"go 函数","uri":"/go_5/"},{"categories":["Go"],"content":"2.1 函数声明 Go 函数声明包括函数名、形式参数列表、返回值列表（可省略）以及函数体。函数的参数，返回值以及函数调用时的传值方式是函数的核心。 func name(parameter‐list) (result‐list) { body } 下面是几个函数声明的示例: func hypot(x, y float64) float64 { return math.Sqrt(x*x + y*y) } // 参数类型相同时，可以合并 func f(i, j, k int, s, t string) { /* ... */ } func f(i int, j int, k int, s string, t string) { /* ... */ } // func add(x int, y int) int {return x + y} func sub(x, y int) (z int) { z = x ‐ y; return} func first(x int, _ int) int { return x } // _ 可以强调某个参数未被使用 func zero(int, int) int { return 0 } // 在返回值的类型都相同时， 返回值变量名可以传达函数返回值的含义 func Size(rect image.Rectangle) (width, height int) func Split(path string) (dir, file string) 返回值 与 Python 默认返回 None 不同，Go 有返回值列表，但是没有默认的返回值，返回值列表就是对函数返回值的约束: 返回值列表描述了函数返回值的变量名以及类型 如果没有返回值列表，函数不能返回任何值 如果包含返回值列表，函数必须返回与返回值列表类型相符的值 返回值可以被命名，此时每个返回值被声明成一个局部变量，并根据返回值的类型，被其初始化为 0 当如果函数返回一个无名变量或者没有返回值，返回值列表的括号可以省略。 Go 的函数返回值符合 Go 强变量类型的约束。 参数 Go 函数参数没有默认值，也不能通过参数名指定行参。每一次函数调用都必须按照声明顺序为所有参数提供实参（参数值）。因此形参和返回值的变量名对于函数调用者而言没有意义。 为了让函数更加通用，Go 和 Python 都提供了可变参数的特性。在 Go 中声明可变参数时，需要在参数列表的最后一个参数类型之前加上省略符号“…”，这表示该函数会接收任意数量的该类型参数。 func sum(vals...int) int { total := 0 for _, val := range vals { total += val } return total } // fmt.Println(sum()) // \"0\" fmt.Println(sum(3)) // \"3\" fmt.Println(sum(1, 2, 3, 4)) // \"10\" 在上面的代码中，调用者隐式的创建一个数组，并将原始参数复制到数组中，再把数组的一个切片作为参数传给被调函数。如果原始参数已经是切片类型，可以像下面这样向函数传递参数。 // values := []int{1, 2, 3, 4} fmt.Println(sum(values...)) // \"10\" ","date":"2021-01-05","objectID":"/go_5/:1:1","tags":["go 语法"],"title":"go 函数","uri":"/go_5/"},{"categories":["Go"],"content":"2.2 函数类型与值 Go 中函数的类型被称为函数的标识符，函数的取决于参数和返回值的类型: 如果两个函数形式参数列表和返回值列表中的变量类型一一对应，那么它们有相同的类型和标识符 形参和返回值的变量名不不会影响函数标识符 函数类型的零值是 nil。调用值为nil的函数值会引起panic错误。函数值可以与nil比较，但是函数值之间是不可比较的，也不能用函数值作为map的key。函数之间之所以不可比，是因为函数闭包，函数会保留定义函数时，存在的自由变量的绑定。我们会在下面讲解。 // 此处f的值为nil, 会引起panic错误 var f func(int) int f(3) // 函数与 nil 比较 var f func(int) int if f != nil { f(3) } ","date":"2021-01-05","objectID":"/go_5/:1:2","tags":["go 语法"],"title":"go 函数","uri":"/go_5/"},{"categories":["Go"],"content":"2.3 函数调用的传值方式 我们把调用函数时传递给函数的值称为实参，函数接收参数值的变量称为行参。 Go 中实参通过值的方式传递，因此函数的形参是实参的拷贝。对形参进行修改不会影响实参。但是，如果实参包括引用类型，如指针，slice(切片)、map、function、channel等类型，实参可能会由于函数的间接引用被修改。 在函数体中，函数的形参作为局部变量，被初始化为调用者提供的值。函数的形参和有名返回值作为函数最外层的局部变量，被存储在相同的词法块中。我们甚至可以直接修返回值变量，来修改函数的返回值。我们会在讲解 Deffer 时详述。 说完了函数作为基本类型的特性，我们再来看为了方便编程，Go 为函数提供的语言层特性。 ","date":"2021-01-05","objectID":"/go_5/:1:3","tags":["go 语法"],"title":"go 函数","uri":"/go_5/"},{"categories":["Go"],"content":"3. 函数特性 ","date":"2021-01-05","objectID":"/go_5/:2:0","tags":["go 语法"],"title":"go 函数","uri":"/go_5/"},{"categories":["Go"],"content":"3.1 函数闭包 Go 里面一个有意思的地方是拥有函数名的函数只能在包级语法块中被声明。即我们不能在函数内部使用，使用 func name(parameter‐list) (result‐list) 方式定义函数，但不带 name 的 func (parameter‐list) (result‐list) 匿名函数可以。func (parameter‐list) (result‐list) 是 Go 函数的函数字面量。函数值字面量是一种表达式，它的值被成为匿名函数（anonymousfunction） 说起来比较绕，即如果我们想在函数内定义命名函数必须使用下面这种方式；或者直接使用匿名函数。 // 1. 函数内定义命名函数 func f1(a, b int) (r int) { v := func() { r += b } defer v() return a + b } // 2. 直接使用匿名函数 func squares() func() int { var x int return func() int { x++ return x * x } } f := squares() fmt.Println(f()) // \"1\" fmt.Println(f()) // \"4\" 注意在上面第二个示例中，squares中定义的匿名内部函数可以访问和更新squares中的局部变量，这意味着匿名函数和squares中存在变量引用。这就是函数闭包，也是函数值属于引用类型和函数值不可比较的原因。 需要注意的是函数闭包内保存的是变量的引用而不是变量的值。我们来看下面删除临时文件的示例: var rmdirs []func() for _, dir := range tempDirs() { // dir := d // NOTE: necessary! os.MkdirAll(dir, 0755) rmdirs = append(rmdirs, func() { os.RemoveAll(dir) // NOTE: incorrect! }) } 在上面的程序中，for循环语句引入了新的词法块，循环变量dir在这个词法块中被声明。在该循环中生成的所有函数值都共享相同的循环变量。需要注意，函数值中记录的是循环变量的内存地址，而不是循环变量某一时刻的值。以dir为例，后续的迭代会不断更新dir的值，当删除操作执行时，for循环已完成，dir中存储的值等于最后一次迭代的值。这意味着，每次对os.RemoveAll的调用删除的都是相同的目录。 如果你使用go语句或者defer语句会经常遇到此类问题。这不是go或defer本身导致的，而是因为它们都会等待循环结束后，再执行函数值。 ","date":"2021-01-05","objectID":"/go_5/:2:1","tags":["go 语法"],"title":"go 函数","uri":"/go_5/"},{"categories":["Go"],"content":"3.2 Defer 机制 Go 的 Defer 机制与 Python 的上下文管理器有点类似，都是为了保证某些代码一定要执行，无论代码是否出现了异常。 defer 的语法很简单，只需要在调用普通函数或方法前加上关键字defer。 当defer语句被执行时，跟在defer后面的函数会被延迟执行。 直到包含该defer语句的函数执行完毕时，defer后的函数才会被执行，不论包含defer语句的函数是通过return正常结束，还是由于panic导致的异常结束。 可以在一个函数中执行多条defer语句，它们的执行顺序与声明顺序相反。 通过defer机制，不论函数逻辑多复杂，都能保证在任何执行路径下，资源被释放。释放资源的defer应该直接跟在请求资源的语句后。需要注意的是跟在 defer 之后的是函数调用，而不是函数本身。 // defer 关闭文件 package ioutil func ReadFile(filename string) ([]byte, error) { f, err := os.Open(filename) if err != nil { return nil, err } defer f.Close() return ReadAll(f) } // 释放锁 var mu sync.Mutex var m = make(map[string]int) func lookup(key string) int { mu.Lock() defer mu.Unlock() return m[key] } 利用 defer中的函数会在return语句更新返回值变量后再执行，以及在函数中定义的匿名函数可以访问该函数包括返回值变量在内的所有变量，我们就可以上面说到的改变函数返回值的目的。 func triple(x int) (result int) { defer func() { result += x }() return double(x) } fmt.Println(triple(4)) // \"12 ","date":"2021-01-05","objectID":"/go_5/:2:2","tags":["go 语法"],"title":"go 函数","uri":"/go_5/"},{"categories":["Go"],"content":"3.3 错误与异常处理 严格的区分错误和异常，应该是 Go 编码风格一个最大的特点。在Go中，错误是程序运行的几个预期的结果之一。而异常是未被预料到的错误，即bug，而不是那些在健壮程序中应该被避免的程序错误。正因为如此，在 Go 的代码中你会看到很多类似下面的条件判断。Go 将对错误的处理放在了代码的逻辑控制中，让程序员更多的关注错误。 // 导致失败的原因只有一个，额外的返回值可以是一个布尔值，通常被命名为ok value, ok := cache.Lookup(key) if !ok { // ...cache[key] does not exist… } // 导致失败的原因不止一种时，额外的返回值是error类型， resp, err := http.Get(url) if err != nil{ return nill, err } 错误处理 对于那些将运行失败看作是预期结果的函数，它们会返回一个额外的返回值，通常是最后一个，来传递错误信息。调用者需要处理程序出现的潜在错误。因此Go中大部分函数的代码结构几乎相同，首先是一系列的初始检查，防止错误发生，之后是函数的实际逻辑。 对于函数返回的错误，通常有以下五种处理方式: 传播错误 重新尝试失败的操作 输出错误信息并结束程序 有时，只输出错误信息就足够了，不需要中断程序的运行 直接忽略掉错误 需要注意的是，输出错误信息并结束程序只应在main中执行。对库函数而言，应仅向上传播错误，除非该错误意味着程序内部包含不一致性，即遇到了bug，才能在库函数中结束程序。 异常处理 Go 中的异常称为 Panic。一般而言，当panic异常发生时，程序会中断运行，并立即执行在该goroutine 中被延迟的函数（defer 机制），在Go的panic机制中，延迟函数的调用在释放堆栈信息之前。直接调用内置的panic函数也会引发panic异常，panic函数接受任何值作为参数。 通常来说，不应该对panic异常做任何处理，但有时候我们需要从异常中恢复，此时就需要 Go 的 Recover 机制来捕获异常。 func Parse(input string) (s *Syntax, err error) { defer func() { if p := recover(); p != nil { err = fmt.Errorf(\"internal error: %v\", p) } }() // ...parser... } 如上所示，如果在deferred函数中调用了内置函数recover，并且定义该defer语句的函数发生了panic异常，recover会使程序从panic中恢复，并返回panic value。导致panic异常的函数不会继续运行，但能正常返回。在未发生panic时调用recover，recover会返回nil。 通常我们不应该不加区分的恢复所有的panic异常，同时作为被广泛遵守的规范，也不应该试图去恢复其他包引起的panic。安全的做法是有选择性的recover。 为了标识某个panic是否应该被恢复，我们可以将panic value设置成特殊类型。在recover时对panic value进行检查，如果发现panic value是特殊类型，就将这个panic作为errror处理，如果不是，则按照正常的panic进行处理。 func soleTitle(doc *html.Node) (title string, err error) { type bailout struct{} defer func() { switch p := recover(); p { case nil: // no panic case bailout{}: // \"expected\" panic err = fmt.Errorf(\"multiple title elements\") default: panic(p) // unexpected panic; carry on panicking } }() } 最后某些致命错误会导致Go在运行时终止程序，无法恢复，比如内存不足。 ","date":"2021-01-05","objectID":"/go_5/:2:3","tags":["go 语法"],"title":"go 函数","uri":"/go_5/"},{"categories":["Go"],"content":"go 提供的复合数据类型","date":"2021-01-04","objectID":"/go_4/","tags":["go 语法"],"title":"go 复合数据类型","uri":"/go_4/"},{"categories":["Go"],"content":"Go 的类型系统 ","date":"2021-01-04","objectID":"/go_4/:0:0","tags":["go 语法"],"title":"go 复合数据类型","uri":"/go_4/"},{"categories":["Go"],"content":"1. Go 的复合数据类型 接着上一篇，我们来继续讨论 Go 里面的复合数据类型，包括数组、slice、map和结构体。数组和结构体是聚合类型；它们的值由许多元素或成员字段的值组成。slice,map 分别与 Python 中的 array.Array,dict 相对应，它们是 Go 提供给我们容器数据类型。 编程语言提供的复合数据类型应该是数据结构与算法的基础内容，如果你熟悉常用的数据结构，对复合类型的特性和支持的操作应该很容易就能理解。因此接下来的内容，我们会先简单说一说数据结构的特点，然后在介绍它们在 Go 中的实现和支持的操作。 ","date":"2021-01-04","objectID":"/go_4/:1:0","tags":["go 语法"],"title":"go 复合数据类型","uri":"/go_4/"},{"categories":["Go"],"content":"2. 数组 数组应该是最基本的数据结构，简单来说，数组具有如下特性: 数组是一段连续的内存空间，用来存储一组具有相同类型的数据 数组一经创建，大小便不能更改，连续的内存要求元素之间不能出现空洞 数组的特性决定了数组天然支持基于下标的“随机访问”(索引)。Go 中的数组我们需要关注以下几个知识点: 数组的长度是数组类型的一个组成部分，[3]int和[4]int是两种不同的数组类型 数组的长度必须是常量表达式，因为数组的长度需要在编译阶段确定 数组的可比性取决于数组的类型是否相同以及数组元素是否可比，只有当两个数组类型相同并且所有元素都是相等的时候数组才相等 下面是数组常用操作的代码示例: // 1. 数组字面量 var q [3]int = [3]int{1, 2, 3} q := [...]int{1, 2, 3} // “...”省略号，表示数组的长度是根据初始化值的个数来计算 r := [...]int{99: ‐1} // 直接按位置初始化，未初始化的为对应类型的零值 // 2. 索引和切片 fmt.Println(q[0]) // print the first element fmt.Println(q[len(q)‐1]) // print the last element, q[2] e := [3]int{1, 2, 3} ff := e[0:2] // 对数组切片返回的是 slice 而不是原数组类型 if ff == e { // missmatch type []int and [3]int } // 3. for 循环迭代 for i, v := range q { fmt.Printf(\"%d %d\\n\", i, v) } // 4. 数组可比性 a := [2]int{1, 2} d := [3]int{1, 2} fmt.Println(a == d) // compile error: cannot compare [2]int == [3]int ","date":"2021-01-04","objectID":"/go_4/:2:0","tags":["go 语法"],"title":"go 复合数据类型","uri":"/go_4/"},{"categories":["Go"],"content":"3. slice 切片 因为数组的大小固定，类型限定严格，我们通常很少直接使用数组，使用更多的是数组的容器，Go 中数组的容器类型就是 slice (切片)。容器的最主要作用是能够根据元素大小对数组进行扩缩容。因此我们可以从 slice 的组成和扩缩容两个方面去理解 slice。 ","date":"2021-01-04","objectID":"/go_4/:3:0","tags":["go 语法"],"title":"go 复合数据类型","uri":"/go_4/"},{"categories":["Go"],"content":"3.1 slice 组成 Go 的 slice由三个部分构成： 指针: 指针指向第一个slice元素对应的底层数组元素的地址 容量: 容量一般是从 slice 的开始位置到底层数据的结尾位置 长度: 对应slice中元素的数目，长度不能超过容量 需要注意的是，因为 slice 底层数组是可以共享(通常是由于切片行为引起的)，因此slice 指针指向的第一个元素并不一定就是数组的第一个元素。内置的len和cap函数分别返回slice的长度和容量。下面是一个 slice 结构示意图: months := [...]string{1: \"January\", /* ... */, 12: \"December\"} Q2 := months[4:7] summer := months[6:9] 对数组 months 的切片操作返回的是 slice []int，Q2和summer 共用了底层的 months 数组。 ","date":"2021-01-04","objectID":"/go_4/:3:1","tags":["go 语法"],"title":"go 复合数据类型","uri":"/go_4/"},{"categories":["Go"],"content":"3.2 slice 扩缩容 slice 扩缩容策略由 append 函数实现，但 append 只能向slice追加元素，Go 并没有删除 slice 中元素的函数。append扩容的过程大体是这样的: 在每次向 slice 添加时，append 会判断当前数组的大小是否足以容纳新增元素，足够则直接插入 如果数组容量不够，append 将创建一个原有数组两倍大小的新数组，并将原数组中的元素拷贝到新数组中去 最后将 slice 中的指针的指向新的底层数组 append 函数可以向 slice 追加多个元素，甚至追加一个slice: var x []int x = append(x, 1) x = append(x, 2, 3) x = append(x, 4, 5, 6) x = append(x, x...) // append the slice x fmt.Println(x) // \"[1 2 3 4 5 6 1 2 3 4 5 6]\" 需要注意的是，通常我们要将 append 的返回值直接赋值给输入的slice变量，这么做与 Go 中函数的参数传值方式有关: Go 中的函数参数是按值传递的，因此传入 append 的是 slice 的副本，但是它们的指针指向了相同的底层数组 如果 append 函数发生了扩容，函数内的 slice 副本将指向新的内存数组，此时 append 函数将不会影响到传入的 slice 变量，为了达到修改 slice 的目的，通常要对输入的slice变量重新赋值 ","date":"2021-01-04","objectID":"/go_4/:3:2","tags":["go 语法"],"title":"go 复合数据类型","uri":"/go_4/"},{"categories":["Go"],"content":"3.3 slice 操作 说完了 slice 的实现，我们再来看看 slice 支持的操作: slice 的字面量与数组类似，只是去掉长度声明 对 slice 的切片操作如果超出cap(s)的上限将导致一个panic异常，但是超出len(s)则是意味着扩展了slice，新slice的长度会变长 为了避免创建 slice 多次内存分配，内置的 make 函数可以创建指定长度和容量的 slice slice之间不能比较，我们不能使用==操作符来判断两个slice是否含有全部相等元素，slice唯一合法的比较操作是和nil比较 因为 Go 没有提供删除 slice 元素的函数，只能采用覆盖的方式进行 slice 元素删除 下面是 slice 常用操作的代码示例: // 1. slice 字面量 var m = []int{3: 10} // 2. slice 创建函数 // make创建了一个匿名的数组变量，然后返回一个slice make([]T, len) make([]T, len, cap) // same as make([]T, cap)[:len] // 3. slice 与 nil 的比较和转换 if summer == nil { /* ... */ } var s []int // len(s) == 0, s == nil s = nil // len(s) == 0, s == nil s = []int(nil) // len(s) == 0, s == nil，类型转换 s = []int{} // len(s) == 0, s != nil // 4. slice 为空测试，不应该使用 s == nil if len(s) == 0{ } // 5. slice 复制 // copy函数可以方便地将一个slice复制另一个相同类型的slice // copy函数将返回成功复制的元素的个数，等于两个slice中较小的长度 copy(m, s) // 将 s 复制到 m // 6. slice 元素删除 //如果要保持 slice 原来顺序 func remove(slice []int, i int) []int { copy(slice[i:], slice[i+1:]) return slice[:len(slice)‐1] } //如果不用保持原来顺序的话，使用最后元素覆盖删除元素 func remove(slice []int, i int) []int { slice[i] = slice[len(slice)‐1] return slice[:len(slice)‐1] } // 7. slice 模拟栈操作 stack = append(stack, v) // push v top := stack[len(stack)‐1] // top of stack stack = stack[:len(stack)‐1] // pop ","date":"2021-01-04","objectID":"/go_4/:3:3","tags":["go 语法"],"title":"go 复合数据类型","uri":"/go_4/"},{"categories":["Go"],"content":"4. Map 散列表 在Go语言中，一个map就是一个散列表的引用，散列表是映射的一种实现方式，因此要想理清楚散列表，我们要从映射入手。所谓映射就是支持以下方法的键值对: M[k]: 返回键 k 对应的值，对应 Python __getitem__ M[k]=v: 对应 Python __setitem__ del M[k]: 对应 Python __delitem__ len(M): 对应 Python __len__ iter(M): 迭代映射 M 中的所有键，对应 Python __iter__ 我列出了 Python 中与之对应的方法，但是 Go 中实现方式有所不同，我们会在下面讲解。散列表是映射高效的实现方式，可以实现 O(1) 时间复杂度的元素查找。那散列表是如何实现的呢？ ","date":"2021-01-04","objectID":"/go_4/:4:0","tags":["go 语法"],"title":"go 复合数据类型","uri":"/go_4/"},{"categories":["Go"],"content":"4.1 散列表的实现 散列表是数组的一种扩展，利用的是数组支持按照下标随机访问的特性，通过散列函数把元素的键映射为数组的下标来实现在数组中保存和查询元素。在整个散列表的实现中，有三个核心问题： 散列函数设计 散列冲突的解决 装载因子以及散列表的动态扩容 下面是散列表实现映射的示意图: 限于篇幅的原因，有关散列表的实现，我就不过多解释，不了解的同学可以看看这篇文章散列表实现。这里我们需要关注的是散列表在使用上的限制。 首先，由于映射过程以及散列冲突的存在，所有的编程语言的散列表都会有以下两点要求: key 不可变，如果key 可变，元素的哈希值就会变化，查找就会失败 key 之间可比，当发生散列冲突时，要通过比较进行二次查找 而 Go 对散列表使用更加严格: 散列表中所有的key必须是相同的类型，所有的value也必须是相同的类型，但是 key 和 value 的类型可以不同 因为 Go 中可变的元素都是不可比的，所以上面的条件就退化成 key 必须是支持==比较运算符的数据类型,例如整数、数组或结构体等 虽然浮点数类型也是支持相等运算符比较的，但是将浮点数用做key类型则是一个坏的想法，最坏的情况是可能出现的NaN和任 何浮点数都不相等 ","date":"2021-01-04","objectID":"/go_4/:4:1","tags":["go 语法"],"title":"go 复合数据类型","uri":"/go_4/"},{"categories":["Go"],"content":"4.2 map 操作 说完了散列表的实现，接下来我们看看 Go map 支持的操作。在Go语言中，一个map就是一个哈希表的引用，map类型可以写为map[K]V，其中K和V分别对应key和value。与 slice 类似，我们可以使用字面量和 make 来创建 map。 map 支持上面所说的映射操作，但是与 Python 相比 Go map 有以下两个鲜明特点: key 不存在时，执行 M[key]，不会触发异常，而是返回 value 类型对应的零值 map类型的零值是nil，也就是没有引用任何哈希表，map上的查找、删除、len和range循环都可以安全工作在nil值的map上，它们的行为和一个空的map类似。但是向一个nil值的map存入元素将导致一个panic异常 此外和slice一样，map之间也不能进行相等比较；唯一的例外是和nil进行比较。要判断两个map是否包含相同的key和value，我们必须通过一个循环实现。下面 map 操作的代码示例: // 1. 字面量 ages := map[string]int{ \"alice\": 31, \"charlie\": 34, } // 2. 初始化函数 make ages := make(map[string]int) ages[\"alice\"] = 31 ages[\"charlie\"] = 34 // 3. 元素访问与删除 ages[\"alice\"] = 32 fmt.Println(ages[\"alice\"]) // \"32 delete(ages, \"alice\") // remove element ages[\"alice\"] // 元素不存在的判断 if age, ok := ages[\"bob\"]; !ok { /* ... */ } // 判断元素是否存在 // 4. 迭代和遍历，迭代总是随机和无序的 for name, age := range ages { fmt.Printf(\"%s\\t%d\\n\", name, age) } // 有序遍历 import \"sort\" var names []string for name := range ages { names = append(names, name) } sort.Strings(names) for _, name := range names { fmt.Printf(\"%s\\t%d\\n\", name, ages[name]) } // 5. 零值，以及是否为空的比较 var ages map[string]int fmt.Println(ages == nil) // \"true\" fmt.Println(len(ages) == 0) // \"true\" // 6. 两个相同 map 判等 func equal(x, y map[string]int) bool { if len(x) != len(y) { return false } for k, xv := range x { // 注意必须先判断，元素是否存在 if yv, ok := y[k]; !ok || yv != xv { return false } } return true } 最后，Go语言中并没有提供一个set类型，可以通过 map 实现类似set的功能，常用的 map 类型就是map[string]bool。 ","date":"2021-01-04","objectID":"/go_4/:4:2","tags":["go 语法"],"title":"go 复合数据类型","uri":"/go_4/"},{"categories":["Go"],"content":"5. 结构体 结构体是一种聚合的数据类型由零个或多个任意类型的值聚合成的实体。每个值称为结构体的成员。结构体是 Go 提供给我们创建自定义类型的载体，下面是一个创建示例: type Employee struct { ID int Name, Address string DoB time.Time Position string Salary int ManagerID int } var dilbert Employee struct 定义了一个结构体，type 为这个结构体定义类型别名，便于引用，这种定义方式与 C 很接近。 在结构体的定义上，Go 中还有下面一些特性: 结构体成员的输入顺序也有重要的意义，拥有相同成员但是成员顺序不同的结构体属于不同的结构体类型 如果结构体成员名字是以大写字母开头的，那么该成员就是导出的；这是Go语言导出规则决定的。一个结构体可能同时包含导出和未导出的成员。 结构体的操作稍显复杂，我们分成下面两块来讲解 结构体通用操作，包括成员变量的引用，结构体的创建和比较 结构体的嵌入和匿名变量，这个是 Go 语言的特性，需要重点关注 ","date":"2021-01-04","objectID":"/go_4/:5:0","tags":["go 语法"],"title":"go 复合数据类型","uri":"/go_4/"},{"categories":["Go"],"content":"5.1 结构体通用操作 成员引用 结构体是一个变量，它所有的成员也同样是变量，可以赋值或者取址，然后通过指针访问。结构体变量的成员可以通过点操作符访问，点操作符也可以和指向结构体的指针一起工作： // 通过点操作直接访问 var dilbert Employee dilbert.Salary ‐= 5000 // 可以对成员变量取址，然后访问 position := \u0026dilbert.Position *position = \"Senior \" + *position // promoted, for outsourcing to Elbonia // 点操作也可以直接用在结构体指针上 var employeeOfTheMonth *Employee = \u0026dilbert employeeOfTheMonth.Position += \" (proactive team player)\" // 等同于 (*employeeOfTheMonth).Position += \" (proactive team player)\" 结构体字面量 结构体字面值有两种语法格式: 以结构体成员定义的顺序为每个结构体成员指定一个面值，这种方式在结构定义发生变化时就会导致编译错误，因此这种方式只在定义结构体的包内部使用，或者是在较小的结构体中使用，这些结构体的成员排列比较规则 以成员名字和相应的值来初始化，可以包含部分或全部的成员,如果成员被忽略的话将默认用零值 需要注意的是两种不同形式的写法不能混合使用。而且，你不能企图在外部包中用第一种顺序赋值的技巧来偷偷地初始化结构体中未导出的成员。 // 方式一: 按照成员定义顺序，依次赋值 type Point struct{ X, Y int } p := Point{1, 2} // 方式二: 以成员名字和相应的值来初始化 f := Point{X: 1, Y: 2} // 未导出变量，无法赋值 package p type T struct{ a, b int } // a and b are not exported package q import \"p\" var _ = p.T{a: 1, b: 2} // compile error: can't reference a, b var _ = p.T{1, 2} // compile error: can't reference a, b 除了字面量外，我们还可以用前面介绍的 new 函数来创建结构体变量 pp := \u0026Point{1, 2} pp := new(Point) *pp = Point{1, 2} 结构体的零值与比较 结构体类型的零值是每个成员都是零值。如果结构体没有任何成员的话就是空结构体，写作struct{}。它的大小为0，也不包含任何信息，通常用作占位。 如果结构体的全部成员都是可以比较的，那么结构体也是可以比较的。可比较的结构体类型和其他可比较的类型一样，可以用于map的key类型。 type address struct { hostname string port int } hits := make(map[address]int) hits[address{\"golang.org\", 443}]++ ","date":"2021-01-04","objectID":"/go_4/:5:1","tags":["go 语法"],"title":"go 复合数据类型","uri":"/go_4/"},{"categories":["Go"],"content":"5.2 结构体的嵌入与匿名变量 结构体嵌入 结构体嵌入是 Go 语言提供的类似类继承机制，形式上是让一个命名的结构体包含另一个结构体类型的匿名成员，目的是实现通过简单的点运算符x.f来访问匿名成员链中嵌套的x.d.e.f成员的机制。说起来很复杂，举个例子。考虑一个图形系统，我们需要定义点，线，圆。显然圆可以在点即园心的基础上添加半径来表示。在 Go 中可以使用下面的结构体表示这样的结构。 // 点 type Point struct { X, Y int } // 圆 type Circle struct { Center Point Radius int } type Wheel struct { Circle Circle Spokes int } // 创建圆 var w Wheel w.Circle.Center.X = 8 w.Circle.Center.Y = 8 w.Circle.Radius = 5 w.Spokes = 20 如上所示，现在想访问Wheel的结构体成员 X 将变的异常繁琐。而结构嵌入就是为了在满足上面结构不变的情况，实现 w.X 成员快速访问。结构体声明如下所示: type Point struct { X, Y int } type Circle struct { Point // 匿名成员 Radius int } type Wheel struct { Circle // 匿名成员 Spokes int } var w Wheel w.X = 8 // equivalent to w.Circle.Point.X = 8 w.Y = 8 // equivalent to w.Circle.Point.Y = 8 w.Radius = 5 // equivalent to w.Circle.Radius = 5 w.Spokes = 20 Point，Circle 此时为匿名成员。所谓匿名成员，就是只声明一个成员对应的数据类型而不指名成员的名字。匿名成员并不是没有名字，其名字就是命名的类型名字，但是这些名字在点操作符中是可选的。上面 w.Circle.Point.X = 8 这样的访问方式依旧是合法的。 不幸的是，结构体字面值并没有简短表示匿名成员的语法， 因此下面的语句都不能编译通过。结构体字面值必须遵循形状类型声明时的结构 // 错误 w = Wheel{8, 8, 5, 20} // compile error: unknown fields w = Wheel{X: 8, Y: 8, Radius: 5, Spokes: 20} // compile error: unknown fields // 正确 w = Wheel{Circle{Point{8, 8}, 5}, 20} w = Wheel{ Circle: Circle{ Point: Point{X: 8, Y: 8}, Radius: 5, }, Spokes: 20, // NOTE: trailing comma necessary here (and at Radius) } 匿名变量的使用要求 需要注意的是 Go 对匿名成员的使用存在一些约束: 匿名成员的数据类型必须是命名的类型或指向一个命名的类型的指针 因为匿名成员也有一个隐式的名字，因此不能同时包含两个类型相同的匿名成员，这会导致名字冲突 因为成员的名字是由其类型隐式地决定的，所有匿名成员也有可见性的规则约束 比如将上面改成小写字母开头的point和circle），此时在包内依旧可以使用 w.X = 8；但是在包外部，因为circle和point没有导出不能访问它们的成员，因此简短的匿名成员访问语法也是禁止的。 匿名结构的可见性只与属性和方法的获取的表达式有关，比如将上面改成小写字母开头的point和circle），在包外部不能通过 w.point.X 访问成员 X，但是可以通过 w.X 直接访问成员 X。下面是另一个例子: //1. pkg 包内定义 animal 和 Dog package pkg type animal struct { Name string } type Dog struct { animal Weight int } func NewDog() Dog { return Dog{animal{\"aaa\"}, 100} } func (g Dog) GetName() string { return g.Name } func (g *Dog) GetWeight() int { return g.Weight } // 2 mian 包内使用 package main import ( \"fmt\" \"mygo/pkg\" ) func main() { g := pkg.NewDog() fmt.Printf(\"%T, %#v\\n\", g, g) fmt.Println(g.Weight) // 注意: 此处我们可以直接访问 g.Weight fmt.Println(g.Name) fmt.Printf(\"%T\\n\", (*pkg.Dog).GetName) // func(*pkg.Dog) string fmt.Printf(\"%T\\n\", (*pkg.Dog).GetWeight) // func(*pkg.Dog) int fmt.Printf(\"%T\\n\", pkg.Dog.GetName) // func(pkg.Dog) string // fmt.Printf(\"%T\\n\", pkg.Dog.GetWeight) } 最后匿名成员并不要求是结构体类型；其实任何命名的类型都可以作为结构体的匿名成员。但是为什么要嵌入一个没有任何子成员类型的匿名成员类型呢？答案是匿名类型的方法集。 简短的点运算符语法可以用于选择匿名成员嵌套的成员，也可以用于访问它们的方法。实际上，外层的结构体不仅仅是获得了匿名成员类型的所有成员，而且也获得了该类型导出的全部的方法。 这个机制可以用于将一个有简单行为的对象组合成有复杂行为的对象。组合是Go语言中面向对象编程的核心。我们在下一章将方法时会再来讨论。 ","date":"2021-01-04","objectID":"/go_4/:5:2","tags":["go 语法"],"title":"go 复合数据类型","uri":"/go_4/"},{"categories":["Go"],"content":"go 的基础数据类型","date":"2021-01-03","objectID":"/go_3/","tags":["go 语法"],"title":"go 基础数据类型","uri":"/go_3/"},{"categories":["Go"],"content":"Go 的类型系统 ","date":"2021-01-03","objectID":"/go_3/:0:0","tags":["go 语法"],"title":"go 基础数据类型","uri":"/go_3/"},{"categories":["Go"],"content":"1. Go 中的数据类型 Go语言将数据类型分为四类：基础类型、复合类型、引用类型和接口类型。基础类型，包括：数字、字符串和布尔型。复合数据类型包括数组和结构体(通过组合简单类型，来表达更加复杂的数据结构)。引用类型包括指针、切片、字典、函数、通道，虽然数据种类很多，但它们都是对程序中一个变量或状态的间接引用。函数和通道并不属于我们通常所说的数据类型，我们放在后面相关章节来介绍。 对于大多数编程语言来说，基础类型以及它们之上的可用运算符都是类似，更加需要我们注意的是，编程语言提供给我们的数据容器以及操作它们的方式。因此我们分成以下几个部分来讲解 Go 的类型系统。 数值与布尔型 字符串与编码 数组与结构体 切片 字典 本节我们先来介绍 Go 中的基本数据类型，即数值，布尔值和字符串。在介绍这些数据类型之前，我们先来谈谈变量类型的含义，这有助于加深我们对编程语言本身的理解。 ","date":"2021-01-03","objectID":"/go_3/:1:0","tags":["go 语法"],"title":"go 基础数据类型","uri":"/go_3/"},{"categories":["Go"],"content":"1.1 变量的类型 无论什么数据，在存储器内都是 0-1，那数据是数值还是字符完全取决于我们对这些二进制数据的解释。变量的类型就是用来定义对应存储值的属性特征，即它们在内部是如何表示的，支持的操作符，以及关联的方法集等。 而在一个编程语言类型系统中，除了内置的变量类型外，还有如下一些问题: 自定义类型 定义新的类型名称(类型重命名) 类型转换 ","date":"2021-01-03","objectID":"/go_3/:1:1","tags":["go 语法"],"title":"go 基础数据类型","uri":"/go_3/"},{"categories":["Go"],"content":"1.2 自定义类型 自定义类型允许我们在编程语言底层类型的基础上定义更加复杂的类型，它是面向对象编程的基础。在 Go 中自定义类型就是使用结构体。 ","date":"2021-01-03","objectID":"/go_3/:1:2","tags":["go 语法"],"title":"go 基础数据类型","uri":"/go_3/"},{"categories":["Go"],"content":"1.2 类型重命名 在任何程序中都会存在一些变量有着相同的内部结构，但是却表示完全不同的概念。例如，一个int类型的变量可以用来表示一个循环的迭代索引、或者一个时间戳、或者一个文件描述符。类型重命名就是为分隔不同概念的类型。新的类型名称使用类型声明语句创建。Go 的类型声明语法如下所示: type 类型名字 底层类型 新的类型和底层类型具有相同的底层结构，支持和底层类型相同的运算符。但是新类型与底层类型以及基于相同底层类型的不同新类型，是完全不不同的数据类型。 import \"fmt\" type Celsius float64 // 摄氏温度 type Fahrenheit float64 // 华氏温度 // 因为 Fahrenheit，float64，Celsius 是完全不同的类型，所以它们不能直接比较 // compile error: type mismatch fmt.Println(Fahrenheit(1.0) == float64(1.0)) fmt.Println(Fahrenheit(1.0) == Celsius(1.0)) ","date":"2021-01-03","objectID":"/go_3/:1:3","tags":["go 语法"],"title":"go 基础数据类型","uri":"/go_3/"},{"categories":["Go"],"content":"1.2 类型转换 对于每一个类型T，都有一个对应的类型转换操作T(x)，用于将x转为T类型。如果T是指针类型，可能会需要用小括弧包装T，比如 (*int)(0)。 在编程语言中，不同类型的变量之间是不能进行直接赋值和比较的，要这样做就需要显示或隐式的类型转换。对于不同编程语言而言，有不同的类型转换规则，但大多数规则都是类似。在 Go 中: 数值之间的转类型转换有一套特定规则，这个规则在不同的编程语言中是一样的，比如将浮点数转换为整数会损失小数部分 显示的类型转换T(x)要求 T 和 x 具有相同的底层基础类型或指向相同底层结构的指针类型；对于数据容器而言需要它们有类似的实现，比如可以将一个字符串转为 []byte类型 自定义的新类型名称，不会自动应用底层类型的隐式类型转换规则，一个命名类型的变量只能和另一个有相同类型的变量，或有着相同底层类型的未命名类型的值之间做比较；依赖相同底层类型的不同自定义类型之间想要进行比较或赋值必须进行显示的类型转换。 import \"fmt\" // 自定义类型与其底层类型不可比较 type tt int fmt.Println(tt(1) \u003e int(0)） // compile error: type mismatch var c Celsius var f Fahrenheit fmt.Println(c == 0) // \"true\" fmt.Println(f \u003e= 0) // \"true\" // 依赖相同底层类型的不同自定义类型不可比较 fmt.Println(c == f) // compile error: type mismatch fmt.Println(c == Celsius(f)) // \"true\"! 说了这么多，接下来我们开始正式讲解 Go 中的数据类型。 ","date":"2021-01-03","objectID":"/go_3/:1:4","tags":["go 语法"],"title":"go 基础数据类型","uri":"/go_3/"},{"categories":["Go"],"content":"2. 数值 Go语言的数值类型包括几种不同大小的整数、浮点数和复数，还有一些为特定用途定义的类型别名。 ","date":"2021-01-03","objectID":"/go_3/:2:0","tags":["go 语法"],"title":"go 基础数据类型","uri":"/go_3/"},{"categories":["Go"],"content":"2.1 整数 整数包括如下几种类型及类型别名： 类型 大小 含义 uint8 8 无符号 8 位整型 uint16 16 无符号 16 位整型 uint32 32 无符号 32 位整型 uint64 64 无符号 64 位整型 uint 32 或 64位 平台相关，取决于CPU平台机器字大小 int 32 或 64位 平台相关，取决于CPU平台机器字大小 int8 8 有符号 8 位整型 int16 16 有符号 16 位整型 int32 32 有符号 32 位整型 int64 64 有符号 64 位整型 byte 8, int8的别名 表示原始的二进制数据 rune 32, int32的别名 Unicode字符，表示一个Unicode码点 uintptr 无符号整数，没有明确指定大小 用于存放一个指针，GO 底层使用 其中int是应用最广泛的数值类型。内置的len函数返回一个有符号的int，虽然使用uint无符号类型似乎是一个更合理的选择。len函数返回有符号 int ，可以使我们像下面这样处理逆序循环。 medals := []string{\"gold\", \"silver\", \"bronze\"} for i := len(medals) ‐ 1; i \u003e= 0; i‐‐ { fmt.Println(medals[i]) // \"bronze\", \"silver\", \"gold\" } 所以尽管Go语言提供了无符号数和运算，并且在数值本身不可能出现负数的情况下，我们还是倾向于使用有符号的int类型。出于这个原因，无符号数往往只有在位运算或其它特殊的运算场景才会使用，就像bit集合、分析二进制文件格式或者是哈希和加密操作等。它们通常并不用于仅仅是表达非负数量的场合。 ","date":"2021-01-03","objectID":"/go_3/:2:1","tags":["go 语法"],"title":"go 基础数据类型","uri":"/go_3/"},{"categories":["Go"],"content":"2.2 整数的运算符 Go 的整数支持如下操作符号，其中大多数与其他语言类似，只有一个比较特殊x \u0026^ y，它表示将 x 中与 y 对应的且 y 中等于 1 的位置为 0，即位清空(AND NOT) # 优先级递减 * / % # 算数运算符 \u003c\u003c \u003e\u003e \u0026 \u0026^ # 位运算符 + ‐ # 算数运算符 | ^ # 位运算符 == != \u003c \u003c= \u003e \u003e= # 比较运算符 \u0026\u0026(AND) ||(or) # 逻辑运算符 ","date":"2021-01-03","objectID":"/go_3/:2:2","tags":["go 语法"],"title":"go 基础数据类型","uri":"/go_3/"},{"categories":["Go"],"content":"2.3 浮点数 Go语言提供了两种精度的浮点数，float32 和 float64 。浮点数的范围极限值可以在math包找到。常量math.MaxFloat32表示float32能表示的最大数值，对应的 float64 为 math.MaxFloat64。 一个float32类型的浮点数可以提供大约6个十进制数的精度，而float64则可以提供约15个十进制数的精度；通常应该优先使用float64类型。小数点前面或后面的数字都可能被省略（例如.707或1.）。很小或很大的数最好用科学计数法书写，通过e或E来指定指数部分。 // float32的有效bit位只有23个，整数大于23bit表示范围时，将出现误差 var f float32 = 16777216 // 1 \u003c\u003c 24 fmt.Println(f == f+1) // \"true\"! const a = .909 const Avogadro = 6.02214129e23 // 阿伏伽德罗常数 const Planck = 6.62606957e‐34 // 普朗克常数 math包中除了提供大量常用的数学函数外，还提供了IEEE754浮点数标准中定义的特殊值的创建和测试。 v := math.Inf(1) // 返回正无穷 p := math.Inf(-1) // 返回负无穷 n := math.NaN() // 返回 NaN 非数，一般用于表示无效的除法操作结果0/0或Sqrt(­1). t ：= math.IsNaN(n) // 测试是否为 NaN // NaN和任何数都是不相等的 nan := math.NaN() fmt.Println(nan == nan, nan \u003c nan, nan \u003e nan) // \"false false false\" ","date":"2021-01-03","objectID":"/go_3/:2:3","tags":["go 语法"],"title":"go 基础数据类型","uri":"/go_3/"},{"categories":["Go"],"content":"2.4 复数 Go语言提供了两种精度的复数类型：complex64 和 complex128，分别对应 float32 和 float64 两种浮点数精度。内置的complex函数用于构建复数，内建的real和imag函数分别返回复数的实部和虚部。复数的字面量使用 i 后缀。 var x complex128 = complex(1, 2) // 1+2i var y complex128 = complex(3, 4) // 3+4i fmt.Println(x*y) // \"(‐5+10i)\" fmt.Println(real(x*y)) // \"‐5\" fmt.Println(imag(x*y)) // \"10\" // 复数的字面量 x := 1 + 2i y := 3 + 4i ","date":"2021-01-03","objectID":"/go_3/:2:4","tags":["go 语法"],"title":"go 基础数据类型","uri":"/go_3/"},{"categories":["Go"],"content":"3. 布尔值 Go 布尔类型的值只有两种：true 和 false，if 和 for 语句的条件部分都是布尔值。需要特别注意的是 在 Go 中布尔之值不会与其他任何类型作隐式转换，将其他类型的值用在 if 或 for 中作为条件判断时，必须作显示的类型转换。 func itob(i int) bool { return i != 0 } b := 0 i := 0 if itob(b) { i = 1 } ","date":"2021-01-03","objectID":"/go_3/:3:0","tags":["go 语法"],"title":"go 基础数据类型","uri":"/go_3/"},{"categories":["Go"],"content":"4. 字符串 ","date":"2021-01-03","objectID":"/go_3/:4:0","tags":["go 语法"],"title":"go 基础数据类型","uri":"/go_3/"},{"categories":["Go"],"content":"4.1 字符串操作 创建字符串最简单的方式是字符串字面量。在 Go 中，单个字符的字面量使用单引号，字符串字面量使用双引号，原生字符串使用反引号。所谓原生字符类似于 Python 中的 r\"\" 用于消除字符串中的所有转义操作。Go 的原生字符甚至可以消除换行，实现跨行，所以原生字符广泛使用再正则表达式，HTML模板、JSON面值以及命令行提示信息中。 与 Python 将大多数字符串操作作为字符串对象的方法不同，Go 大多数的字符串操作都在 strings 包，我们将这部分内容放在后面专门介绍，先来看看Go 提供的字符串基础操作。下面是一些代码示例: // 原生字符串 const GoUsage = `Go is a tool for managing Go source code. Usage: go command [arguments] ` s := \"hello, world\" // 1. len 函数获取字符串长度 fmt.Println(len(s)) // \"12\" // 2. 索引 fmt.Println(s[0], s[7]) // \"104 119\" ('h' and 'w') // 3. 切片 fmt.Println(s[0:5]) // \"hello // 4. + 拼接 fmt.Println(\"goodbye\" + s[5:]) // \"goodbye, world\" // 5. 不可修改 s[0] = 'L' // compile error: cannot assign to s[0] 虽然字符串作为一个基本的数据类型被几乎所有的编程语言所支持，但是字符串本身确是很复杂。而复杂的地方至少有如下两点: 字符串的实现 字符的编码问题 ","date":"2021-01-03","objectID":"/go_3/:4:1","tags":["go 语法"],"title":"go 基础数据类型","uri":"/go_3/"},{"categories":["Go"],"content":"4.1 字符串的实现 上面是字符串以及切片操作结果的示意图，在 Go 中，字符串是一个不可改变的字节序列，底层是一个字符数组，一个字符串可认为由两个部分构成:指针、长度 指针指向第一个字符对应的底层数组元素的地址 长度对应字符串中字符的个数 字符串的底层数组位于受保护的内存中，不能被修改，因此字符串是不可变的 对字符串变量进行重新赋值，不会改变字符串的底层数组，而只是改变了字符串中的指针的指向 不变性意味两个字符串可以安全的共享相同的底层数据，这使得字符串复制和切片不会发生实际的复制行为，而是直接共享原有的底层字符数组，因此操作非常迅速。 ","date":"2021-01-03","objectID":"/go_3/:4:2","tags":["go 语法"],"title":"go 基础数据类型","uri":"/go_3/"},{"categories":["Go"],"content":"4.3 字符集 在上面关于字符串的实现中，我们忽略了一个问题，即如何把字符串中的字符保存在一个数组中。我们知道在计算机上保存的数据只有二进制的 0 和 1，显然计算机没办法直接保存每个字符，于是就有了字符集的概念。 对于字符集以及字符的编码和解码，我是这样理解的: 字符集中最重要的概念就是码表，其作用是将每个字符与一个特定的数字对应起来，用特定的数字(又称码点)来表示特定的字符，因此码表就是字符集能表示的字符范围 有了码表，并没有解决保存字符的问题，显然就算是数字也要保存为整数的二进制格式。对于不同字符集而言，码点到特定的二进制也有一套特定的转换规则 因此，字符集实现了字符 --\u003e 码点 ---\u003e 码点二进制值的转换过程，码点 ---\u003e 码点二进制值被称为编码，反过来就是解码 有了上面的说明，就能解释清楚下面两个问题: ASCII 字符集 与 Unicode 字符集区别: ASCII字符集使用7bit来表示一个码点，而 Unicode 使用32bit表示一个 Unicode 码点，Unicode 显然能表示更大的字符范围 UTF8 编码与 UTF32 编码的区别: UTF32 编码直接将每个 Unicode 码点保存为 int32 的整数，而UTF8 会根据Unicode码点变长编码成二进制，它们都表示 Unicode 字符集，但是编码规则不同 ","date":"2021-01-03","objectID":"/go_3/:4:3","tags":["go 语法"],"title":"go 基础数据类型","uri":"/go_3/"},{"categories":["Go"],"content":"4.4 字符串和 []rune Go语言的源文件采用UTF8编码，因此程序运行之后，保存在字符数组内的是 UTF8 编码的二进制值。因此前面我们所讲的字符串基础操作，操作的其实是UTF8 编码的每个字节，并不是我们理解的字符。为了处理真实的字符，我们需要对字符串进行解码。Go 将 Unicode 码点表示为 rune 整数类型，因此字符串解码后的类型就是 []rune。下面就是Go 中字符编码解码的一些代码示例: // 1. 字符串基础操作操作的是 UTF8 中的字节 import \"unicode/utf8\" s := \"Hello, 世界\" fmt.Println(len(s)) // \"13\" fmt.Println(utf8.RuneCountInString(s)) // \"9\" // 2. unicode 提供了 UTF8 的解码函数 for i := 0; i \u003c len(s); { r, size := utf8.DecodeRuneInString(s[i:]) fmt.Printf(\"%d\\t%c\\n\", i, r) i += size } // 3. range 会自动对字符串解码 for i, r := range \"Hello, 世界\" { fmt.Printf(\"%d\\t%q\\t%d\\n\", i, r, r) } // 4. []rune 字符串的类型转换 s := \"プログラム\" fmt.Printf(\"% x\\n\", s) // \"e3 83 97 e3 83 ad e3 82 b0 e3 83 a9 e3 83 a0\" // 字符串 --\u003e []rune r := []rune(s) fmt.Printf(\"%x\\n\", r) // \"[30d7 30ed 30b0 30e9 30e0] // string 函数： []rune ---\u003e 字符串 fmt.Println(string(r)) // \"プログラム // 5. 生成Unicode码点字符的UTF8字符串 fmt.Println(string(65)) // \"A\", not \"65\" fmt.Println(string(0x4eac)) // \"京\" ","date":"2021-01-03","objectID":"/go_3/:4:4","tags":["go 语法"],"title":"go 基础数据类型","uri":"/go_3/"},{"categories":["Go"],"content":"4.5 字符串和 []byte 一个字符串是包含的只读字节数组，一旦创建，是不可变的。相比之下，一个字节slice(即 []byte，下一节我们会详述)的元素则可以自由地修改。字符串和字节slice之间可以相互转换： s := \"abc\" b := []byte(s) s2 := string(b) ","date":"2021-01-03","objectID":"/go_3/:4:5","tags":["go 语法"],"title":"go 基础数据类型","uri":"/go_3/"},{"categories":["Go"],"content":"4.6 字符串相关类型的包 标准库中有四个包对字符串处理尤为重要：bytes、strings、strconv和unicode包 strings包提供了许多如字符串的查询、替换、比较、截断、拆分和合并等功能。 bytes包也提供了很多类似功能的函数，但是针对和字符串有着相同结构的[]byte类型 strconv包提供了布尔型、整型数、浮点数和对应字符串的相互转换，还提供了双引号转义相关的转换 unicode包提供了IsDigit、IsLetter、IsUpper和IsLower等类似功能，它们用于给字符分类，每个函数有一个单一的rune类型的参数，然后返回一个布尔值 下面是字符串与数值转换的代码示例，我们会在后面专门讲解这些包的实现和使用。 // 数值转字符串 x := 123 y := fmt.Sprintf(\"%d\", x) fmt.Println(y, strconv.Itoa(x)) // \"123 123\" // 数值的进制转换 fmt.Println(strconv.FormatInt(int64(x), 2)) // \"1111011\" s := fmt.Sprintf(\"x=%b\", x) // \"x=1111011 // 字符串转数值 x, err := strconv.Atoi(\"123\") // x is an int y, err := strconv.ParseInt(\"123\", 10, 64) // base 10, up to 64 bits ","date":"2021-01-03","objectID":"/go_3/:4:6","tags":["go 语法"],"title":"go 基础数据类型","uri":"/go_3/"},{"categories":["Go"],"content":"5. 常量 ","date":"2021-01-03","objectID":"/go_3/:5:0","tags":["go 语法"],"title":"go 基础数据类型","uri":"/go_3/"},{"categories":["Go"],"content":"5.1 常量的类型 在讲常量之前，先问大家一个问题，你知道字面量，常量，变量，字面量类型之间的区别么？ 字面量是编程语言提供的用来创建特定值的快捷方式，因此字面量也有类型，特定的字面量代表什么类型，完全有编程语言决定。因此对于像下面的赋值语句来说，在字面量类型和变量类型之间发生了类型转换。 var f float64 = 3 常量和变量都是变量，但是相比与变量，常量有以下特点: 常量的值不可变，并且常量的类型只能是基础类型：boolean、string或数字 常量表达式的值在编译期计算，而不是在运行期，因此常量可以是构成类型的一部分，例如用于指定数组类型的长度 因为常量也是变量，所以常量通常有确定的类型，但Go语言的常量有个不同寻常之处， Go 中的常量可以没有一个明确的基础类型。 首先在 Go 中，有六种无类型的字面量，分别是无类型的布尔型、无类型的整数、无类型的字符、无类型的浮点数、无类型的复数、无类型的字符串。例如0、0.0、0i和'\\u0000’分别对应无类型的整数、无类型的浮点数、无类型的复数和无类型的字符。 其次在如下不带类型声明的常量声明语句中，不会发生隐式类型转换，常量的类型依旧为无类型的整数。 const deadbeef = 0xdeadbeef // untyped int with value 3735928559 为了便于描述下面我们将无类型的字面量和常量统称为无类型常量，这些无类型常量有诸多好处。 编译器为这些无类型常量提供了比基础类型更高精度的算术运算。通过延迟明确常量的具体类型，无类型的常量不仅可以提供更高的运算精度，而且可以直接用于更多的表达式而不需要显式的类型转换。 只有常量可以是无类型的。当一个无类型的常量被赋值给一个变量的时候，或者出现在有明确类型的变量声明的右边，无类型的常量将会被隐式转换为对应的类型，如果转换合法的话。对于一个没有显式类型的变量声明（包括简短变量声明），字面量的形式将隐式决定变量的默认类型，Go 有一个明确的转换规则。如果要给变量一个不同的类型，我们必须显式地将无类型的常量转化为所需的类型，或给声明的变量指定明确的类型。 // 1. 常量可以无类型，无类型常量可以提供更高的精度 const ( deadbeef = 0xdeadbeef // untyped int with value 3735928559 a = uint32(deadbeef) // uint32 with value 3735928559 b = float32(deadbeef) // float32 with value 3735928576 (rounded up) c = float64(deadbeef) // float64 with value 3735928559 (exact) d = int32(deadbeef) // compile error: constant overflows int32 e = float64(1e309) // compile error: constant overflows float64 f = uint(‐1) // compile error: constant underflows uint ) // 2. 无类型常量，可以直接应用在更多的表达式中，无需显示类型转换 var f float64 = 3 + 0i // untyped complex ‐\u003e float64 f = 2 // untyped integer ‐\u003e float64 f = 1e123 // untyped floating‐point ‐\u003e float64 f = 'a' // untyped rune ‐\u003e float64 // 3. 有类型声明时，无类型常量将根据类型隐式类性转换 var x float32 = math.Pi var y float64 = math.Pi var z complex128 = math.Pi // 4. 无类型声明时，根据字面量形式，决定变量类型 i := 0 // untyped integer; implicit int(0) r := '\\000' // untyped rune; implicit rune('\\000') f := 0.0 // untyped floating‐point; implicit float64(0.0) c := 0i // untyped complex; implicit complex128(0i) var i = int8(0) var i int8 = 0 ","date":"2021-01-03","objectID":"/go_3/:5:1","tags":["go 语法"],"title":"go 基础数据类型","uri":"/go_3/"},{"categories":["Go"],"content":"5.2 常量批量声明 最后，Go 为常量的批量声明提供了一些便捷方式，下面是代码示例: // 1. 批量声明多个常量 const ( e = 2.71828182845904523536028747135266249775724709369995957496696763 pi = 3.14159265358979323846264338327950288419716939937510582097494459 ) const ( a = 1 b // 省略初始化表达式，表示使用前面常量的初始化表达式写法， b=1 c = 2 d // d=2 ) // 2. iota常量生成器初始化，用于生成一组以相似规则初始化的常量 type Weekday int const ( Sunday Weekday = iota // 在第一个声明的常量所在的行，iota将会被置为0， Monday // 然后在每一个有常量声明的行加一， 1 Tuesday // 2 Wednesday // 3 Thursday Friday Saturday ) const ( _ = 1 \u003c\u003c (10 * iota) KiB // 1024 MiB // 1048576 GiB // 1073741824 TiB // 1099511627776 (exceeds 1 \u003c\u003c 32) PiB // 1125899906842624 EiB // 1152921504606846976 ZiB // 1180591620717411303424 (exceeds 1 \u003c\u003c 64) YiB // 1208925819614629174706176 ) ","date":"2021-01-03","objectID":"/go_3/:5:2","tags":["go 语法"],"title":"go 基础数据类型","uri":"/go_3/"},{"categories":["Go"],"content":"go 变量与流程控制语法","date":"2021-01-02","objectID":"/go_2/","tags":["go 语法"],"title":"go 变量及流程控制","uri":"/go_2/"},{"categories":["Go"],"content":"Golang Hello World! ","date":"2021-01-02","objectID":"/go_2/:0:0","tags":["go 语法"],"title":"go 变量及流程控制","uri":"/go_2/"},{"categories":["Go"],"content":"1. Hello World 抛开数据结构，代码封装和复杂的库文件，我们接触一门新语言的第一步可能就是学会这门语言的基础语法。下面是我写的 go 的一个 “Hello World” 程序。在这个简单的代码中包含了很多 Go 基础语法的内容: 变量及常量的命名，声明和创建 条件判断和循环 变量的生命周期与作用域 下面我们就分成这几块来讲讲 Go 的基础语法。 package main import \"fmt\" const defaultUser = \"unsigned\" func main() { name := \"A\" if name == defaultUser { fmt.Println(\"Helll man\") } else { fmt.Println(\"Hey it is you\") } num := 100 r := 0 for i := 0; i \u003c= num; i++ { r += i } fmt.Println(r) } ","date":"2021-01-02","objectID":"/go_2/:1:0","tags":["go 语法"],"title":"go 变量及流程控制","uri":"/go_2/"},{"categories":["Go"],"content":"2. 变量及常量的命名，声明和创建 ","date":"2021-01-02","objectID":"/go_2/:2:0","tags":["go 语法"],"title":"go 变量及流程控制","uri":"/go_2/"},{"categories":["Go"],"content":"2.1 命名规则 几乎所有的编程语言变量，常量，函数以及类型的命名规则都是相同的，即一个名字必须以一个字母或下划线开头，后面可以跟任意数量的字母、数字或下划线。 Go 与众不同的是名称中可以包含Unicode字母(不建议使用)，并且使用名字的开头字母的大小写决定了名字在包外的可见性。关于变量的导出我们会在模块的相关内容详述。 习惯上，Go语言程序员推荐使用驼峰式命名。 ","date":"2021-01-02","objectID":"/go_2/:2:1","tags":["go 语法"],"title":"go 变量及流程控制","uri":"/go_2/"},{"categories":["Go"],"content":"2.2 声明和创建 Go语言主要有四种类型的声明语句：var、const、type和func，分别对应变量、常量、类型和函数实体对象的声明。我们先说变量以及常量。 与 Python 这种动态语言不同的是，Go 是静态语言，变量必须先声名才能使用。Go 中变量可以看成一个“容器”，一个变量对应一个保存了变量对应类型值的内存空间；变量一经声明，其类型就不能再改变。下面是 Go 中声明和创建变量的几种方式: //方式一: var 声明语句 var name string = \"abc\" var i, j, k int var b, f, s = true, 2.3, \"four\" //方式二: 函数内的短变量声明，用于局部变量的声明和初始化 t := 10 i, j := 0, 1 //方式三: new 函数，创建变量，并返回对应变量的指针 p := new(int) // 此处创建了两个变量: new 函数创建的匿名变量，以及指向匿名变量的指针变量 p *p = 2 var var声明语句可以创建一个特定类型的变量，然后给变量附加一个名字，并且设置变量的初始值。对于 var 变量名字 类型 = 表达式，“类型”或“= 表达式”两个部分可以省略其中的一个。 如果省略的是类型信息，那么将根据初始化表达式来推导变量的类型信息。 如果初始化表达式被省略，那么将用零值初始化该变量，规则如下 数值类型变量对应的零值是0 布尔类型变量对应的零值是false 字符串类型对应的零值是空字符串 接口或引用类型（包括slice、指针、map、chan和函数）变量对应的零值是nil 数组或结构体等聚合类型对应的零值是每个元素或字段都是对应该类型的零值 常量的声明和创建使用 const 声明语句，用法与 var 类似。 短变量声明 短变量声明语句用在函数内，用于声名和初始化局部变量，语法为变量名:=表达式，变量的类型根据表达式自动推导。Go 的短变量声明有一些微妙之处: 首先“:=”是一个变量声明语句，而“=”是一个变量赋值操作 其次，简短变量声明左边的变量可以包含已经声明过的变量，对于这些变量将只是赋值，而不是再声明 最后，简短变量声明语句中必须至少要声明一个新的变量否则无法通过编译 ","date":"2021-01-02","objectID":"/go_2/:2:2","tags":["go 语法"],"title":"go 变量及流程控制","uri":"/go_2/"},{"categories":["Go"],"content":"new 函数 new 是 Go 预定义的一个函数，new(T)将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址。 用new创建变量和普通变量声明语句方式创建变量没有什么区别，除了不需要声明一个临时变量的名字外。因为 new 只是一个普通函数，因此可以使用在任何函数可用的地方，甚至new名字可以被重定义其他类型。 ","date":"2021-01-02","objectID":"/go_2/:2:3","tags":["go 语法"],"title":"go 变量及流程控制","uri":"/go_2/"},{"categories":["Go"],"content":"3. 条件判断和循环 看完了变量创建，我们再来看看 Go 为我们提供的逻辑控制语句: if, switch, for。Go 没有 while 语句，但是 for 语句包含了 while 语句的功能。除了 if 外，switch 和 for 的用法都不简单。 除了这些基础的逻辑控制语句外，Go 还有一个特殊的与 Go 高并发相关的多路复用器 select。 ","date":"2021-01-02","objectID":"/go_2/:3:0","tags":["go 语法"],"title":"go 变量及流程控制","uri":"/go_2/"},{"categories":["Go"],"content":"3.1 if Go 应该是类 C 风格的语言，使用 {} 来分隔代码块。一个完整的 if 语句如下所示: if r == 0 { fmt.Println(\"aaa\") } else if r == 1 { fmt.Println(\"bbbb\") } else { fmt.Println(\"cccc\") } ","date":"2021-01-02","objectID":"/go_2/:3:1","tags":["go 语法"],"title":"go 变量及流程控制","uri":"/go_2/"},{"categories":["Go"],"content":"3.2 switch switch 是多分支条件判断的便捷语法，用于基于不同条件执行不同动作，Go 的 switch 有如下三种使用方式。 //方式一: 变量值判断 switch var1 { case v1: // var1 变量与 case 语句中的值类型必须相同 ... case v2,v3: // 逗号分隔表示可匹配多个值 ... default: ... } // 方式二: 条件判断的变形 switch { case condition1: ... case condition2, condition3: // 逗号分隔表示可匹配多个条件 ... default: ... } // 方式三: type-switch 用来判断某个 interface 变量中实际存储的变量类型 // 我们会在后面讲接口类型时详述 switch x.(type) { case type1: .... case type2: .... default: .... } 不同语言的 switch 语句差异很大，Go 的 switch 有如下特点: switch 语句的执行过程是从上直下逐一测试，直到匹配就会停止 每个 case 分支的最后不需要再加break，即默认只会执行第一个匹配到的 case 分支 Python 中没有 switch 语句，shell 脚本则必须在每个 case 分支之后添加 break，否则第一次匹配成功后后，会继续匹配之后的 case 分支。 ","date":"2021-01-02","objectID":"/go_2/:3:2","tags":["go 语法"],"title":"go 变量及流程控制","uri":"/go_2/"},{"categories":["Go"],"content":"3.3 select select 类似于用于通信的switch语句，它的一个使用示例如下所示: func main() { var c1, c2 chan int var i1, i2 int select { case i1 = \u003c-c1: fmt.Printf(\"received \", i1, \" from c1\\n\") case c2 \u003c- i2: fmt.Printf(\"sent \", i2, \" to c2\\n\") default: fmt.Printf(\"no communication\\n\") } 在 select 中: 每个case必须是一个通信操作，要么是发送要么是接收 所有channel表达式都会被求值，如果有多个 case 可以运行，select会随机执行一个可运行的case 如果没有case可运行，此时 如果有default子句，则执行该语句，defalut 子句应该总是可运行的 如果没有default字句，select将阻塞，直到某个通信可以运行；Go不会重新对channel或值进行求值 ","date":"2021-01-02","objectID":"/go_2/:3:3","tags":["go 语法"],"title":"go 变量及流程控制","uri":"/go_2/"},{"categories":["Go"],"content":"3.3 for Go 的 for 循环有四种常见的使用方式，如下所示。最特殊的是第四种 for 循环的 range 格式，它可以对 slice、map、数组、字符串等进行迭代循环。 //方式一: 典型的类 C for 循环 for init; condition; post { } //方式二: 类 while 循环 for condition { } //方式三: 无限循环 for { } //无限循环的另一种方式 for true { } //方式四: 类Python 的迭代循环 for index, value := range oldMap { // index: 索引 // value: 索引对应的值 } ","date":"2021-01-02","objectID":"/go_2/:3:4","tags":["go 语法"],"title":"go 变量及流程控制","uri":"/go_2/"},{"categories":["Go"],"content":"4. 变量的生命周期与作用域 变量的生命周期指的是在程序运行期间变量有效存在的时间间隔，变量作用域是指源代码中可以有效使用这个名字的范围。虽然我将变量的生命周期与作用域放在一起，但是其实它们之间并没有什么联系。声明语句的作用域对应的是一个源代码的文本区域；它是一个 编译时的属性。一个变量的生命周期是指程序运行时变量存在的有效时间段，在此时间区域内它可以被程序的其他部分引用；是一个运行时的概念。 Go 与 Python 类似，通过引用计数的方式，解释器会自动实现对象内存的分配和释放。变量的生命周期取决于变量是否可达，即其引用计数是否为 0，而与变量的作用域无关。虽然大多数位于函数内的局部变量的生命周期都是函数调用的存续区间，但是函数内的局部变量可以\"逃逸\"成为全局变量，或者从函数返回，从而延长生命周期。 变量的作用域取决于变量声明语句所在的语法块(又称词法域)，语法块通常由花括号显示限定，除此之外还有一些特殊的语法块。对于 Go 作用域从大到小依次是: 整个源代码，称为全局语法块 每个包的包语法块 每个源文件的源文件级的语法块 由显示花括号限定的由外而内的语法块 对于 if,for,switch,select 还有隐式的语法块 一个程序可能包含多个同名的声明，只要它们在不同的作用域。位于内部作用域的变量声明显然会覆盖外部的同名变量。对于大多数程序的作用于而言，都有类似规则。而 Go 比较特殊的是 if,for,switch,select引入的隐式作用域。 if, for 等的隐式作用域 if x := f(); x == 0 { fmt.Println(x) } else if y := g(x); x == y { fmt.Println(x, y) } else { fmt.Println(x, y) } fmt.Println(x, y) // compile error: x and y are not visible here 在上面的示例中存在多个作用域，从大到小依次是: 全局作用域 外层 if 语句条件部分创建隐式词法域 外层 if 语句花括弧包含的显式作用域 内层 if 语句条件部分创建隐式词法域 ….. 因此内层 if 语句的条件测试部分，能访问到外层 if 语句条件部分声明的变量 x。for 语句循环的初始化部分，switch 语句的条件测试部分都会引入类似的隐式作用域。 变量的作用域问题说起来比较复杂，但是大多数情况下，只要我们不在不同的作用域内声明同名变量，导致变量覆盖，基本上都不会现问题。但是在 Go 中要特别注意短变量声明语句的作用域。 在下面的示例中，虽然cwd在外部已经声明过，但是 := 语句还是将cwd和err重新声明为新的局部变量。因为内部声明的cwd将屏蔽外部的声明，因此上面的代码并不会正确更新包级声明的cwd变量。 var cwd string func init() { cwd, err := os.Getwd() // compile error: unused: cwd if err != nil { log.Fatalf(\"os.Getwd failed: %v\", err) } } // 正确做法 var cwd string func init() { var err error # 单独声明 err 变量 cwd, err = os.Getwd() if err != nil { log.Fatalf(\"os.Getwd failed: %v\", err) } } 最后，Go 变量遵循先声明后使用的规则，但是在包级别，声明的顺序并不会影响作用域范围，因此一个先声明的可以引用它自身或者是引用后面的一个声明，这可以让我们定义一些相互嵌套或递归的类型或函数。 ","date":"2021-01-02","objectID":"/go_2/:4:0","tags":["go 语法"],"title":"go 变量及流程控制","uri":"/go_2/"},{"categories":["Go"],"content":"这个系列我们开始学习 go 语言的第一部分-语法","date":"2021-01-01","objectID":"/go_1/","tags":["go 语法"],"title":"go 入门开篇","uri":"/go_1/"},{"categories":["Go"],"content":"如果编程的世界是海贼王里的\"大航海时代\", go 语言可能就是\"草帽海贼团\" ","date":"2021-01-01","objectID":"/go_1/:0:0","tags":["go 语法"],"title":"go 入门开篇","uri":"/go_1/"},{"categories":["Go"],"content":"1. 要去学 Go 了 学习和使用 Python 有三四年,好想学一门新语言,打算学 Go。为什么是 Go，其实更想学 Rust。但是 Go 有谷歌这个大佬，背靠k8s，显然学 Go 好处大大的。其实也无所谓，哪天想学 Rust，就拿来看看对比着学可能更快。当然学 Go 还有另一个重要原因，想转运维开发。 ","date":"2021-01-01","objectID":"/go_1/:1:0","tags":["go 语法"],"title":"go 入门开篇","uri":"/go_1/"},{"categories":["Go"],"content":"2. 怎么学 Go 因为已经不是第一次学编程了，之前也看过一段时间 C，想看看在学习了编程这么长时间之后，在编程领域的学习能力相比于一开始有没有提升。所以这次打算从语言特性的角度出发，有目的性的对比学习，看看能不能以更快的速度学好 Go。下面是我能想到知识面: 基础语法，包括变量，循环，判断以及运算符 Go 语言提供的基本数据结构 异常处理 函数，类与泛型 并发编程 ","date":"2021-01-01","objectID":"/go_1/:2:0","tags":["go 语法"],"title":"go 入门开篇","uri":"/go_1/"},{"categories":["Go"],"content":"3. 学习资料 书选的《Go程序设计语言》，在写博客之前已经翻过一遍，的确是一本可以拿来入门的好书。 ","date":"2021-01-01","objectID":"/go_1/:3:0","tags":["go 语法"],"title":"go 入门开篇","uri":"/go_1/"},{"categories":["Go"],"content":"4. 环境搭建 在学习 Go 语言之前，最重要的是搭建一个 Go 的开发环境。为了对 Go 有一个更好的整体把握，对于这个开发环境我们至少完成下面这些任务。下面涉及的 Go 专业术语，后面会详细解释，为了便于理解，我简单的跟 Python作了一个对比 安装 Go，搭建基本的go开发环境 – python 安装 Go 语言工具箱，特别是 go 程序包的查询，下载和管理 – pip 的使用 Go 语言的工作目录 – 模块的搜索路径 IDE 编程环境 我们主要讲解 Linux 下的环境搭建，Windows 的搭建类似。我们使用 VScode 作为我们的IDE，没其他原因，因为大佬们都推荐。 ","date":"2021-01-01","objectID":"/go_1/:4:0","tags":["go 语法"],"title":"go 入门开篇","uri":"/go_1/"},{"categories":["Go"],"content":"4.1 Go 安装 Go 语言官方文档有完整的安装文档,Linux 下可直接运行下面的 bash 脚本，而唯一需要修改的是最后三个环境变量的配置。其中 PATH: 用于将 go 命令添加到环境变量的命令搜索路径中，便于直接使用 go 命令 GOPATH: 用于指定 go 的工作区，可以是单个目录路径，也可以是冒号分割的多个路径 GOBIN: 用于指定 GO 程序生成的可执行文件（executable file）的存放路径 先让你的 Go 可以运行起来，别的不用着急，马上我们就会讲解环境变量的作用，在你理解这些环境变量的含义之后就可以按需修改。 go_vsersion=go1.12.4.linux-amd64.tar.gz # 1. 下载安装包 wget https://studygolang.com/dl/golang/${go_vsersion}.tar.gz # 2. 解压到指定目录 tar -C /usr/local -xzf ${go_version}.tar.gz # 3. 配置相关环境变量 # 将 go 命令添加到 PATH 环境变量中，以便直接使用，PATH 环境变量与 GO 本身无关 echo 'export PATH=/usr/local/go/bin:$PATH' \u003e /etc/profile.d/go.sh # 添加 Go的工作区，下面默认为 $HOME/go echo 'export GOPATH=$(go env GOPATH)' \u003e\u003e /etc/profile.d/go.sh echo 'export GOBIN=$GOPATH/bin' \u003e\u003e /etc/profile.d/go. # 4. 并通过在命令行中输入go version来验证是否安装成功。 go version ","date":"2021-01-01","objectID":"/go_1/:4:1","tags":["go 语法"],"title":"go 入门开篇","uri":"/go_1/"},{"categories":["Go"],"content":"4.2 Go语言工具箱 在 go 安装完毕之后，在 go 安装目录的 bin 子目录下会有一个 go 命令(默认为/usr/local/go/bin)，这就是 go 语言提供给我们的管理工具箱，它是一系列功能的集合: 首先它是一个构建系统，计算文件的依赖关系，然后调用编译器、汇编器和连接器构建程序 其次它是一个包管理器（类似于python pip），用于包的查询、下载、依赖关系解决。 最后它是一个单元测试和基准测试的驱动程序 go 命令的执行依赖很多环境变量，使用 go env 可以查看所有的环境变量，大多数环境变量在 go 语言正确安装之后(主要是选择与操作系统匹配的安装包)会自动配置，唯一需要用户配置是GOPATH，用于指定go 语言的工作区，工作区是 go 语言中的一个核心概念，Go 语言项目在其生命周期内的所有操作（编码、依赖管理、构建、测试、安装等）基本上都是围绕着 GOPATH 和工作区进行的。 ","date":"2021-01-01","objectID":"/go_1/:4:2","tags":["go 语法"],"title":"go 入门开篇","uri":"/go_1/"},{"categories":["Go"],"content":"4.3 Go 工作区 GOPATH对应的工作区目录有三个子目录: src 子目录用于存储源代码，使用 go get 下载的 go 包和自定义的 go 程序源代码都存在此目录中，同时也是代码包搜索和导入的启始根目录 pkg子目录用于保存编译后的包的目标文件 bin子目录用于保存编译后的可执行程序 go build命令编译命令行参数指定的每个包。如果 src 使用命令 go get可以下载一个单一的包或者用 …下载整个子目录里面的每个包。go get 会自动下载所依赖的每个包 ","date":"2021-01-01","objectID":"/go_1/:4:3","tags":["go 语法"],"title":"go 入门开篇","uri":"/go_1/"},{"categories":["Go"],"content":"4.3 GOROOT 环境变量GOROOT用来指定Go的安装目录，还有它自带的标准库包的位置。GOROOT的目录结构和GOPATH类似，因此存放fmt包的源代码对应目录应该为$GOROOT/src/fmt。用户一般不需要设置GOROOT，默认情况下Go语言安装工具会将其设置为安装的目录路径。 下面是我当前工作区目录的示例: $ tree -L 2 /home/tao/go /home/tao/go ├── bin │ ├── a │ ├── dlv │ ├── gocode │ ├── godef │ ├── go-outline │ ├── gopkgs │ ├── goreturns │ └── helloworld ├── pkg │ └── linux_amd64 └── src ├── algo ├── blog ├── github.com ├── golang.org ├── gopl.io ├── sourcegraph.com └── test 你可以运行go或go help命令查看内置的帮助文档，为了查询方便，我们列出了最常用的命令 $ go Go is a tool for managing Go source code. Usage: go \u003ccommand\u003e [arguments] The commands are: bug start a bug report build compile packages and dependencies clean remove object files and cached files doc show documentation for package or symbol env print Go environment information fix update packages to use new APIs fmt gofmt (reformat) package sources generate generate Go files by processing source get download and install packages and dependencies install compile and install packages and dependencies list list packages or modules mod module maintenance run compile and run Go program test test packages tool run specified go tool version print Go version vet report likely mistakes in packages Use \"go help \u003ccommand\u003e\" for more information about a command. ","date":"2021-01-01","objectID":"/go_1/:4:4","tags":["go 语法"],"title":"go 入门开篇","uri":"/go_1/"},{"categories":["Go"],"content":"4.3 Go 环境变量 GOPATH对应的工作区目录有三个子目录。 与 Python 不同的是，Go 的包不是通过镜像的方式，而是直接从远程版本控制系统(eg: githup)直接下载的，因此当我们使用标准的 go get 下载Go包时，可能会由于不可描述的原因失败。因此我们必须手动解决一些包的安装问题。 ","date":"2021-01-01","objectID":"/go_1/:4:5","tags":["go 语法"],"title":"go 入门开篇","uri":"/go_1/"},{"categories":["Go"],"content":"4.2 Vscode 安装 在Vscode官网 下载与你系统时配的安装包，安装即可。安装完成后在 VScode Extension 安装与 go 相关的扩展，如下图所示: ","date":"2021-01-01","objectID":"/go_1/:4:6","tags":["go 语法"],"title":"go 入门开篇","uri":"/go_1/"},{"categories":["loveit"],"content":"探索 Hugo - LoveIt 主题的全部内容和背后的核心概念.","date":"2020-03-06","objectID":"/loveit_config/","tags":["loveit"],"title":"Loveit 配置","uri":"/loveit_config/"},{"categories":["loveit"],"content":"探索 Hugo - LoveIt 主题的全部内容和背后的核心概念. ","date":"2020-03-06","objectID":"/loveit_config/:0:0","tags":["loveit"],"title":"Loveit 配置","uri":"/loveit_config/"},{"categories":["loveit"],"content":"1 准备 由于 Hugo 提供的便利性, Hugo 本身是这个主题唯一的依赖. 直接安装满足你操作系统 (Windows, Linux, macOS) 的最新版本  Hugo (\u003e 0.62.0). 为什么不支持早期版本的 Hugo?\r\r由于 Markdown 渲染钩子函数 在 Hugo 圣诞节版本 中被引入, 本主题只支持高于 0.62.0 的 Hugo 版本.\r\r 推荐使用 Hugo extended 版本\r\r由于这个主题的一些特性需要将  SCSS 转换为  CSS, 推荐使用 Hugo extended 版本来获得更好的使用体验.\r\r ","date":"2020-03-06","objectID":"/loveit_config/:1:0","tags":["loveit"],"title":"Loveit 配置","uri":"/loveit_config/"},{"categories":["loveit"],"content":"2 安装 以下步骤可帮助你初始化新网站. 如果你根本不了解 Hugo, 我们强烈建议你按照此 快速入门文档 进一步了解它. ","date":"2020-03-06","objectID":"/loveit_config/:2:0","tags":["loveit"],"title":"Loveit 配置","uri":"/loveit_config/"},{"categories":["loveit"],"content":"2.1 创建你的项目 Hugo 提供了一个 new 命令来创建一个新的网站: hugo new site my_website cd my_website ","date":"2020-03-06","objectID":"/loveit_config/:2:1","tags":["loveit"],"title":"Loveit 配置","uri":"/loveit_config/"},{"categories":["loveit"],"content":"2.2 安装主题 LoveIt 主题的仓库是: https://github.com/dillonzq/LoveIt. 你可以下载主题的 最新版本  .zip 文件 并且解压放到 themes 目录. 另外, 也可以直接把这个主题克隆到 themes 目录: git clone https://github.com/dillonzq/LoveIt.git themes/LoveIt 或者, 初始化你的项目目录为 git 仓库, 并且把主题仓库作为你的网站目录的子模块: git init git submodule add https://github.com/dillonzq/LoveIt.git themes/LoveIt ","date":"2020-03-06","objectID":"/loveit_config/:2:2","tags":["loveit"],"title":"Loveit 配置","uri":"/loveit_config/"},{"categories":["loveit"],"content":"2.3 基础配置 以下是 LoveIt 主题的基本配置: baseURL = \"http://example.org/\" # [en, zh-cn, fr, ...] 设置默认的语言 defaultContentLanguage = \"zh-cn\" # 网站语言, 仅在这里 CN 大写 languageCode = \"zh-CN\" # 是否包括中日韩文字 hasCJKLanguage = true # 网站标题 title = \"我的全新 Hugo 网站\" # 更改使用 Hugo 构建网站时使用的默认主题 theme = \"LoveIt\" [params] # LoveIt 主题版本 version = \"0.2.X\" [menu] [[menu.main]] identifier = \"posts\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" name = \"文章\" url = \"/posts/\" # 当你将鼠标悬停在此菜单链接上时, 将显示的标题 title = \"\" weight = 1 [[menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"标签\" url = \"/tags/\" title = \"\" weight = 2 [[menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"分类\" url = \"/categories/\" title = \"\" weight = 3 # Hugo 解析文档的配置 [markup] # 语法高亮设置 (https://gohugo.io/content-management/syntax-highlighting) [markup.highlight] # false 是必要的设置 (https://github.com/dillonzq/LoveIt/issues/158) noClasses = false 注意\r\r在构建网站时, 你可以使用 --theme 选项设置主题. 但是, 我建议你修改配置文件 (config.toml) 将本主题设置为默认主题.\r\r ","date":"2020-03-06","objectID":"/loveit_config/:2:3","tags":["loveit"],"title":"Loveit 配置","uri":"/loveit_config/"},{"categories":["loveit"],"content":"2.4 创建你的第一篇文章 以下是创建第一篇文章的方法: hugo new posts/first_post.md 通过添加一些示例内容并替换文件开头的标题, 你可以随意编辑文章. 注意\r\r默认情况下, 所有文章和页面均作为草稿创建. 如果想要渲染这些页面, 请从元数据中删除属性 draft: true, 设置属性 draft: false 或者为 hugo 命令添加 -D/--buildDrafts 参数.\r\r ","date":"2020-03-06","objectID":"/loveit_config/:2:4","tags":["loveit"],"title":"Loveit 配置","uri":"/loveit_config/"},{"categories":["loveit"],"content":"2.5 在本地启动网站 使用以下命令启动网站: hugo serve 去查看 http://localhost:1313. 基本配置下的预览基本配置下的预览 \"\r基本配置下的预览\r 技巧\r\r当你运行 hugo serve 时, 当文件内容更改时, 页面会随着更改自动刷新.\r\r 注意\r\r由于本主题使用了 Hugo 中的 .Scratch 来实现一些特性, 非常建议你为 hugo server 命令添加 --disableFastRender 参数来实时预览你正在编辑的文章页面. hugo serve --disableFastRender \r\r ","date":"2020-03-06","objectID":"/loveit_config/:2:5","tags":["loveit"],"title":"Loveit 配置","uri":"/loveit_config/"},{"categories":["loveit"],"content":"2.6 构建网站 当你准备好部署你的网站时, 运行以下命令: hugo 会生成一个 public 目录, 其中包含你网站的所有静态内容和资源. 现在可以将其部署在任何 Web 服务器上. 技巧\r\r网站内容可以通过 Netlify 自动发布和托管 (了解有关通过 Netlify 进行 HUGO 自动化部署 的更多信息). 或者, 您可以使用 AWS Amplify, Github pages, Render 以及更多…\r\r ","date":"2020-03-06","objectID":"/loveit_config/:2:6","tags":["loveit"],"title":"Loveit 配置","uri":"/loveit_config/"},{"categories":["loveit"],"content":"3 配置 ","date":"2020-03-06","objectID":"/loveit_config/:3:0","tags":["loveit"],"title":"Loveit 配置","uri":"/loveit_config/"},{"categories":["loveit"],"content":"3.1 网站配置 除了 Hugo 全局配置 和 菜单配置 之外, LoveIt 主题还允许您在网站配置中定义以下参数 (这是一个示例 config.toml, 其内容为默认值). 请打开下面的代码块查看完整的示例配置 : [params] # LoveIt 主题版本 version = \"0.2.X\" # 网站描述 description = \"这是我的全新 Hugo 网站\" # 网站关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 哪种哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\"fixed\", \"normal\", \"auto\") desktopMode = \"fixed\" # 移动端导航栏模式 (\"fixed\", \"normal\", \"auto\") mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = false # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2019 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = '\u003ca rel=\"license external nofollow noopener noreffer\" href=\"https://creativecommons.org/licenses/by-nc/4.0/\" target=\"_blank\"\u003eCC BY-NC 4.0\u003c/a\u003e' # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 # List (目录或标签) 页面配置 [params.list] # list 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 # 主页配置 [params.home] # RSS 文章数目 rss = 10 # 主页个人信息 [params.home.profile] enable = true # Gravatar 邮箱，用于优先在主页显示的头像 gravatarEmail = \"\" # 主页显示头像的 URL avatarURL = \"/images/avatar.png\" # 主页显示的网站标题 (支持 HTML 格式) title = \"\" # 主页显示的网站副标题 subtitle = \"这是我的全新 Hugo 网站\" # 是否为副标题显示打字机动画 typeit = true # 是否显示社交账号 social = true # 免责声明 (支持 HTML 格式) disclaimer = \"\" # 主页文章列表 [params.home.posts] enable = true # 主页每页显示文章数量 paginate = 6 # 被 params.page 中的 hiddenFromHomePage 替代 # 当你没有在文章前置参数中设置 \"hiddenFromHomePage\" 时的默认行为 defaultHiddenFromHomePage = false # 作者的社交信息设置 [params.social] GitHub = \"xxxx\" Linkedin = \"\" Twitter = \"xxxx\" Instagram = \"xxxx\" Facebook = \"xxxx\" Telegram = \"xxxx\" Medium = \"\" Gitlab = \"\" Youtubelegacy = \"\" Youtubecustom = \"\" Youtubechannel = \"\" Tumblr = \"\" Quora = \"\" Keybase = \"\" Pinterest = \"\" Reddit = \"\" Codepen = \"\" FreeCodeCamp = \"\" Bitbucket = \"\" Stackoverflow = \"\" Weibo = \"\" Odnoklassniki = \"\" VK = \"\" Flickr = \"\" Xing = \"\" Snapchat = \"\" Soundcloud = \"\" Spotify = \"\" Bandcamp = \"\" Paypal = \"\" Fivehundredpx = \"\" Mix = \"\" Goodreads = \"\" Lastfm = \"\" Foursquare = \"\" Hackernews = \"\" Kickstarter = \"\" Patreon = \"\" Steam = \"\" Twitch = \"\" Strava = \"\" Skype = \"\" Whatsapp = \"\" Zhihu = \"\" Douban = \"\" Angellist = \"\" Slidershare = \"\" Jsfiddle = \"\" Deviantart = \"\" Behance = \"\" Dribbble = \"\" Wordpress = \"\" Vine = \"\" Googlescholar = \"\" Researchgate = \"\" Mastodon = \"\" Thingiverse = \"\" Devto = \"\" Gitea = \"\" XMPP = \"\" Matrix = \"\" Bilibili = \"\" Email = \"xxxx@xxxx.com\" RSS = true # # 文章页面配置 [params.page] # 是否在主页隐藏一篇文章 hiddenFromHomePage = false # 是否在搜索结果中隐藏一篇文章 hiddenFromSearch = false # 是否使用 twemoji twemoji = false # 是否使用 lightgallery lightgallery = false # 是否使用 ruby 扩展语法 ruby = true # 是否使用 fraction 扩展语法 fraction = true # 是否使用 fontawesome 扩展语法 fontawesome = true # 是否在文章页面显示原始 Markdown 文档链接 linkToMarkdown = true # 是否在 RSS 中显示全文内容 rssFullText = ","date":"2020-03-06","objectID":"/loveit_config/:3:1","tags":["loveit"],"title":"Loveit 配置","uri":"/loveit_config/"},{"categories":["loveit"],"content":"3.2 网站图标, 浏览器配置, 网站清单 强烈建议你把: apple-touch-icon.png (180x180) favicon-32x32.png (32x32) favicon-16x16.png (16x16) mstile-150x150.png (150x150) android-chrome-192x192.png (192x192) android-chrome-512x512.png (512x512) 放在 /static 目录. 利用 https://realfavicongenerator.net/ 可以很容易地生成这些文件. 可以自定义 browserconfig.xml 和 site.webmanifest 文件来设置 theme-color 和 background-color. ","date":"2020-03-06","objectID":"/loveit_config/:3:2","tags":["loveit"],"title":"Loveit 配置","uri":"/loveit_config/"},{"categories":["loveit"],"content":"3.3 自定义样式 注意\r\rHugo extended 版本对于自定义样式是必需的.\r\r 通过定义自定义 .scss 样式文件, LoveIt 主题支持可配置的样式. 包含自定义 .scss 样式文件的目录相对于 你的项目根目录 的路径为 assets/css. 在 assets/css/_override.scss 中, 你可以覆盖 themes/LoveIt/assets/css/_variables.scss 中的变量以自定义样式. 这是一个例子: @import url('https://fonts.googleapis.com/css?family=Fira+Mono:400,700\u0026display=swap\u0026subset=latin-ext'); $code-font-family: Fira Mono, Source Code Pro, Menlo, Consolas, Monaco, monospace; 在 assets/css/_custom.scss 中, 你可以添加一些 CSS 样式代码以自定义样式. ","date":"2020-03-06","objectID":"/loveit_config/:3:3","tags":["loveit"],"title":"Loveit 配置","uri":"/loveit_config/"},{"categories":["loveit"],"content":"4 多语言和 i18n LoveIt 主题完全兼容 Hugo 的多语言模式, 并且支持在网页上切换语言. 语言切换语言切换 \"\r语言切换\r ","date":"2020-03-06","objectID":"/loveit_config/:4:0","tags":["loveit"],"title":"Loveit 配置","uri":"/loveit_config/"},{"categories":["loveit"],"content":"4.1 兼容性 语言 Hugo 代码 HTML lang 属性 主题文档 Lunr.js 支持 英语 en en 简体中文 zh-cn zh-CN 法语 fr fr 波兰语 pl pl 巴西葡萄牙语 pt-br pt-BR 意大利语 it it 西班牙语 es es 德语 de de 塞尔维亚语 pl pl 俄语 ru ru 罗马尼亚语 ro ro 越南语 vi vi ","date":"2020-03-06","objectID":"/loveit_config/:4:1","tags":["loveit"],"title":"Loveit 配置","uri":"/loveit_config/"},{"categories":["loveit"],"content":"4.2 基本配置 学习了 Hugo如何处理多语言网站 之后, 请在 站点配置 中定义你的网站语言. 例如, 一个支持英语, 中文和法语的网站配置: # [en, zh-cn, fr, pl, ...] 设置默认的语言 defaultContentLanguage = \"zh-cn\" [languages] [languages.en] weight = 1 title = \"My New Hugo Site\" languageCode = \"en\" languageName = \"English\" [[languages.en.menu.main]] identifier = \"posts\" pre = \"\" post = \"\" name = \"Posts\" url = \"/posts/\" title = \"\" weight = 1 [[languages.en.menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"Tags\" url = \"/tags/\" title = \"\" weight = 2 [[languages.en.menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"Categories\" url = \"/categories/\" title = \"\" weight = 3 [languages.zh-cn] weight = 2 title = \"我的全新 Hugo 网站\" # 网站语言, 仅在这里 CN 大写 languageCode = \"zh-CN\" languageName = \"简体中文\" # 是否包括中日韩文字 hasCJKLanguage = true [[languages.zh-cn.menu.main]] identifier = \"posts\" pre = \"\" post = \"\" name = \"文章\" url = \"/posts/\" title = \"\" weight = 1 [[languages.zh-cn.menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"标签\" url = \"/tags/\" title = \"\" weight = 2 [[languages.zh-cn.menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"分类\" url = \"/categories/\" title = \"\" weight = 3 [languages.fr] weight = 3 title = \"Mon nouveau site Hugo\" languageCode = \"fr\" languageName = \"Français\" [[languages.fr.menu.main]] identifier = \"posts\" pre = \"\" post = \"\" name = \"Postes\" url = \"/posts/\" title = \"\" weight = 1 [[languages.fr.menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"Balises\" url = \"/tags/\" title = \"\" weight = 2 [[languages.fr.menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"Catégories\" url = \"/categories/\" title = \"\" weight = 3 然后, 对于每个新页面, 将语言代码附加到文件名中. 单个文件 my-page.md 需要分为三个文件: 英语: my-page.en.md 中文: my-page.zh-cn.md 法语: my-page.fr.md 注意\r\r请注意, 菜单中仅显示翻译的页面. 它不会替换为默认语言内容.\r\r 技巧\r\r也可以使用 文章前置参数 来翻译网址.\r\r ","date":"2020-03-06","objectID":"/loveit_config/:4:2","tags":["loveit"],"title":"Loveit 配置","uri":"/loveit_config/"},{"categories":["loveit"],"content":"4.3 修改默认的翻译字符串 翻译字符串用于在主题中使用的常见默认值. 目前提供一些语言的翻译, 但你可能自定义其他语言或覆盖默认值. 要覆盖默认值, 请在你项目的 i18n 目录 i18n/\u003clanguageCode\u003e.toml 中创建一个新文件，并从 themes/LoveIt/i18n/en.toml 中获得提示. 另外, 由于你的翻译可能会帮助到其他人, 请花点时间通过  创建一个 PR 来贡献主题翻译, 谢谢! ","date":"2020-03-06","objectID":"/loveit_config/:4:3","tags":["loveit"],"title":"Loveit 配置","uri":"/loveit_config/"},{"categories":["loveit"],"content":"5 搜索 基于 Lunr.js 或 algolia, LoveIt 主题支持搜索功能. ","date":"2020-03-06","objectID":"/loveit_config/:5:0","tags":["loveit"],"title":"Loveit 配置","uri":"/loveit_config/"},{"categories":["loveit"],"content":"5.1 输出配置 为了生成搜索功能所需要的 index.json, 请在你的 网站配置 中添加 JSON 输出文件类型到 outputs 部分的 home 字段中. [outputs] home = [\"HTML\", \"RSS\", \"JSON\"] ","date":"2020-03-06","objectID":"/loveit_config/:5:1","tags":["loveit"],"title":"Loveit 配置","uri":"/loveit_config/"},{"categories":["loveit"],"content":"5.2 搜索配置 基于 Hugo 生成的 index.json 文件, 你可以激活搜索功能. 这是你的 网站配置 中的搜索部分: [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" 怎样选择搜索引擎?\r\r以下是两种搜索引擎的对比: lunr: 简单, 无需同步 index.json, 没有 contentLength 的限制, 但占用带宽大且性能低 (特别是中文需要一个较大的分词依赖库) algolia: 高性能并且占用带宽低, 但需要同步 index.json 且有 contentLength 的限制 文章内容被 h2 和 h3 HTML 标签切分来提高查询效果并且基本实现全文搜索. contentLength 用来限制 h2 和 h3 HTML 标签开头的内容部分的最大长度. \r\r 关于 algolia 的使用技巧\r\r你需要上传 index.json 到 algolia 来激活搜索功能. 你可以使用浏览器来上传 index.json 文件但是一个自动化的脚本可能效果更好. Algolia Atomic 是一个不错的选择. 为了兼容 Hugo 的多语言模式, 你需要上传不同语言的 index.json 文件到对应的 algolia index, 例如 zh-cn/index.json 或 fr/index.json…\r\r","date":"2020-03-06","objectID":"/loveit_config/:5:2","tags":["loveit"],"title":"Loveit 配置","uri":"/loveit_config/"},{"categories":["loveit"],"content":"了解如何在 LoveIt 主题中快速, 直观地创建和组织内容.","date":"2020-03-05","objectID":"/loveit_content/","tags":["loveit"],"title":"Loveit 内容组织","uri":"/loveit_content/"},{"categories":["loveit"],"content":"了解如何在 LoveIt 主题中快速, 直观地创建和组织内容. ","date":"2020-03-05","objectID":"/loveit_content/:0:0","tags":["loveit"],"title":"Loveit 内容组织","uri":"/loveit_content/"},{"categories":["loveit"],"content":"1 内容组织 以下是一些方便你清晰管理和生成文章的目录结构建议: 保持博客文章存放在 content/posts 目录, 例如: content/posts/我的第一篇文章.md 保持简单的静态页面存放在 content 目录, 例如: content/about.md 本地资源组织 本地资源引用\r\r 有三种方法来引用图片和音乐等本地资源: 使用页面包中的页面资源. 你可以使用适用于 Resources.GetMatch 的值或者直接使用相对于当前页面目录的文件路径来引用页面资源. 将本地资源放在 assets 目录中, 默认路径是 /assets. 引用资源的文件路径是相对于 assets 目录的. 将本地资源放在 static 目录中, 默认路径是 /static. 引用资源的文件路径是相对于 static 目录的. 引用的优先级符合以上的顺序. 在这个主题中的很多地方可以使用上面的本地资源引用, 例如 链接, 图片, image shortcode, music shortcode 和前置参数中的部分参数. 页面资源或者 assets 目录中的图片处理会在未来的版本中得到支持. 非常酷的功能! \r\r ","date":"2020-03-05","objectID":"/loveit_content/:1:0","tags":["loveit"],"title":"Loveit 内容组织","uri":"/loveit_content/"},{"categories":["loveit"],"content":"2 前置参数 Hugo 允许你在文章内容前面添加 yaml, toml 或者 json 格式的前置参数. 注意\r\r不是所有的以下前置参数都必须在你的每篇文章中设置. 只有在文章的参数和你的 网站设置 中的 page 部分不一致时才有必要这么做.\r\r 这是一个前置参数例子: ---title:\"我的第一篇文章\"subtitle:\"\"date:2020-03-04T15:58:26+08:00lastmod:2020-03-04T15:58:26+08:00draft:trueauthor:\"\"authorLink:\"\"description:\"\"license:\"\"images:[]tags:[]categories:[]featuredImage:\"\"featuredImagePreview:\"\"hiddenFromHomePage:falsehiddenFromSearch:falsetwemoji:falselightgallery:trueruby:truefraction:truefontawesome:truelinkToMarkdown:truerssFullText:falsetoc:enable:trueauto:truecode:copy:true# ...math:enable:true# ...mapbox:accessToken:\"\"# ...share:enable:true# ...comment:enable:true# ...library:css:# someCSS = \"some.css\"# 位于 \"assets/\"# 或者# someCSS = \"https://cdn.example.com/some.css\"js:# someJS = \"some.js\"# 位于 \"assets/\"# 或者# someJS = \"https://cdn.example.com/some.js\"seo:images:[]# ...--- title: 文章标题. subtitle: 文章副标题. date: 这篇文章创建的日期时间. 它通常是从文章的前置参数中的 date 字段获取的, 但是也可以在 网站配置 中设置. lastmod: 上次修改内容的日期时间. draft: 如果设为 true, 除非 hugo 命令使用了 --buildDrafts/-D 参数, 这篇文章不会被渲染. author: 文章作者. authorLink: 文章作者的链接. description: 文章内容的描述. license: 这篇文章特殊的许可. images: 页面图片, 用于 Open Graph 和 Twitter Cards. tags: 文章的标签. categories: 文章所属的类别. featuredImage: 文章的特色图片. featuredImagePreview: 用在主页预览的文章特色图片. hiddenFromHomePage: 如果设为 true, 这篇文章将不会显示在主页上. hiddenFromSearch: 如果设为 true, 这篇文章将不会显示在搜索结果中. twemoji: 如果设为 true, 这篇文章会使用 twemoji. lightgallery: 如果设为 true, 文章中的图片将可以按照画廊形式呈现. ruby: 如果设为 true, 这篇文章会使用 上标注释扩展语法. fraction: 如果设为 true, 这篇文章会使用 分数扩展语法. fontawesome: 如果设为 true, 这篇文章会使用 Font Awesome 扩展语法. linkToMarkdown: 如果设为 true, 内容的页脚将显示指向原始 Markdown 文件的链接. rssFullText: 如果设为 true, 在 RSS 中将会显示全文内容. toc: 和 网站配置 中的 params.page.toc 部分相同. code: 和 网站配置 中的 params.page.code 部分相同. math: 和 网站配置 中的 params.page.math 部分相同. mapbox: 和 网站配置 中的 params.page.mapbox 部分相同. share: 和 网站配置 中的 params.page.share 部分相同. comment: 和 网站配置 中的 params.page.comment 部分相同. library: 和 网站配置 中的 params.page.library 部分相同. seo: 和 网站配置 中的 params.page.seo 部分相同. 技巧\r\r featuredImage 和 featuredImagePreview 支持本地资源引用的完整用法. 如果带有在前置参数中设置了 name: featured-image 或 name: featured-image-preview 属性的页面资源, 没有必要在设置 featuredImage 或 featuredImagePreview: resources:- name:featured-imagesrc:featured-image.jpg- name:featured-image-previewsrc:featured-image-preview.jpg \r\r ","date":"2020-03-05","objectID":"/loveit_content/:2:0","tags":["loveit"],"title":"Loveit 内容组织","uri":"/loveit_content/"},{"categories":["loveit"],"content":"3 内容摘要 LoveIt 主题使用内容摘要在主页中显示大致文章信息。Hugo 支持生成文章的摘要. 文章摘要预览文章摘要预览 \"\r文章摘要预览\r ","date":"2020-03-05","objectID":"/loveit_content/:3:0","tags":["loveit"],"title":"Loveit 内容组织","uri":"/loveit_content/"},{"categories":["loveit"],"content":"自动摘要拆分 默认情况下, Hugo 自动将内容的前 70 个单词作为摘要. 你可以通过在 网站配置 中设置 summaryLength 来自定义摘要长度. 如果您要使用 CJK中文/日语/韩语 语言创建内容, 并且想使用 Hugo 的自动摘要拆分功能，请在 网站配置 中将 hasCJKLanguage 设置为 true. ","date":"2020-03-05","objectID":"/loveit_content/:3:1","tags":["loveit"],"title":"Loveit 内容组织","uri":"/loveit_content/"},{"categories":["loveit"],"content":"手动摘要拆分 另外, 你也可以添加 \u003c!--more--\u003e 摘要分割符来拆分文章生成摘要. 摘要分隔符之前的内容将用作该文章的摘要. 注意\r\r请小心输入\u003c!--more--\u003e ; 即全部为小写且没有空格.\r\r ","date":"2020-03-05","objectID":"/loveit_content/:3:2","tags":["loveit"],"title":"Loveit 内容组织","uri":"/loveit_content/"},{"categories":["loveit"],"content":"前置参数摘要 你可能希望摘要不是文章开头的文字. 在这种情况下, 你可以在文章前置参数的 summary 变量中设置单独的摘要. ","date":"2020-03-05","objectID":"/loveit_content/:3:3","tags":["loveit"],"title":"Loveit 内容组织","uri":"/loveit_content/"},{"categories":["loveit"],"content":"使用文章描述作为摘要 你可能希望将文章前置参数中的 description 变量的内容作为摘要. 你仍然需要在文章开头添加 \u003c!--more--\u003e 摘要分割符. 将摘要分隔符之前的内容保留为空. 然后 LoveIt 主题会将你的文章描述作为摘要. ","date":"2020-03-05","objectID":"/loveit_content/:3:4","tags":["loveit"],"title":"Loveit 内容组织","uri":"/loveit_content/"},{"categories":["loveit"],"content":"摘要选择的优先级顺序 由于可以通过多种方式指定摘要, 因此了解顺序很有用. 如下: 如果文章中有 \u003c!--more--\u003e 摘要分隔符, 但分隔符之前没有内容, 则使用描述作为摘要. 如果文章中有 \u003c!--more--\u003e 摘要分隔符, 则将按照手动摘要拆分的方法获得摘要. 如果文章前置参数中有摘要变量, 那么将以该值作为摘要. 按照自动摘要拆分方法. 注意\r\r不建议在摘要内容中包含富文本块元素, 这会导致渲染错误. 例如代码块, 图片, 表格等.\r\r ","date":"2020-03-05","objectID":"/loveit_content/:3:5","tags":["loveit"],"title":"Loveit 内容组织","uri":"/loveit_content/"},{"categories":["loveit"],"content":"4 Markdown 基本语法 这部分内容在 Markdown 基本语法页面 中介绍. ","date":"2020-03-05","objectID":"/loveit_content/:4:0","tags":["loveit"],"title":"Loveit 内容组织","uri":"/loveit_content/"},{"categories":["loveit"],"content":"5 Markdown 扩展语法 LoveIt 主题提供了一些扩展的语法便于你撰写文章. ","date":"2020-03-05","objectID":"/loveit_content/:5:0","tags":["loveit"],"title":"Loveit 内容组织","uri":"/loveit_content/"},{"categories":["loveit"],"content":"Emoji 支持 这部分内容在 Emoji 支持页面 中介绍. ","date":"2020-03-05","objectID":"/loveit_content/:5:1","tags":["loveit"],"title":"Loveit 内容组织","uri":"/loveit_content/"},{"categories":["loveit"],"content":"数学公式 LoveIt 基于 $ \\KaTeX $ 提供数学公式的支持. 在你的 网站配置 中的 [params.math] 下面设置属性 enable = true, 并在文章的前置参数中设置属性 math: true来启用数学公式的自动渲染. 技巧\r\r有一份 $ \\KaTeX $ 中支持的 $ \\TeX $ 函数 清单.\r\r 公式块 默认的公式块分割符是 $$/$$ 和 \\\\[/\\\\]: $$ c = \\pm\\sqrt{a^2 + b^2} $$ \\\\[ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\\\] 呈现的输出效果如下: $$ c = \\pm\\sqrt{a^2 + b^2} $$ \\[ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\] 行内公式 默认的行内公式分割符是 $/$ 和 \\\\(/\\\\): $ c = \\pm\\sqrt{a^2 + b^2} $ 和 \\\\( f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\\\) 呈现的输出效果如下: $ c = \\pm\\sqrt{a^2 + b^2} $ 和 \\( f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\) 技巧\r\r你可以在 网站配置 中自定义公式块和行内公式的分割符.\r\r Copy-tex Copy-tex 是一个 $ \\KaTeX $ 的插件. 通过这个扩展, 在选择并复制 $ \\KaTeX $ 渲染的公式时, 会将其 $ \\LaTeX $ 源代码复制到剪贴板. 在你的 网站配置 中的 [params.math] 下面设置属性 copyTex = true 来启用 Copy-tex. 选择并复制上一节中渲染的公式, 可以发现复制的内容为 LaTeX 源代码. mhchem mhchem 是一个 $ \\KaTeX $ 的插件. 通过这个扩展, 你可以在文章中轻松编写漂亮的化学方程式. 在你的 网站配置 中的 [params.math] 下面设置属性 mhchem = true 来启用 mhchem. $$ \\ce{CO2 + C -\u003e 2 CO} $$ $$ \\ce{Hg^2+ -\u003e[I-] HgI2 -\u003e[I-] [Hg^{II}I4]^2-} $$ 呈现的输出效果如下: $$ \\ce{CO2 + C -\u003e 2 CO} $$ $$ \\ce{Hg^2+ -\u003e[I-] HgI2 -\u003e[I-] [Hg^{II}I4]^2-} $$ ","date":"2020-03-05","objectID":"/loveit_content/:5:2","tags":["loveit"],"title":"Loveit 内容组织","uri":"/loveit_content/"},{"categories":["loveit"],"content":"字符注音或者注释 LoveIt 主题支持一种 字符注音或者注释 Markdown 扩展语法: [Hugo]^(一个开源的静态网站生成工具) 呈现的输出效果如下: Hugo一个开源的静态网站生成工具 ","date":"2020-03-05","objectID":"/loveit_content/:5:3","tags":["loveit"],"title":"Loveit 内容组织","uri":"/loveit_content/"},{"categories":["loveit"],"content":"分数 LoveIt 主题支持一种 分数 Markdown 扩展语法: [浅色]/[深色] [99]/[100] 呈现的输出效果如下: 浅色/深色 90/100 ","date":"2020-03-05","objectID":"/loveit_content/:5:4","tags":["loveit"],"title":"Loveit 内容组织","uri":"/loveit_content/"},{"categories":["loveit"],"content":"Font Awesome LoveIt 主题使用 Font Awesome 作为图标库. 你同样可以在文章中轻松使用这些图标. 从 Font Awesome 网站 上获取所需的图标 class. 去露营啦! :(fas fa-campground fa-fw): 很快就回来. 真开心! :(far fa-grin-tears): 呈现的输出效果如下: 去露营啦!  很快就回来. 真开心! ","date":"2020-03-05","objectID":"/loveit_content/:5:5","tags":["loveit"],"title":"Loveit 内容组织","uri":"/loveit_content/"},{"categories":["loveit"],"content":"转义字符 在某些特殊情况下 (编写这个主题文档时 ), 你的文章内容会与 Markdown 的基本或者扩展语法冲突, 并且无法避免. 转义字符语法可以帮助你渲染出想要的内容: {?X} -\u003e X 例如, 两个 : 会启用 emoji 语法. 但有时候这不是你想要的结果. 可以像这样使用转义字符语法: {?:}joy: 呈现的输出效果如下: :joy: 而不是 😂 技巧\r\r这个方法可以间接解决一个还未解决的 Hugo 的 issue.\r\r 另一个例子是: [link{?]}(#escape-character) 呈现的输出效果如下: [link](#escape-character) 而不是 link. ","date":"2020-03-05","objectID":"/loveit_content/:5:6","tags":["loveit"],"title":"Loveit 内容组织","uri":"/loveit_content/"},{"categories":["loveit"],"content":"Hugo 提供了多个内置的 Shortcodes, 以方便作者保持 Markdown 内容的整洁.","date":"2020-03-04","objectID":"/loveit_shortcodes/","tags":["loveit"],"title":"Loveit 内置 Shortcodes","uri":"/loveit_shortcodes/"},{"categories":["loveit"],"content":"Hugo 提供了多个内置的 Shortcodes, 以方便作者保持 Markdown 内容的整洁. Hugo 使用 Markdown 为其简单的内容格式. 但是, Markdown 在很多方面都无法很好地支持. 你可以使用纯 HTML 来扩展可能性. 但这恰好是一个坏主意. 大家使用 Markdown, 正是因为它即使不经过渲染也可以轻松阅读. 应该尽可能避免使用 HTML 以保持内容简洁. 为了避免这种限制, Hugo 创建了 shortcodes. shortcode 是一个简单代码段, 可以生成合理的 HTML 代码, 并且符合 Markdown 的设计哲学. Hugo 附带了一组预定义的 shortcodes, 它们实现了一些非常常见的用法. 提供这些 shortcodes 是为了方便保持你的 Markdown 内容简洁. ","date":"2020-03-04","objectID":"/loveit_shortcodes/:0:0","tags":["loveit"],"title":"Loveit 内置 Shortcodes","uri":"/loveit_shortcodes/"},{"categories":["loveit"],"content":"1 figure figure 的文档 一个 figure 示例: {{\u003c figure src=\"/images/hugo/lighthouse.jpg\" title=\"Lighthouse (figure)\" \u003e}} 呈现的输出效果如下: Lighthouse (figure) 输出的 HTML 看起来像这样: \u003cfigure\u003e \u003cimg src=\"/images/hugo/lighthouse.jpg\"/\u003e \u003cfigcaption\u003e \u003ch4\u003eLighthouse (figure)\u003c/h4\u003e \u003c/figcaption\u003e \u003c/figure\u003e ","date":"2020-03-04","objectID":"/loveit_shortcodes/:1:0","tags":["loveit"],"title":"Loveit 内置 Shortcodes","uri":"/loveit_shortcodes/"},{"categories":["loveit"],"content":"2 gist gist 的文档 一个 gist 示例: {{\u003c gist spf13 7896402 \u003e}} 呈现的输出效果如下: 输出的 HTML 看起来像这样: \u003cscript type=\"application/javascript\" src=\"https://gist.github.com/spf13/7896402.js\"\u003e\u003c/script\u003e ","date":"2020-03-04","objectID":"/loveit_shortcodes/:2:0","tags":["loveit"],"title":"Loveit 内置 Shortcodes","uri":"/loveit_shortcodes/"},{"categories":["loveit"],"content":"3 highlight highlight 的文档 一个 highlight 示例: {{\u003c highlight html \u003e}} \u003csection id=\"main\"\u003e \u003cdiv\u003e \u003ch1 id=\"title\"\u003e{{ .Title }}\u003c/h1\u003e {{ range .Pages }} {{ .Render \"summary\"}} {{ end }} \u003c/div\u003e \u003c/section\u003e {{\u003c /highlight \u003e}} 呈现的输出效果如下: \u003csection id=\"main\"\u003e \u003cdiv\u003e \u003ch1 id=\"title\"\u003e{{ .Title }}\u003c/h1\u003e {{ range .Pages }} {{ .Render \"summary\"}} {{ end }} \u003c/div\u003e \u003c/section\u003e ","date":"2020-03-04","objectID":"/loveit_shortcodes/:3:0","tags":["loveit"],"title":"Loveit 内置 Shortcodes","uri":"/loveit_shortcodes/"},{"categories":["loveit"],"content":"4 instagram instagram 的文档 Instagram’s API was deprecated since October 24th, 2020\r\rThe instagram-shortcode refers an endpoint of Instagram’s API, that’s deprecated since October 24th, 2020. Thus, no images can be fetched from this API endpoint, resulting in an error when the instagram-shortcode is used. For more information please have a look at GitHub issue #7879.\r\r ","date":"2020-03-04","objectID":"/loveit_shortcodes/:4:0","tags":["loveit"],"title":"Loveit 内置 Shortcodes","uri":"/loveit_shortcodes/"},{"categories":["loveit"],"content":"5 param param 的文档 一个 param 示例: {{\u003c param description \u003e}} 呈现的输出效果如下: Hugo 提供了多个内置的 Shortcodes, 以方便作者保持 Markdown 内容的整洁. ","date":"2020-03-04","objectID":"/loveit_shortcodes/:5:0","tags":["loveit"],"title":"Loveit 内置 Shortcodes","uri":"/loveit_shortcodes/"},{"categories":["loveit"],"content":"6 ref 和 relref ref 和 relref 的文档 ","date":"2020-03-04","objectID":"/loveit_shortcodes/:6:0","tags":["loveit"],"title":"Loveit 内置 Shortcodes","uri":"/loveit_shortcodes/"},{"categories":["loveit"],"content":"7 tweet tweet 的文档 一个 tweet 示例: {{\u003c tweet 917359331535966209 \u003e}} 呈现的输出效果如下: ","date":"2020-03-04","objectID":"/loveit_shortcodes/:7:0","tags":["loveit"],"title":"Loveit 内置 Shortcodes","uri":"/loveit_shortcodes/"},{"categories":["loveit"],"content":"8 vimeo vimeo 的文档 一个 vimeo 示例: {{\u003c vimeo 146022717 \u003e}} 呈现的输出效果如下: ","date":"2020-03-04","objectID":"/loveit_shortcodes/:8:0","tags":["loveit"],"title":"Loveit 内置 Shortcodes","uri":"/loveit_shortcodes/"},{"categories":["loveit"],"content":"9 youtube youtube 的文档 一个 youtube 示例: {{\u003c youtube w7Ft2ymGmfc \u003e}} 呈现的输出效果如下: ","date":"2020-03-04","objectID":"/loveit_shortcodes/:9:0","tags":["loveit"],"title":"Loveit 内置 Shortcodes","uri":"/loveit_shortcodes/"},{"categories":["loveit"],"content":"LoveIt 主题在 Hugo 内置的 shortcode 的基础上提供多个扩展的 shortcode.","date":"2020-03-03","objectID":"/loveit_extend_shortcodes/","tags":["loveit"],"title":"Loveit 扩展 Shortcodes","uri":"/loveit_extend_shortcodes/"},{"categories":["loveit"],"content":"LoveIt 主题在 Hugo 内置的 shortcode 的基础上提供多个扩展的 shortcode. ","date":"2020-03-03","objectID":"/loveit_extend_shortcodes/:0:0","tags":["loveit"],"title":"Loveit 扩展 Shortcodes","uri":"/loveit_extend_shortcodes/"},{"categories":["loveit"],"content":"1 style 注意\r\rHugo extended 版本对于 style shortcode 是必需的.\r\r style shortcode 用来在你的文章中插入自定义样式. style shortcode 有两个位置参数. 第一个参数是自定义样式的内容. 它支持  SASS 中的嵌套语法, 并且 \u0026 指代这个父元素. 第二个参数是包裹你要更改样式的内容的 HTML 标签, 默认值是 div. 一个 style 示例: {{\u003c style \"text-align:right; strong{color:#00b1ff;}\" \u003e}} This is a **right-aligned** paragraph. {{\u003c /style \u003e}} 呈现的输出效果如下: This is a right-aligned paragraph. ","date":"2020-03-03","objectID":"/loveit_extend_shortcodes/:1:0","tags":["loveit"],"title":"Loveit 扩展 Shortcodes","uri":"/loveit_extend_shortcodes/"},{"categories":["loveit"],"content":"2 link link shortcode 是 Markdown 链接语法 的替代. link shortcode 可以提供一些其它的功能并且可以在代码块中使用. 支持本地资源引用的完整用法. link shortcode 有以下命名参数: href [必需] (第一个位置参数) 链接的目标. content [可选] (第二个位置参数) 链接的内容, 默认值是 href 参数的值. 支持 Markdown 或者 HTML 格式. title [可选] (第三个位置参数) HTML a 标签 的 title 属性, 当悬停在链接上会显示的提示. rel [可选] HTML a 标签 的 rel 补充属性. class [可选] HTML a 标签 的 class 属性. 一个 link 示例: {{\u003c link \"https://assemble.io\" \u003e}} 或者 {{\u003c link href=\"https://assemble.io\" \u003e}} {{\u003c link \"mailto:contact@revolunet.com\" \u003e}} 或者 {{\u003c link href=\"mailto:contact@revolunet.com\" \u003e}} {{\u003c link \"https://assemble.io\" Assemble \u003e}} 或者 {{\u003c link href=\"https://assemble.io\" content=Assemble \u003e}} 呈现的输出效果如下: https://assemble.io mailto:contact@revolunet.com Assemble 一个带有标题的 link 示例: {{\u003c link \"https://github.com/upstage/\" Upstage \"Visit Upstage!\" \u003e}} 或者 {{\u003c link href=\"https://github.com/upstage/\" content=Upstage title=\"Visit Upstage!\" \u003e}} 呈现的输出效果如下 (将鼠标悬停在链接上，会有一行提示): Upstage ","date":"2020-03-03","objectID":"/loveit_extend_shortcodes/:2:0","tags":["loveit"],"title":"Loveit 扩展 Shortcodes","uri":"/loveit_extend_shortcodes/"},{"categories":["loveit"],"content":"3 image image shortcode 是 figure shortcode 的替代. image shortcode 可以充分利用 lazysizes 和 lightgallery.js 两个依赖库. 支持本地资源引用的完整用法. image shortcode 有以下命名参数: src [必需] (第一个位置参数) 图片的 URL. alt [可选] (第二个位置参数) 图片无法显示时的替代文本, 默认值是 src 参数的值. 支持 Markdown 或者 HTML 格式. caption [可选] (第三个位置参数) 图片标题. 支持 Markdown 或者 HTML 格式. title [可选] 当悬停在图片上会显示的提示. class [可选] HTML figure 标签的 class 属性. src_s [可选] 图片缩略图的 URL, 用在画廊模式中, 默认值是 src 参数的值. src_l [可选] 高清图片的 URL, 用在画廊模式中, 默认值是 src 参数的值. height [可选] 图片的 height 属性. width [可选] 图片的 width 属性. linked [可选] 图片是否需要被链接, 默认值是 true. rel [可选] HTML a 标签 的 rel 补充属性, 仅在 linked 属性设置成 true 时有效. 一个 image 示例: {{\u003c image src=\"/images/hugo/lighthouse.jpg\" caption=\"Lighthouse (`image`)\" src_s=\"/images/hugo/lighthouse-small.jpg\" src_l=\"/images/hugo/lighthouse-large.jpg\" \u003e}} 呈现的输出效果如下: Lighthouse (image)\"\rLighthouse (image)\r ","date":"2020-03-03","objectID":"/loveit_extend_shortcodes/:3:0","tags":["loveit"],"title":"Loveit 扩展 Shortcodes","uri":"/loveit_extend_shortcodes/"},{"categories":["loveit"],"content":"4 admonition admonition shortcode 支持 12 种 帮助你在页面中插入提示的横幅. 支持 Markdown 或者 HTML 格式. 注意\r\r一个 注意 横幅\r\r 摘要\r\r一个 摘要 横幅\r\r 信息\r\r一个 信息 横幅\r\r 技巧\r\r一个 技巧 横幅\r\r 成功\r\r一个 成功 横幅\r\r 问题\r\r一个 问题 横幅\r\r 警告\r\r一个 警告 横幅\r\r 失败\r\r一个 失败 横幅\r\r 危险\r\r一个 危险 横幅\r\r Bug\r\r一个 Bug 横幅\r\r 示例\r\r一个 示例 横幅\r\r 引用\r\r一个 引用 横幅\r\r admonition shortcode 有以下命名参数: type [必需] (第一个位置参数) admonition 横幅的类型, 默认值是 note. title [可选] (第二个位置参数) admonition 横幅的标题, 默认值是 type 参数的值. open [可选] (第三个位置参数) 横幅内容是否默认展开, 默认值是 true. 一个 admonition 示例: {{\u003c admonition type=tip title=\"This is a tip\" open=false \u003e}} 一个 **技巧** 横幅 {{\u003c /admonition \u003e}} 或者 {{\u003c admonition tip \"This is a tip\" false \u003e}} 一个 **技巧** 横幅 {{\u003c /admonition \u003e}} 呈现的输出效果如下: This is a tip\r\r一个 技巧 横幅\r\r ","date":"2020-03-03","objectID":"/loveit_extend_shortcodes/:4:0","tags":["loveit"],"title":"Loveit 扩展 Shortcodes","uri":"/loveit_extend_shortcodes/"},{"categories":["loveit"],"content":"5 mermaid mermaid 是一个可以帮助你在文章中生成图表和流程图的库, 类似 Markdown 的语法. 只需将你的 mermaid 代码插入 mermaid shortcode 中即可. ","date":"2020-03-03","objectID":"/loveit_extend_shortcodes/:5:0","tags":["loveit"],"title":"Loveit 扩展 Shortcodes","uri":"/loveit_extend_shortcodes/"},{"categories":["loveit"],"content":"5.1 流程图 一个 流程图 mermaid 示例: {{\u003c mermaid \u003e}} graph LR; A[Hard edge] --\u003e|Link text| B(Round edge) B --\u003e C{Decision} C --\u003e|One| D[Result one] C --\u003e|Two| E[Result two] {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/loveit_extend_shortcodes/:5:1","tags":["loveit"],"title":"Loveit 扩展 Shortcodes","uri":"/loveit_extend_shortcodes/"},{"categories":["loveit"],"content":"5.2 时序图 一个 时序图 mermaid 示例: {{\u003c mermaid \u003e}} sequenceDiagram participant Alice participant Bob Alice-\u003e\u003eJohn: Hello John, how are you? loop Healthcheck John-\u003eJohn: Fight against hypochondria end Note right of John: Rational thoughts \u003cbr/\u003eprevail... John--\u003eAlice: Great! John-\u003eBob: How about you? Bob--\u003eJohn: Jolly good! {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/loveit_extend_shortcodes/:5:2","tags":["loveit"],"title":"Loveit 扩展 Shortcodes","uri":"/loveit_extend_shortcodes/"},{"categories":["loveit"],"content":"5.3 甘特图 一个 甘特图 mermaid 示例: {{\u003c mermaid \u003e}} gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/loveit_extend_shortcodes/:5:3","tags":["loveit"],"title":"Loveit 扩展 Shortcodes","uri":"/loveit_extend_shortcodes/"},{"categories":["loveit"],"content":"5.4 类图 一个 类图 mermaid 示例: {{\u003c mermaid \u003e}} classDiagram Class01 \u003c|-- AveryLongClass : Cool Class03 *-- Class04 Class05 o-- Class06 Class07 .. Class08 Class09 --\u003e C2 : Where am i? Class09 --* C3 Class09 --|\u003e Class07 Class07 : equals() Class07 : Object[] elementData Class01 : size() Class01 : int chimp Class01 : int gorilla Class08 \u003c--\u003e C2: Cool label {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/loveit_extend_shortcodes/:5:4","tags":["loveit"],"title":"Loveit 扩展 Shortcodes","uri":"/loveit_extend_shortcodes/"},{"categories":["loveit"],"content":"5.5 状态图 一个 状态图 mermaid 示例: {{\u003c mermaid \u003e}} stateDiagram [*] --\u003e Still Still --\u003e [*] Still --\u003e Moving Moving --\u003e Still Moving --\u003e Crash Crash --\u003e [*] {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/loveit_extend_shortcodes/:5:5","tags":["loveit"],"title":"Loveit 扩展 Shortcodes","uri":"/loveit_extend_shortcodes/"},{"categories":["loveit"],"content":"5.6 Git 图 一个 Git 图 mermaid 示例: {{\u003c mermaid \u003e}} gitGraph: options { \"nodeSpacing\": 100, \"nodeRadius\": 10 } end commit branch newbranch checkout newbranch commit commit checkout master commit commit merge newbranch {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/loveit_extend_shortcodes/:5:6","tags":["loveit"],"title":"Loveit 扩展 Shortcodes","uri":"/loveit_extend_shortcodes/"},{"categories":["loveit"],"content":"5.7 饼图 一个 饼图 mermaid 示例: {{\u003c mermaid \u003e}} pie \"Dogs\" : 386 \"Cats\" : 85 \"Rats\" : 15 {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/loveit_extend_shortcodes/:5:7","tags":["loveit"],"title":"Loveit 扩展 Shortcodes","uri":"/loveit_extend_shortcodes/"},{"categories":["loveit"],"content":"6 echarts ECharts 是一个帮助你生成交互式数据可视化的库. ECharts 提供了常规的 折线图, 柱状图, 散点图, 饼图, K线图, 用于统计的 盒形图, 用于地理数据可视化的 地图, 热力图, 线图, 用于关系数据可视化的 关系图, treemap, 旭日图, 多维数据可视化的 平行坐标, 还有用于 BI 的 漏斗图, 仪表盘, 并且支持图与图之间的混搭. 只需在 echarts shortcode 中以 JSON/YAML/TOML格式插入 ECharts 选项即可. 一个 JSON 格式的 echarts 示例: {{\u003c echarts \u003e}} { \"title\": { \"text\": \"折线统计图\", \"top\": \"2%\", \"left\": \"center\" }, \"tooltip\": { \"trigger\": \"axis\" }, \"legend\": { \"data\": [\"邮件营销\", \"联盟广告\", \"视频广告\", \"直接访问\", \"搜索引擎\"], \"top\": \"10%\" }, \"grid\": { \"left\": \"5%\", \"right\": \"5%\", \"bottom\": \"5%\", \"top\": \"20%\", \"containLabel\": true }, \"toolbox\": { \"feature\": { \"saveAsImage\": { \"title\": \"保存为图片\" } } }, \"xAxis\": { \"type\": \"category\", \"boundaryGap\": false, \"data\": [\"周一\", \"周二\", \"周三\", \"周四\", \"周五\", \"周六\", \"周日\"] }, \"yAxis\": { \"type\": \"value\" }, \"series\": [ { \"name\": \"邮件营销\", \"type\": \"line\", \"stack\": \"总量\", \"data\": [120, 132, 101, 134, 90, 230, 210] }, { \"name\": \"联盟广告\", \"type\": \"line\", \"stack\": \"总量\", \"data\": [220, 182, 191, 234, 290, 330, 310] }, { \"name\": \"视频广告\", \"type\": \"line\", \"stack\": \"总量\", \"data\": [150, 232, 201, 154, 190, 330, 410] }, { \"name\": \"直接访问\", \"type\": \"line\", \"stack\": \"总量\", \"data\": [320, 332, 301, 334, 390, 330, 320] }, { \"name\": \"搜索引擎\", \"type\": \"line\", \"stack\": \"总量\", \"data\": [820, 932, 901, 934, 1290, 1330, 1320] } ] } {{\u003c /echarts \u003e}} 一个 YAML 格式的 echarts 示例: {{\u003c echarts \u003e}}title:text:折线统计图top:2%left:centertooltip:trigger:axislegend:data:- 邮件营销- 联盟广告- 视频广告- 直接访问- 搜索引擎top:10%grid:left:5%right:5%bottom:5%top:20%containLabel:truetoolbox:feature:saveAsImage:title:保存为图片xAxis:type:categoryboundaryGap:falsedata:- 周一- 周二- 周三- 周四- 周五- 周六- 周日yAxis:type:valueseries:- name:邮件营销type:linestack:总量data:- 120- 132- 101- 134- 90- 230- 210- name:联盟广告type:linestack:总量data:- 220- 182- 191- 234- 290- 330- 310- name:视频广告type:linestack:总量data:- 150- 232- 201- 154- 190- 330- 410- name:直接访问type:linestack:总量data:- 320- 332- 301- 334- 390- 330- 320- name:搜索引擎type:linestack:总量data:- 820- 932- 901- 934- 1290- 1330- 1320{{\u003c /echarts \u003e}} 一个 TOML 格式的 echarts 示例: {{\u003c echarts \u003e}} [title] text = \"折线统计图\" top = \"2%\" left = \"center\" [tooltip] trigger = \"axis\" [legend] data = [ \"邮件营销\", \"联盟广告\", \"视频广告\", \"直接访问\", \"搜索引擎\" ] top = \"10%\" [grid] left = \"5%\" right = \"5%\" bottom = \"5%\" top = \"20%\" containLabel = true [toolbox] [toolbox.feature] [toolbox.feature.saveAsImage] title = \"保存为图片\" [xAxis] type = \"category\" boundaryGap = false data = [ \"周一\", \"周二\", \"周三\", \"周四\", \"周五\", \"周六\", \"周日\" ] [yAxis] type = \"value\" [[series]] name = \"邮件营销\" type = \"line\" stack = \"总量\" data = [ 120.0, 132.0, 101.0, 134.0, 90.0, 230.0, 210.0 ] [[series]] name = \"联盟广告\" type = \"line\" stack = \"总量\" data = [ 220.0, 182.0, 191.0, 234.0, 290.0, 330.0, 310.0 ] [[series]] name = \"视频广告\" type = \"line\" stack = \"总量\" data = [ 150.0, 232.0, 201.0, 154.0, 190.0, 330.0, 410.0 ] [[series]] name = \"直接访问\" type = \"line\" stack = \"总量\" data = [ 320.0, 332.0, 301.0, 334.0, 390.0, 330.0, 320.0 ] [[series]] name = \"搜索引擎\" type = \"line\" stack = \"总量\" data = [ 820.0, 932.0, 901.0, 934.0, 1290.0, 1330.0, 1320.0 ] {{\u003c /echarts \u003e}} 呈现的输出效果如下: echarts shortcode 还有以下命名参数: width [可选] (第一个位置参数) 数据可视化的宽度, 默认值是 100%. height [可选] (第二个位置参数) 数据可视化的高度, 默认值是 30rem. ","date":"2020-03-03","objectID":"/loveit_extend_shortcodes/:6:0","tags":["loveit"],"title":"Loveit 扩展 Shortcodes","uri":"/loveit_extend_shortcodes/"},{"categories":["loveit"],"content":"7 mapbox Mapbox GL JS 是一个 JavaScript 库，它使用 WebGL, 以 vector tiles 和 Mapbox styles 为来源, 将它们渲染成互动式地图. mapbox shortcode 有以下命名参数来使用 Mapbox GL JS: lng [必需] (第一个位置参数) 地图初始中心点的经度, 以度为单位. lat [必需] (第二个位置参数) 地图初始中心点的纬度, 以度为单位. zoom [可选] (第三个位置参数) 地图的初始缩放级别, 默认值是 10. marked [可选] (第四个位置参数) 是否在地图的初始中心点添加图钉, 默认值是 true. light-style [可选] (第五个位置参数) 浅色主题的地图样式, 默认值是前置参数或者网站配置中设置的值. dark-style [可选] (第六个位置参数) 深色主题的地图样式, 默认值是前置参数或者网站配置中设置的值. navigation [可选] 是否添加 NavigationControl, 默认值是前置参数或者网站配置中设置的值. geolocate [可选] 是否添加 GeolocateControl, 默认值是前置参数或者网站配置中设置的值. scale [可选] 是否添加 ScaleControl, 默认值是前置参数或者网站配置中设置的值. fullscreen [可选] 是否添加 FullscreenControl, 默认值是前置参数或者网站配置中设置的值. width [可选] 地图的宽度, 默认值是 100%. height [可选] 地图的高度, 默认值是 20rem. 一个简单的 mapbox 示例: {{\u003c mapbox 121.485 31.233 12 \u003e}} 或者 {{\u003c mapbox lng=121.485 lat=31.233 zoom=12 \u003e}} 呈现的输出效果如下: 一个带有自定义样式的 mapbox 示例: {{\u003c mapbox -122.252 37.453 10 false \"mapbox://styles/mapbox/streets-zh-v1\" \u003e}} 或者 {{\u003c mapbox lng=-122.252 lat=37.453 zoom=10 marked=false light-style=\"mapbox://styles/mapbox/streets-zh-v1\" \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/loveit_extend_shortcodes/:7:0","tags":["loveit"],"title":"Loveit 扩展 Shortcodes","uri":"/loveit_extend_shortcodes/"},{"categories":["loveit"],"content":"8 music music shortcode 基于 APlayer 和 MetingJS 提供了一个内嵌的响应式音乐播放器. 有三种方式使用 music shortcode. ","date":"2020-03-03","objectID":"/loveit_extend_shortcodes/:8:0","tags":["loveit"],"title":"Loveit 扩展 Shortcodes","uri":"/loveit_extend_shortcodes/"},{"categories":["loveit"],"content":"8.1 自定义音乐 URL 支持本地资源引用的完整用法. music shortcode 有以下命名参数来使用自定义音乐 URL: server [必需] 音乐的链接. type [可选] 音乐的名称. artist [可选] 音乐的创作者. cover [可选] 音乐的封面链接. 一个使用自定义音乐 URL 的 music 示例: {{\u003c music url=\"/music/Wavelength.mp3\" name=Wavelength artist=oldmanyoung cover=\"/images/hugo/Wavelength.jpg\" \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/loveit_extend_shortcodes/:8:1","tags":["loveit"],"title":"Loveit 扩展 Shortcodes","uri":"/loveit_extend_shortcodes/"},{"categories":["loveit"],"content":"8.2 音乐平台 URL 的自动识别 music shortcode 有一个命名参数来使用音乐平台 URL 的自动识别: auto [必需]] (第一个位置参数) 用来自动识别的音乐平台 URL, 支持 netease, tencent 和 xiami 平台. 一个使用音乐平台 URL 的自动识别的 music 示例: {{\u003c music auto=\"https://music.163.com/#/playlist?id=60198\" \u003e}} 或者 {{\u003c music \"https://music.163.com/#/playlist?id=60198\" \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/loveit_extend_shortcodes/:8:2","tags":["loveit"],"title":"Loveit 扩展 Shortcodes","uri":"/loveit_extend_shortcodes/"},{"categories":["loveit"],"content":"8.3 自定义音乐平台, 类型和 ID music shortcode 有以下命名参数来使用自定义音乐平台: server [必需] (第一个位置参数) [netease, tencent, kugou, xiami, baidu] 音乐平台. type [必需] (第二个位置参数) [song, playlist, album, search, artist] 音乐类型. id [必需] (第三个位置参数) 歌曲 ID, 或者播放列表 ID, 或者专辑 ID, 或者搜索关键词, 或者创作者 ID. 一个使用自定义音乐平台的 music 示例: {{\u003c music server=\"netease\" type=\"song\" id=\"1868553\" \u003e}} 或者 {{\u003c music netease song 1868553 \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/loveit_extend_shortcodes/:8:3","tags":["loveit"],"title":"Loveit 扩展 Shortcodes","uri":"/loveit_extend_shortcodes/"},{"categories":["loveit"],"content":"8.4 其它参数 music shortcode 有一些可以应用于以上三种方式的其它命名参数: theme [可选] 音乐播放器的主题色, 默认值是 #448aff. fixed [可选] 是否开启固定模式, 默认值是 false. mini [可选] 是否开启迷你模式, 默认值是 false. autoplay [可选] 是否自动播放音乐, 默认值是 false. volume [可选] 第一次打开播放器时的默认音量, 会被保存在浏览器缓存中, 默认值是 0.7. mutex [可选] 是否自动暂停其它播放器, 默认值是 true. music shortcode 还有一些只适用于音乐列表方式的其它命名参数: loop [可选] [all, one, none] 音乐列表的循环模式, 默认值是 none. order [可选] [list, random] 音乐列表的播放顺序, 默认值是 list. list-folded [可选] 初次打开的时候音乐列表是否折叠, 默认值是 false. list-max-height [可选] 音乐列表的最大高度, 默认值是 340px. ","date":"2020-03-03","objectID":"/loveit_extend_shortcodes/:8:4","tags":["loveit"],"title":"Loveit 扩展 Shortcodes","uri":"/loveit_extend_shortcodes/"},{"categories":["loveit"],"content":"9 bilibili bilibili shortcode 提供了一个内嵌的用来播放 bilibili 视频的响应式播放器. 如果视频只有一个部分, 则仅需要视频的 BV id, 例如: https://www.bilibili.com/video/BV1Sx411T7QQ 一个 bilibili 示例: {{\u003c bilibili BV1Sx411T7QQ \u003e}} 或者 {{\u003c bilibili id=BV1Sx411T7QQ \u003e}} 呈现的输出效果如下: \r如果视频包含多个部分, 则除了视频的 BV id 之外, 还需要 p, 默认值为 1, 例如: https://www.bilibili.com/video/BV1TJ411C7An?p=3 一个带有 p 参数的 bilibili 示例: {{\u003c bilibili BV1TJ411C7An 3 \u003e}} 或者 {{\u003c bilibili id=BV1TJ411C7An p=3 \u003e}} 呈现的输出效果如下: \r","date":"2020-03-03","objectID":"/loveit_extend_shortcodes/:9:0","tags":["loveit"],"title":"Loveit 扩展 Shortcodes","uri":"/loveit_extend_shortcodes/"},{"categories":["loveit"],"content":"10 typeit typeit shortcode 基于 TypeIt 提供了打字动画. 只需将你需要打字动画的内容插入 typeit shortcode 中即可. ","date":"2020-03-03","objectID":"/loveit_extend_shortcodes/:10:0","tags":["loveit"],"title":"Loveit 扩展 Shortcodes","uri":"/loveit_extend_shortcodes/"},{"categories":["loveit"],"content":"10.1 简单内容 允许使用 Markdown 格式的简单内容, 并且 不包含 富文本的块内容, 例如图像等等… 一个 typeit 示例: {{\u003c typeit \u003e}} 这一个带有基于 [TypeIt](https://typeitjs.com/) 的 **打字动画** 的 *段落*... {{\u003c /typeit \u003e}} 呈现的输出效果如下: \r另外, 你也可以自定义 HTML 标签. 一个带有 h4 标签的 typeit 示例: {{\u003c typeit tag=h4 \u003e}} 这一个带有基于 [TypeIt](https://typeitjs.com/) 的 **打字动画** 的 *段落*... {{\u003c /typeit \u003e}} 呈现的输出效果如下: \r","date":"2020-03-03","objectID":"/loveit_extend_shortcodes/:10:1","tags":["loveit"],"title":"Loveit 扩展 Shortcodes","uri":"/loveit_extend_shortcodes/"},{"categories":["loveit"],"content":"10.2 代码内容 代码内容也是允许的, 并且通过使用参数 code 指定语言类型可以实习语法高亮. 一个带有 code 参数的 typeit 示例: {{\u003c typeit code=java \u003e}} public class HelloWorld { public static void main(String []args) { System.out.println(\"Hello World\"); } } {{\u003c /typeit \u003e}} 呈现的输出效果如下: \r","date":"2020-03-03","objectID":"/loveit_extend_shortcodes/:10:2","tags":["loveit"],"title":"Loveit 扩展 Shortcodes","uri":"/loveit_extend_shortcodes/"},{"categories":["loveit"],"content":"10.3 分组内容 默认情况下, 所有打字动画都是同时开始的. 但是有时你可能需要按顺序开始一组 typeit 内容的打字动画. 一组具有相同 group 参数值的 typeit 内容将按顺序开始打字动画. 一个带有 group 参数的 typeit 示例: {{\u003c typeit group=paragraph \u003e}} **首先**, 这个段落开始 {{\u003c /typeit \u003e}} {{\u003c typeit group=paragraph \u003e}} **然后**, 这个段落开始 {{\u003c /typeit \u003e}} 呈现的输出效果如下: \r\r","date":"2020-03-03","objectID":"/loveit_extend_shortcodes/:10:3","tags":["loveit"],"title":"Loveit 扩展 Shortcodes","uri":"/loveit_extend_shortcodes/"},{"categories":["loveit"],"content":"11 script script shortcode 用来在你的文章中插入  Javascript 脚本. 注意\r\r脚本内容可以保证在所有的第三方库加载之后按顺序执行. 所以你可以自由地使用第三方库.\r\r 一个 script 示例: {{\u003c script \u003e}} console.log('Hello LoveIt!'); {{\u003c /script \u003e}} 你可以在开发者工具的控制台中看到输出. ","date":"2020-03-03","objectID":"/loveit_extend_shortcodes/:11:0","tags":["loveit"],"title":"Loveit 扩展 Shortcodes","uri":"/loveit_extend_shortcodes/"},{"categories":["loveit"],"content":"这篇文章展示了基本的 Markdown 语法和格式.","date":"2019-12-01","objectID":"/markdown/","tags":["loveit"],"title":"Markdown 基本语法","uri":"/markdown/"},{"categories":["loveit"],"content":"这篇文章提供了可以在 Hugo 的文章中使用的基本 Markdown 语法示例. 注意\r\r这篇文章借鉴了一篇很棒的来自 Grav 的文章. 如果你想了解 Loveit 主题的扩展 Markdown 语法, 请阅读扩展 Markdown 语法页面. \r\r 事实上, 编写 Web 内容很麻烦. WYSIWYG所见即所得 编辑器帮助减轻了这一任务. 但通常会导致代码太糟, 或更糟糕的是, 网页也会很丑. 没有通常伴随的所有复杂和丑陋的问题, Markdown 是一种更好的生成 HTML 内容的方式. 一些主要好处是: Markdown 简单易学, 几乎没有多余的字符, 因此编写内容也更快. 用 Markdown 书写时出错的机会更少. 可以产生有效的 XHTML 输出. 将内容和视觉显示保持分开, 这样就不会打乱网站的外观. 可以在你喜欢的任何文本编辑器或 Markdown 应用程序中编写内容. Markdown 使用起来很有趣! John Gruber, Markdown 的作者如是说: Markdown 格式的首要设计目标是更具可读性. 最初的想法是 Markdown 格式的文档应当以纯文本形式发布, 而不会看起来像被标签或格式说明所标记. 虽然 Markdown 的语法受到几种现有的文本到 HTML 转换工具的影响, 但 Markdown 语法的最大灵感来源是纯文本电子邮件的格式. – John Gruber 话不多说, 我们来回顾一下 Markdown 的主要语法以及生成的 HTML 样式! 技巧\r\r 将此页保存为书签，以备将来参考!\r\r ","date":"2019-12-01","objectID":"/markdown/:0:0","tags":["loveit"],"title":"Markdown 基本语法","uri":"/markdown/"},{"categories":["loveit"],"content":"1 标题 从 h2 到 h6 的标题在每个级别上都加上一个 ＃: ## h2 标题 ### h3 标题 #### h4 标题 ##### h5 标题 ###### h6 标题 输出的 HTML 看起来像这样: \u003ch2\u003eh2 标题\u003c/h2\u003e \u003ch3\u003eh3 标题\u003c/h3\u003e \u003ch4\u003eh4 标题\u003c/h4\u003e \u003ch5\u003eh5 标题\u003c/h5\u003e \u003ch6\u003eh6 标题\u003c/h6\u003e 标题 ID\r\r要添加自定义标题 ID, 请在与标题相同的行中将自定义 ID 放在花括号中: ### 一个很棒的标题 {#custom-id} 输出的 HTML 看起来像这样: \u003ch3 id=\"custom-id\"\u003e一个很棒的标题\u003c/h3\u003e \r\r ","date":"2019-12-01","objectID":"/markdown/:1:0","tags":["loveit"],"title":"Markdown 基本语法","uri":"/markdown/"},{"categories":["loveit"],"content":"2 注释 注释是和 HTML 兼容的： \u003c!-- 这是一段注释 --\u003e 不能看到以下的注释: ","date":"2019-12-01","objectID":"/markdown/:2:0","tags":["loveit"],"title":"Markdown 基本语法","uri":"/markdown/"},{"categories":["loveit"],"content":"3 水平线 HTML 中的 \u003chr\u003e 标签是用来在段落元素之间创建一个 “专题间隔” 的. 使用 Markdown, 你可以用以下方式创建一个 \u003chr\u003e 标签: ___: 三个连续的下划线 ---: 三个连续的破折号 ***: 三个连续的星号 呈现的输出效果如下: ","date":"2019-12-01","objectID":"/markdown/:3:0","tags":["loveit"],"title":"Markdown 基本语法","uri":"/markdown/"},{"categories":["loveit"],"content":"4 段落 按照纯文本的方式书写段落, 纯文本在呈现的 HTML 中将用 \u003cp\u003e/\u003c/p\u003e 标签包裹. 如下段落: Lorem ipsum dolor sit amet, graecis denique ei vel, at duo primis mandamus. Et legere ocurreret pri, animal tacimates complectitur ad cum. Cu eum inermis inimicus efficiendi. Labore officiis his ex, soluta officiis concludaturque ei qui, vide sensibus vim ad. 输出的 HTML 看起来像这样: \u003cp\u003eLorem ipsum dolor sit amet, graecis denique ei vel, at duo primis mandamus. Et legere ocurreret pri, animal tacimates complectitur ad cum. Cu eum inermis inimicus efficiendi. Labore officiis his ex, soluta officiis concludaturque ei qui, vide sensibus vim ad.\u003c/p\u003e 可以使用一个空白行进行换行. ","date":"2019-12-01","objectID":"/markdown/:4:0","tags":["loveit"],"title":"Markdown 基本语法","uri":"/markdown/"},{"categories":["loveit"],"content":"5 内联 HTML 元素 如果你需要某个 HTML 标签 (带有一个类), 则可以简单地像这样使用: Markdown 格式的段落. \u003cdiv class=\"class\"\u003e 这是 \u003cb\u003eHTML\u003c/b\u003e \u003c/div\u003e Markdown 格式的段落. ","date":"2019-12-01","objectID":"/markdown/:5:0","tags":["loveit"],"title":"Markdown 基本语法","uri":"/markdown/"},{"categories":["loveit"],"content":"6 强调 ","date":"2019-12-01","objectID":"/markdown/:6:0","tags":["loveit"],"title":"Markdown 基本语法","uri":"/markdown/"},{"categories":["loveit"],"content":"加粗 用于强调带有较粗字体的文本片段. 以下文本片段会被 渲染为粗体. **渲染为粗体** __渲染为粗体__ 输出的 HTML 看起来像这样: \u003cstrong\u003e渲染为粗体\u003c/strong\u003e ","date":"2019-12-01","objectID":"/markdown/:6:1","tags":["loveit"],"title":"Markdown 基本语法","uri":"/markdown/"},{"categories":["loveit"],"content":"斜体 用于强调带有斜体的文本片段. 以下文本片段被 渲染为斜体. *渲染为斜体* _渲染为斜体_ 输出的 HTML 看起来像这样: \u003cem\u003e渲染为斜体\u003c/em\u003e ","date":"2019-12-01","objectID":"/markdown/:6:2","tags":["loveit"],"title":"Markdown 基本语法","uri":"/markdown/"},{"categories":["loveit"],"content":"删除线 按照 GFMGitHub flavored Markdown 你可以使用删除线. ~~这段文本带有删除线.~~ 呈现的输出效果如下: 这段文本带有删除线. 输出的 HTML 看起来像这样: \u003cdel\u003e这段文本带有删除线.\u003c/del\u003e ","date":"2019-12-01","objectID":"/markdown/:6:3","tags":["loveit"],"title":"Markdown 基本语法","uri":"/markdown/"},{"categories":["loveit"],"content":"组合 加粗, 斜体, 和删除线可以 组合使用. ***加粗和斜体*** ~~**删除线和加粗**~~ ~~*删除线和斜体*~~ ~~***加粗, 斜体和删除线***~~ 呈现的输出效果如下: 加粗和斜体 删除线和加粗 删除线和斜体 加粗, 斜体和删除线 输出的 HTML 看起来像这样: \u003cem\u003e\u003cstrong\u003e加粗和斜体\u003c/strong\u003e\u003c/em\u003e \u003cdel\u003e\u003cstrong\u003e删除线和加粗\u003c/strong\u003e\u003c/del\u003e \u003cdel\u003e\u003cem\u003e删除线和斜体\u003c/em\u003e\u003c/del\u003e \u003cdel\u003e\u003cem\u003e\u003cstrong\u003e加粗, 斜体和删除线\u003c/strong\u003e\u003c/em\u003e\u003c/del\u003e ","date":"2019-12-01","objectID":"/markdown/:6:4","tags":["loveit"],"title":"Markdown 基本语法","uri":"/markdown/"},{"categories":["loveit"],"content":"7 引用 用于在文档中引用其他来源的内容块. 在要引用的任何文本之前添加 \u003e: \u003e **Fusion Drive** combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. 呈现的输出效果如下: Fusion Drive combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. 输出的 HTML 看起来像这样: \u003cblockquote\u003e \u003cp\u003e \u003cstrong\u003eFusion Drive\u003c/strong\u003e combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. \u003c/p\u003e \u003c/blockquote\u003e 引用也可以嵌套: \u003e Donec massa lacus, ultricies a ullamcorper in, fermentum sed augue. Nunc augue augue, aliquam non hendrerit ac, commodo vel nisi. \u003e\u003e Sed adipiscing elit vitae augue consectetur a gravida nunc vehicula. Donec auctor odio non est accumsan facilisis. Aliquam id turpis in dolor tincidunt mollis ac eu diam. 呈现的输出效果如下: Donec massa lacus, ultricies a ullamcorper in, fermentum sed augue. Nunc augue augue, aliquam non hendrerit ac, commodo vel nisi. Sed adipiscing elit vitae augue consectetur a gravida nunc vehicula. Donec auctor odio non est accumsan facilisis. Aliquam id turpis in dolor tincidunt mollis ac eu diam. ","date":"2019-12-01","objectID":"/markdown/:7:0","tags":["loveit"],"title":"Markdown 基本语法","uri":"/markdown/"},{"categories":["loveit"],"content":"8 列表 ","date":"2019-12-01","objectID":"/markdown/:8:0","tags":["loveit"],"title":"Markdown 基本语法","uri":"/markdown/"},{"categories":["loveit"],"content":"无序列表 一系列项的列表, 其中项的顺序没有明显关系. 你可以使用以下任何符号来表示无序列表中的项: * 一项内容 - 一项内容 + 一项内容 例如: * Lorem ipsum dolor sit amet * Consectetur adipiscing elit * Integer molestie lorem at massa * Facilisis in pretium nisl aliquet * Nulla volutpat aliquam velit * Phasellus iaculis neque * Purus sodales ultricies * Vestibulum laoreet porttitor sem * Ac tristique libero volutpat at * Faucibus porta lacus fringilla vel * Aenean sit amet erat nunc * Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Phasellus iaculis neque Purus sodales ultricies Vestibulum laoreet porttitor sem Ac tristique libero volutpat at Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem 输出的 HTML 看起来像这样: \u003cul\u003e \u003cli\u003eLorem ipsum dolor sit amet\u003c/li\u003e \u003cli\u003eConsectetur adipiscing elit\u003c/li\u003e \u003cli\u003eInteger molestie lorem at massa\u003c/li\u003e \u003cli\u003eFacilisis in pretium nisl aliquet\u003c/li\u003e \u003cli\u003eNulla volutpat aliquam velit \u003cul\u003e \u003cli\u003ePhasellus iaculis neque\u003c/li\u003e \u003cli\u003ePurus sodales ultricies\u003c/li\u003e \u003cli\u003eVestibulum laoreet porttitor sem\u003c/li\u003e \u003cli\u003eAc tristique libero volutpat at\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003eFaucibus porta lacus fringilla vel\u003c/li\u003e \u003cli\u003eAenean sit amet erat nunc\u003c/li\u003e \u003cli\u003eEget porttitor lorem\u003c/li\u003e \u003c/ul\u003e ","date":"2019-12-01","objectID":"/markdown/:8:1","tags":["loveit"],"title":"Markdown 基本语法","uri":"/markdown/"},{"categories":["loveit"],"content":"有序列表 一系列项的列表, 其中项的顺序确实很重要. 1. Lorem ipsum dolor sit amet 2. Consectetur adipiscing elit 3. Integer molestie lorem at massa 4. Facilisis in pretium nisl aliquet 5. Nulla volutpat aliquam velit 6. Faucibus porta lacus fringilla vel 7. Aenean sit amet erat nunc 8. Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem 输出的 HTML 看起来像这样: \u003col\u003e \u003cli\u003eLorem ipsum dolor sit amet\u003c/li\u003e \u003cli\u003eConsectetur adipiscing elit\u003c/li\u003e \u003cli\u003eInteger molestie lorem at massa\u003c/li\u003e \u003cli\u003eFacilisis in pretium nisl aliquet\u003c/li\u003e \u003cli\u003eNulla volutpat aliquam velit\u003c/li\u003e \u003cli\u003eFaucibus porta lacus fringilla vel\u003c/li\u003e \u003cli\u003eAenean sit amet erat nunc\u003c/li\u003e \u003cli\u003eEget porttitor lorem\u003c/li\u003e \u003c/ol\u003e 技巧\r\r如果你对每一项使用 1., Markdown 将自动为每一项编号. 例如: 1. Lorem ipsum dolor sit amet 1. Consectetur adipiscing elit 1. Integer molestie lorem at massa 1. Facilisis in pretium nisl aliquet 1. Nulla volutpat aliquam velit 1. Faucibus porta lacus fringilla vel 1. Aenean sit amet erat nunc 1. Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem \r\r ","date":"2019-12-01","objectID":"/markdown/:8:2","tags":["loveit"],"title":"Markdown 基本语法","uri":"/markdown/"},{"categories":["loveit"],"content":"任务列表 任务列表使你可以创建带有复选框的列表. 要创建任务列表, 请在任务列表项之前添加破折号 (-) 和带有空格的方括号 ([ ]). 要选择一个复选框，请在方括号之间添加 x ([x]). - [x] Write the press release - [ ] Update the website - [ ] Contact the media 呈现的输出效果如下: Write the press release Update the website Contact the media ","date":"2019-12-01","objectID":"/markdown/:8:3","tags":["loveit"],"title":"Markdown 基本语法","uri":"/markdown/"},{"categories":["loveit"],"content":"9 代码 ","date":"2019-12-01","objectID":"/markdown/:9:0","tags":["loveit"],"title":"Markdown 基本语法","uri":"/markdown/"},{"categories":["loveit"],"content":"行内代码 用 ` 包装行内代码段. 在这个例子中, `\u003csection\u003e\u003c/section\u003e` 会被包裹成 **代码**. 呈现的输出效果如下: 在这个例子中, \u003csection\u003e\u003c/section\u003e 会被包裹成 代码. 输出的 HTML 看起来像这样: \u003cp\u003e 在这个例子中, \u003ccode\u003e\u0026lt;section\u0026gt;\u0026lt;/section\u0026gt;\u003c/code\u003e 会被包裹成 \u003cstrong\u003e代码\u003c/strong\u003e. \u003c/p\u003e ","date":"2019-12-01","objectID":"/markdown/:9:1","tags":["loveit"],"title":"Markdown 基本语法","uri":"/markdown/"},{"categories":["loveit"],"content":"缩进代码 将几行代码缩进至少四个空格，例如: // Some comments line 1 of code line 2 of code line 3 of code 呈现的输出效果如下: // Some comments\rline 1 of code\rline 2 of code\rline 3 of code\r 输出的 HTML 看起来像这样: \u003cpre\u003e \u003ccode\u003e // Some comments line 1 of code line 2 of code line 3 of code \u003c/code\u003e \u003c/pre\u003e ","date":"2019-12-01","objectID":"/markdown/:9:2","tags":["loveit"],"title":"Markdown 基本语法","uri":"/markdown/"},{"categories":["loveit"],"content":"围栏代码块 使用 “围栏” ``` 来生成一段带有语言属性的代码块. ```markdown Sample text here... ``` 输出的 HTML 看起来像这样: \u003cpre language-html\u003e \u003ccode\u003eSample text here...\u003c/code\u003e \u003c/pre\u003e ","date":"2019-12-01","objectID":"/markdown/:9:3","tags":["loveit"],"title":"Markdown 基本语法","uri":"/markdown/"},{"categories":["loveit"],"content":"语法高亮 GFMGitHub Flavored Markdown 也支持语法高亮. 要激活它，只需在第一个代码 “围栏” 之后直接添加你要使用的语言的文件扩展名, ```js, 语法高亮显示将自动应用于渲染的 HTML 中. 例如, 在以下 JavaScript 代码中应用语法高亮: ```js grunt.initConfig({ assemble: { options: { assets: 'docs/assets', data: 'src/data/*.{json,yml}', helpers: 'src/custom-helpers.js', partials: ['src/partials/**/*.{hbs,md}'] }, pages: { options: { layout: 'default.hbs' }, files: { './': ['src/templates/pages/index.hbs'] } } } }; ``` 呈现的输出效果如下: grunt.initConfig({ assemble: { options: { assets: 'docs/assets', data: 'src/data/*.{json,yml}', helpers: 'src/custom-helpers.js', partials: ['src/partials/**/*.{hbs,md}'] }, pages: { options: { layout: 'default.hbs' }, files: { './': ['src/templates/pages/index.hbs'] } } } }; 注意\r\rHugo 文档中的 语法高亮页面 介绍了有关语法高亮的更多信息, 包括语法高亮的 shortcode.\r\r ","date":"2019-12-01","objectID":"/markdown/:9:4","tags":["loveit"],"title":"Markdown 基本语法","uri":"/markdown/"},{"categories":["loveit"],"content":"10 表格 通过在每个单元格之间添加竖线作为分隔线, 并在标题下添加一行破折号 (也由竖线分隔) 来创建表格. 注意, 竖线不需要垂直对齐. | Option | Description | | ------ | ----------- | | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | 呈现的输出效果如下: Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. 输出的 HTML 看起来像这样: \u003ctable\u003e \u003cthead\u003e \u003ctr\u003e \u003cth\u003eOption\u003c/th\u003e \u003cth\u003eDescription\u003c/th\u003e \u003c/tr\u003e \u003c/thead\u003e \u003ctbody\u003e \u003ctr\u003e \u003ctd\u003edata\u003c/td\u003e \u003ctd\u003epath to data files to supply the data that will be passed into templates.\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eengine\u003c/td\u003e \u003ctd\u003eengine to be used for processing templates. Handlebars is the default.\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eext\u003c/td\u003e \u003ctd\u003eextension to be used for dest files.\u003c/td\u003e \u003c/tr\u003e \u003c/tbody\u003e \u003c/table\u003e 文本右对齐或居中对齐\r\r在任何标题下方的破折号右侧添加冒号将使该列的文本右对齐. 在任何标题下方的破折号两边添加冒号将使该列的对齐文本居中. | Option | Description | |:------:| -----------:| | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | 呈现的输出效果如下: Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. \r\r ","date":"2019-12-01","objectID":"/markdown/:10:0","tags":["loveit"],"title":"Markdown 基本语法","uri":"/markdown/"},{"categories":["loveit"],"content":"11 链接 ","date":"2019-12-01","objectID":"/markdown/:11:0","tags":["loveit"],"title":"Markdown 基本语法","uri":"/markdown/"},{"categories":["loveit"],"content":"基本链接 \u003chttps://assemble.io\u003e \u003ccontact@revolunet.com\u003e [Assemble](https://assemble.io) 呈现的输出效果如下 (将鼠标悬停在链接上，没有提示): https://assemble.io contact@revolunet.com Assemble 输出的 HTML 看起来像这样: \u003ca href=\"https://assemble.io\"\u003ehttps://assemble.io\u003c/a\u003e \u003ca href=\"mailto:contact@revolunet.com\"\u003econtact@revolunet.com\u003c/a\u003e \u003ca href=\"https://assemble.io\"\u003eAssemble\u003c/a\u003e ","date":"2019-12-01","objectID":"/markdown/:11:1","tags":["loveit"],"title":"Markdown 基本语法","uri":"/markdown/"},{"categories":["loveit"],"content":"添加一个标题 [Upstage](https://github.com/upstage/ \"Visit Upstage!\") 呈现的输出效果如下 (将鼠标悬停在链接上，会有一行提示): Upstage 输出的 HTML 看起来像这样: \u003ca href=\"https://github.com/upstage/\" title=\"Visit Upstage!\"\u003eUpstage\u003c/a\u003e ","date":"2019-12-01","objectID":"/markdown/:11:2","tags":["loveit"],"title":"Markdown 基本语法","uri":"/markdown/"},{"categories":["loveit"],"content":"定位标记 定位标记使你可以跳至同一页面上的指定锚点. 例如, 每个章节: ## Table of Contents * [Chapter 1](#chapter-1) * [Chapter 2](#chapter-2) * [Chapter 3](#chapter-3) 将跳转到这些部分: ## Chapter 1 \u003ca id=\"chapter-1\"\u003e\u003c/a\u003e Content for chapter one. ## Chapter 2 \u003ca id=\"chapter-2\"\u003e\u003c/a\u003e Content for chapter one. ## Chapter 3 \u003ca id=\"chapter-3\"\u003e\u003c/a\u003e Content for chapter one. 注意\r\r定位标记的位置几乎是任意的. 因为它们并不引人注目, 所以它们通常被放在同一行了.\r\r ","date":"2019-12-01","objectID":"/markdown/:11:3","tags":["loveit"],"title":"Markdown 基本语法","uri":"/markdown/"},{"categories":["loveit"],"content":"12 脚注 脚注使你可以添加注释和参考, 而不会使文档正文混乱. 当你创建脚注时, 会在添加脚注引用的位置出现带有链接的上标编号. 读者可以单击链接以跳至页面底部的脚注内容. 要创建脚注引用, 请在方括号中添加插入符号和标识符 ([^1]). 标识符可以是数字或单词, 但不能包含空格或制表符. 标识符仅将脚注引用与脚注本身相关联 - 在脚注输出中, 脚注按顺序编号. 在中括号内使用插入符号和数字以及用冒号和文本来添加脚注内容 ([^1]：这是一段脚注). 你不一定要在文档末尾添加脚注. 可以将它们放在除列表, 引用和表格等元素之外的任何位置. 这是一个数字脚注[^1]. 这是一个带标签的脚注[^label] [^1]: 这是一个数字脚注 [^label]: 这是一个带标签的脚注 这是一个数字脚注1. 这是一个带标签的脚注2 ","date":"2019-12-01","objectID":"/markdown/:12:0","tags":["loveit"],"title":"Markdown 基本语法","uri":"/markdown/"},{"categories":["loveit"],"content":"13 图片 图片的语法与链接相似, 但包含一个在前面的感叹号. ![Minion](https://octodex.github.com/images/minion.png) 或者: ![Alt text](https://octodex.github.com/images/stormtroopocat.jpg \"The Stormtroopocat\") The StormtroopocatAlt text \"\rThe Stormtroopocat\r 像链接一样, 图片也具有脚注样式的语法: ![Alt text][id] The DojocatAlt text \"\rThe Dojocat\r 稍后在文档中提供参考内容, 用来定义 URL 的位置: [id]: https://octodex.github.com/images/dojocat.jpg \"The Dojocat\" 技巧\r\rLoveIt 主题提供了一个包含更多功能的 图片的 shortcode.\r\r 这是一个数字脚注 ↩︎ 这是一个带标签的脚注 ↩︎ ","date":"2019-12-01","objectID":"/markdown/:13:0","tags":["loveit"],"title":"Markdown 基本语法","uri":"/markdown/"},{"categories":["loveit"],"content":"Hugo 和 LoveIt 中的 Emoji 的用法指南.","date":"2019-10-01","objectID":"/loveit_emoji/","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"Emoji 可以通过多种方式在 Hugo 项目中启用. emojify 方法可以直接在模板中调用, 或者使用行内 Shortcodes. 要全局使用 emoji, 需要在你的网站配置中设置 enableEmoji 为 true, 然后你就可以直接在文章中输入 emoji 的代码. 它们以冒号开头和结尾，并且包含 emoji 的 代码: 去露营啦! :tent: 很快就回来. 真开心! :joy: 呈现的输出效果如下: 去露营啦! ⛺ 很快就回来. 真开心! 😂 以下符号清单是 emoji 代码的非常有用的参考. ","date":"2019-10-01","objectID":"/loveit_emoji/:0:0","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"表情与情感 ","date":"2019-10-01","objectID":"/loveit_emoji/:1:0","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"笑脸表情 图标 代码 图标 代码 😀 grinning 😃 smiley 😄 smile 😁 grin 😆 laughing satisfied 😅 sweat_smile 🤣 rofl 😂 joy 🙂 slightly_smiling_face 🙃 upside_down_face 😉 wink 😊 blush 😇 innocent ","date":"2019-10-01","objectID":"/loveit_emoji/:1:1","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"爱意表情 图标 代码 图标 代码 😍 heart_eyes 😘 kissing_heart 😗 kissing ☺️ relaxed 😚 kissing_closed_eyes 😙 kissing_smiling_eyes ","date":"2019-10-01","objectID":"/loveit_emoji/:1:2","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"吐舌头表情 图标 代码 图标 代码 😋 yum 😛 stuck_out_tongue 😜 stuck_out_tongue_winking_eye 😝 stuck_out_tongue_closed_eyes 🤑 money_mouth_face ","date":"2019-10-01","objectID":"/loveit_emoji/:1:3","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"带手的表情 图标 代码 图标 代码 🤗 hugs 🤔 thinking ","date":"2019-10-01","objectID":"/loveit_emoji/:1:4","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"中性表情 图标 代码 图标 代码 🤐 zipper_mouth_face 😐 neutral_face 😑 expressionless 😶 no_mouth 😏 smirk 😒 unamused 🙄 roll_eyes 😬 grimacing 🤥 lying_face ","date":"2019-10-01","objectID":"/loveit_emoji/:1:5","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"困倦的表情 图标 代码 图标 代码 😌 relieved 😔 pensive 😪 sleepy 🤤 drooling_face 😴 sleeping ","date":"2019-10-01","objectID":"/loveit_emoji/:1:6","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"不适的表情 图标 代码 图标 代码 😷 mask 🤒 face_with_thermometer 🤕 face_with_head_bandage 🤢 nauseated_face 🤧 sneezing_face 😵 dizzy_face ","date":"2019-10-01","objectID":"/loveit_emoji/:1:7","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"戴帽子的表情 图标 代码 图标 代码 🤠 cowboy_hat_face ","date":"2019-10-01","objectID":"/loveit_emoji/:1:8","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"戴眼镜的表情 图标 代码 图标 代码 😎 sunglasses 🤓 nerd_face ","date":"2019-10-01","objectID":"/loveit_emoji/:1:9","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"担心的表情 图标 代码 图标 代码 😕 confused 😟 worried 🙁 slightly_frowning_face ☹ frowning_face 😮 open_mouth 😯 hushed 😲 astonished 😳 flushed 😦 frowning 😧 anguished 😨 fearful 😰 cold_sweat 😥 disappointed_relieved 😢 cry 😭 sob 😱 scream 😖 confounded 😣 persevere 😞 disappointed 😓 sweat 😩 weary 😫 tired_face ","date":"2019-10-01","objectID":"/loveit_emoji/:1:10","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"否定的表情 图标 代码 图标 代码 😤 triumph 😡 pout rage 😠 angry 😈 smiling_imp 👿 imp 💀 skull ☠️ skull_and_crossbones ","date":"2019-10-01","objectID":"/loveit_emoji/:1:11","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"特殊打扮的表情 图标 代码 图标 代码 💩 hankey poop shit 🤡 clown_face 👹 japanese_ogre 👺 japanese_goblin 👻 ghost 👽 alien 👾 space_invader 🤖 robot ","date":"2019-10-01","objectID":"/loveit_emoji/:1:12","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"猫脸表情 图标 代码 图标 代码 😺 smiley_cat 😸 smile_cat 😹 joy_cat 😻 heart_eyes_cat 😼 smirk_cat 😽 kissing_cat 🙀 scream_cat 😿 crying_cat_face 😾 pouting_cat ","date":"2019-10-01","objectID":"/loveit_emoji/:1:13","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"猴脸表情 图标 代码 图标 代码 🙈 see_no_evil 🙉 hear_no_evil 🙊 speak_no_evil ","date":"2019-10-01","objectID":"/loveit_emoji/:1:14","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"情感 图标 代码 图标 代码 💋 kiss 💌 love_letter 💘 cupid 💝 gift_heart 💖 sparkling_heart 💗 heartpulse 💓 heartbeat 💞 revolving_hearts 💕 two_hearts 💟 heart_decoration ❣️ heavy_heart_exclamation 💔 broken_heart ❤️ heart 💛 yellow_heart 💚 green_heart 💙 blue_heart 💜 purple_heart 🖤 black_heart 💯 100 💢 anger 💥 boom collision 💫 dizzy 💦 sweat_drops 💨 dash 🕳️ hole 💣 bomb 💬 speech_balloon 👁️‍🗨️ eye_speech_bubble 🗯️ right_anger_bubble 💭 thought_balloon 💤 zzz ","date":"2019-10-01","objectID":"/loveit_emoji/:1:15","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"人与身体 ","date":"2019-10-01","objectID":"/loveit_emoji/:2:0","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"张开手掌的手势 图标 代码 图标 代码 👋 wave 🤚 raised_back_of_hand 🖐️ raised_hand_with_fingers_splayed ✋ hand raised_hand 🖖 vulcan_salute ","date":"2019-10-01","objectID":"/loveit_emoji/:2:1","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"部分手指的手势 图标 代码 图标 代码 👌 ok_hand ✌️ v 🤞 crossed_fingers 🤘 metal 🤙 call_me_hand ","date":"2019-10-01","objectID":"/loveit_emoji/:2:2","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"一根手指的手势 图标 代码 图标 代码 👈 point_left 👉 point_right 👆 point_up_2 🖕 fu middle_finger 👇 point_down ☝️ point_up ","date":"2019-10-01","objectID":"/loveit_emoji/:2:3","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"握紧的手势 图标 代码 图标 代码 👍 +1 thumbsup 👎 -1 thumbsdown ✊ fist fist_raised 👊 facepunch fist_oncoming punch 🤛 fist_left 🤜 fist_right ","date":"2019-10-01","objectID":"/loveit_emoji/:2:4","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"两只手 图标 代码 图标 代码 👏 clap 🙌 raised_hands 👐 open_hands 🤝 handshake 🙏 pray ","date":"2019-10-01","objectID":"/loveit_emoji/:2:5","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"握住东西的手势 图标 代码 图标 代码 ✍️ writing_hand 💅 nail_care 🤳 selfie ","date":"2019-10-01","objectID":"/loveit_emoji/:2:6","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"身体部位 图标 代码 图标 代码 💪 muscle 👂 ear 👃 nose 👀 eyes 👁️ eye 👅 tongue 👄 lips ","date":"2019-10-01","objectID":"/loveit_emoji/:2:7","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"人 图标 代码 图标 代码 👶 baby 👦 boy 👧 girl :blonde_man: blonde_man person_with_blond_hair 👨 man 👩 woman 👱‍♀️ blonde_woman 👴 older_man 👵 older_woman ","date":"2019-10-01","objectID":"/loveit_emoji/:2:8","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"身体动作 图标 代码 图标 代码 🙍‍♀️ frowning_woman person_frowning 🙍‍♂️ frowning_man 🙎‍♀️ person_with_pouting_face pouting_woman 🙎‍♂️ pouting_man 🙅‍♀️ ng_woman no_good no_good_woman 🙅‍♂️ ng_man no_good_man 🙆‍♀️ ok_woman 🙆‍♂️ ok_man 💁‍♀️ information_desk_person sassy_woman tipping_hand_woman 💁‍♂️ sassy_man tipping_hand_man 🙋‍♀️ raising_hand raising_hand_woman 🙋‍♂️ raising_hand_man 🙇‍♂️ bow bowing_man 🙇‍♀️ bowing_woman 🤦‍♂️ man_facepalming 🤦‍♀️ woman_facepalming 🤷‍♂️ man_shrugging 🤷‍♀️ woman_shrugging ","date":"2019-10-01","objectID":"/loveit_emoji/:2:9","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"人物角色 图标 代码 图标 代码 👨‍⚕️ man_health_worker 👩‍⚕️ woman_health_worker 👨‍🎓 man_student 👩‍🎓 woman_student 👨‍🏫 man_teacher 👩‍🏫 woman_teacher 👨‍⚖️ man_judge 👩‍⚖️ woman_judge 👨‍🌾 man_farmer 👩‍🌾 woman_farmer 👨‍🍳 man_cook 👩‍🍳 woman_cook 👨‍🔧 man_mechanic 👩‍🔧 woman_mechanic 👨‍🏭 man_factory_worker 👩‍🏭 woman_factory_worker 👨‍💼 man_office_worker 👩‍💼 woman_office_worker 👨‍🔬 man_scientist 👩‍🔬 woman_scientist 👨‍💻 man_technologist 👩‍💻 woman_technologist 👨‍🎤 man_singer 👩‍🎤 woman_singer 👨‍🎨 man_artist 👩‍🎨 woman_artist 👨‍✈️ man_pilot 👩‍✈️ woman_pilot 👨‍🚀 man_astronaut 👩‍🚀 woman_astronaut 👨‍🚒 man_firefighter 👩‍🚒 woman_firefighter 👮‍♂️ cop policeman 👮‍♀️ policewoman 🕵 detective male_detective 🕵️‍♀️ female_detective 💂‍♂️ guardsman 💂‍♀️ guardswoman 👷‍♂️ construction_worker construction_worker_man 👷‍♀️ construction_worker_woman 🤴 prince 👸 princess 👳‍♂️ man_with_turban 👳‍♀️ woman_with_turban 👲 man_with_gua_pi_mao 🤵‍♂️ man_in_tuxedo 👰 bride_with_veil 🤰 pregnant_woman ","date":"2019-10-01","objectID":"/loveit_emoji/:2:10","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"幻想的人物 图标 代码 图标 代码 👼 angel 🎅 santa 🤶 mrs_claus ","date":"2019-10-01","objectID":"/loveit_emoji/:2:11","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"人物活动 图标 代码 图标 代码 💆‍♀️ massage massage_woman 💆‍♂️ massage_man 💇‍♀️ haircut haircut_woman 💇‍♂️ haircut_man 🚶‍♂️ walking walking_man 🚶‍♀️ walking_woman 🏃‍♂️ runner running running_man 🏃‍♀️ running_woman 💃 dancer 🕺 man_dancing 🕴️ business_suit_levitating 👯‍♀️ dancers dancing_women 👯‍♂️ dancing_men ","date":"2019-10-01","objectID":"/loveit_emoji/:2:12","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"体育 图标 代码 图标 代码 🤺 person_fencing 🏇 horse_racing ⛷️ skier 🏂 snowboarder 🏌️‍♂️ golfing_man 🏌️‍♀️ golfing_woman 🏄‍♂️ surfer surfing_man 🏄‍♀️ surfing_woman 🚣‍♂️ rowboat rowing_man 🚣‍♀️ rowing_woman 🏊‍♂️ swimmer swimming_man 🏊‍♀️ swimming_woman ⛹️‍♂️ basketball_man ⛹️‍♀️ basketball_woman 🏋️‍♂️ weight_lifting_man 🏋️‍♀️ weight_lifting_woman 🚴‍♂️ bicyclist biking_man 🚴‍♀️ biking_woman 🚵‍♂️ mountain_bicyclist mountain_biking_man 🚵‍♀️ mountain_biking_woman 🤸‍♂️ man_cartwheeling 🤸‍♀️ woman_cartwheeling 🤼‍♂️ men_wrestling 🤼‍♀️ women_wrestling 🤽‍♂️ man_playing_water_polo 🤽‍♀️ woman_playing_water_polo 🤾‍♂️ man_playing_handball 🤾‍♀️ woman_playing_handball 🤹‍♂️ man_juggling 🤹‍♀️ woman_juggling ","date":"2019-10-01","objectID":"/loveit_emoji/:2:13","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"休息 图标 代码 图标 代码 🛀 bath 🛌 sleeping_bed ","date":"2019-10-01","objectID":"/loveit_emoji/:2:14","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"家庭 图标 代码 图标 代码 👭 two_women_holding_hands 👫 couple 👬 two_men_holding_hands 👩‍❤️‍💋‍👨 couplekiss_man_woman 👨‍❤️‍💋‍👨 couplekiss_man_man 👩‍❤️‍💋‍👩 couplekiss_woman_woman 👩‍❤️‍👨 couple_with_heart couple_with_heart_woman_man 👨‍❤️‍👨 couple_with_heart_man_man 👩‍❤️‍👩 couple_with_heart_woman_woman 👨‍👩‍👦 family family_man_woman_boy 👨‍👩‍👧 family_man_woman_girl 👨‍👩‍👧‍👦 family_man_woman_girl_boy 👨‍👩‍👦‍👦 family_man_woman_boy_boy 👨‍👩‍👧‍👧 family_man_woman_girl_girl 👨‍👨‍👦 family_man_man_boy 👨‍👨‍👧 family_man_man_girl 👨‍👨‍👧‍👦 family_man_man_girl_boy 👨‍👨‍👦‍👦 family_man_man_boy_boy 👨‍👨‍👧‍👧 family_man_man_girl_girl 👩‍👩‍👦 family_woman_woman_boy 👩‍👩‍👧 family_woman_woman_girl 👩‍👩‍👧‍👦 family_woman_woman_girl_boy 👩‍👩‍👦‍👦 family_woman_woman_boy_boy 👩‍👩‍👧‍👧 family_woman_woman_girl_girl 👨‍👦 family_man_boy 👨‍👦‍👦 family_man_boy_boy 👨‍👧 family_man_girl 👨‍👧‍👦 family_man_girl_boy 👨‍👧‍👧 family_man_girl_girl 👩‍👦 family_woman_boy 👩‍👦‍👦 family_woman_boy_boy 👩‍👧 family_woman_girl 👩‍👧‍👦 family_woman_girl_boy 👩‍👧‍👧 family_woman_girl_girl ","date":"2019-10-01","objectID":"/loveit_emoji/:2:15","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"人物符号 图标 代码 图标 代码 🗣 speaking_head 👤 bust_in_silhouette 👥 busts_in_silhouette 👣 footprints ","date":"2019-10-01","objectID":"/loveit_emoji/:2:16","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"动物与自然 ","date":"2019-10-01","objectID":"/loveit_emoji/:3:0","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"哺乳动物 图标 代码 图标 代码 🐵 monkey_face 🐒 monkey 🦍 gorilla 🐶 dog 🐕 dog2 🐩 poodle 🐺 wolf 🦊 fox_face 🐱 cat 🐈 cat2 🦁 lion 🐯 tiger 🐅 tiger2 🐆 leopard 🐴 horse 🐎 racehorse 🦄 unicorn 🦌 deer 🐮 cow 🐂 ox 🐃 water_buffalo 🐄 cow2 🐷 pig 🐖 pig2 🐗 boar 🐽 pig_nose 🐏 ram 🐑 sheep 🐐 goat 🐪 dromedary_camel 🐫 camel 🐘 elephant 🦏 rhinoceros 🐭 mouse 🐁 mouse2 🐀 rat 🐹 hamster 🐰 rabbit 🐇 rabbit2 🐿️ chipmunk 🦇 bat 🐻 bear 🐨 koala 🐼 panda_face 🐾 feet paw_prints ","date":"2019-10-01","objectID":"/loveit_emoji/:3:1","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"鸟类 图标 代码 图标 代码 🦃 turkey 🐔 chicken 🐓 rooster 🐣 hatching_chick 🐤 baby_chick 🐥 hatched_chick 🐦 bird 🐧 penguin 🕊 dove 🦅 eagle 🦆 duck 🦉 owl ","date":"2019-10-01","objectID":"/loveit_emoji/:3:2","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"两栖动物 icon code icon code 🐸 frog ","date":"2019-10-01","objectID":"/loveit_emoji/:3:3","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"爬虫类 图标 代码 图标 代码 🐊 crocodile 🐢 turtle 🦎 lizard 🐍 snake 🐲 dragon_face 🐉 dragon ","date":"2019-10-01","objectID":"/loveit_emoji/:3:4","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"海洋动物 图标 代码 图标 代码 🐳 whale 🐋 whale2 🐬 dolphin flipper 🐟 fish 🐠 tropical_fish 🐡 blowfish 🦈 shark 🐙 octopus 🐚 shell ","date":"2019-10-01","objectID":"/loveit_emoji/:3:5","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"虫类 图标 代码 图标 代码 🐌 snail 🦋 butterfly 🐛 bug 🐜 ant 🐝 bee honeybee 🪲 beetle 🕷️ spider 🕸️ spider_web 🦂 scorpion ","date":"2019-10-01","objectID":"/loveit_emoji/:3:6","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"花类植物 图标 代码 图标 代码 💐 bouquet 🌸 cherry_blossom 💮 white_flower 🏵️ rosette 🌹 rose 🥀 wilted_flower 🌺 hibiscus 🌻 sunflower 🌼 blossom 🌷 tulip ","date":"2019-10-01","objectID":"/loveit_emoji/:3:7","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"其它植物 图标 代码 图标 代码 🌱 seedling 🌲 evergreen_tree 🌳 deciduous_tree 🌴 palm_tree 🌵 cactus 🌾 ear_of_rice 🌿 herb ☘️ shamrock 🍀 four_leaf_clover 🍁 maple_leaf 🍂 fallen_leaf 🍃 leaves ","date":"2019-10-01","objectID":"/loveit_emoji/:3:8","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"食物与饮料 ","date":"2019-10-01","objectID":"/loveit_emoji/:4:0","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"水果 图标 代码 图标 代码 🍇 grapes 🍈 melon 🍉 watermelon 🍊 mandarin orange tangerine 🍋 lemon 🍌 banana 🍍 pineapple 🍎 apple 🍏 green_apple 🍐 pear 🍑 peach 🍒 cherries 🍓 strawberry 🥝 kiwi_fruit 🍅 tomato ","date":"2019-10-01","objectID":"/loveit_emoji/:4:1","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"蔬菜 图标 代码 图标 代码 🥑 avocado 🍆 eggplant 🥔 potato 🥕 carrot 🌽 corn 🌶️ hot_pepper 🥒 cucumber 🍄 mushroom 🥜 peanuts 🌰 chestnut ","date":"2019-10-01","objectID":"/loveit_emoji/:4:2","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"快餐 图标 代码 图标 代码 🍞 bread 🥐 croissant 🥖 baguette_bread 🥞 pancakes 🧀 cheese 🍖 meat_on_bone 🍗 poultry_leg 🥓 bacon 🍔 hamburger 🍟 fries 🍕 pizza 🌭 hotdog 🌮 taco 🌯 burrito 🥙 stuffed_flatbread 🥚 egg 🍳 fried_egg 🥘 shallow_pan_of_food 🍲 stew 🥗 green_salad 🍿 popcorn ","date":"2019-10-01","objectID":"/loveit_emoji/:4:3","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"亚洲食物 图标 代码 图标 代码 🍱 bento 🍘 rice_cracker 🍙 rice_ball 🍚 rice 🍛 curry 🍜 ramen 🍝 spaghetti 🍠 sweet_potato 🍢 oden 🍣 sushi 🍤 fried_shrimp 🍥 fish_cake 🍡 dango ","date":"2019-10-01","objectID":"/loveit_emoji/:4:4","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"海鲜 图标 代码 图标 代码 🦀 crab 🦐 shrimp 🦑 squid ","date":"2019-10-01","objectID":"/loveit_emoji/:4:5","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"甜点 图标 代码 图标 代码 🍦 icecream 🍧 shaved_ice 🍨 ice_cream 🍩 doughnut 🍪 cookie 🎂 birthday 🍰 cake 🍫 chocolate_bar 🍬 candy 🍭 lollipop 🍮 custard 🍯 honey_pot ","date":"2019-10-01","objectID":"/loveit_emoji/:4:6","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"饮料 图标 代码 图标 代码 🍼 baby_bottle 🥛 milk_glass ☕ coffee 🍵 tea 🍶 sake 🍾 champagne 🍷 wine_glass 🍸 cocktail 🍹 tropical_drink 🍺 beer 🍻 beers 🥂 clinking_glasses 🥃 tumbler_glass ","date":"2019-10-01","objectID":"/loveit_emoji/:4:7","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"餐具 图标 代码 图标 代码 🍽️ plate_with_cutlery 🍴 fork_and_knife 🥄 spoon 🔪 hocho knife 🏺 amphora ","date":"2019-10-01","objectID":"/loveit_emoji/:4:8","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"旅游与地理 ","date":"2019-10-01","objectID":"/loveit_emoji/:5:0","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"地图 图标 代码 图标 代码 🌍 earth_africa 🌎 earth_americas 🌏 earth_asia 🌐 globe_with_meridians 🗺️ world_map 🗾 japan ","date":"2019-10-01","objectID":"/loveit_emoji/:5:1","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"地理现象 图标 代码 图标 代码 🏔 mountain_snow ⛰️ mountain 🌋 volcano 🗻 mount_fuji 🏕️ camping ⛱ beach_umbrella 🏜️ desert 🏝️ desert_island 🏞️ national_park ","date":"2019-10-01","objectID":"/loveit_emoji/:5:2","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"建筑物 图标 代码 图标 代码 🏟️ stadium 🏛️ classical_building 🏗️ building_construction 🏘 houses 🏚 derelict_house 🏠 house 🏡 house_with_garden 🏢 office 🏣 post_office 🏤 european_post_office 🏥 hospital 🏦 bank 🏨 hotel 🏩 love_hotel 🏪 convenience_store 🏫 school 🏬 department_store 🏭 factory 🏯 japanese_castle 🏰 european_castle 💒 wedding 🗼 tokyo_tower 🗽 statue_of_liberty ","date":"2019-10-01","objectID":"/loveit_emoji/:5:3","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"宗教建筑 图标 代码 图标 代码 ⛪ church 🕌 mosque 🕍 synagogue ⛩️ shinto_shrine 🕋 kaaba ","date":"2019-10-01","objectID":"/loveit_emoji/:5:4","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"其它地点 图标 代码 图标 代码 ⛲ fountain ⛺ tent 🌁 foggy 🌃 night_with_stars 🏙️ cityscape 🌄 sunrise_over_mountains 🌅 sunrise 🌆 city_sunset 🌇 city_sunrise 🌉 bridge_at_night ♨️ hotsprings 🎠 carousel_horse 🎡 ferris_wheel 🎢 roller_coaster 💈 barber 🎪 circus_tent ","date":"2019-10-01","objectID":"/loveit_emoji/:5:5","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"陆路运输 图标 代码 图标 代码 🚂 steam_locomotive 🚃 railway_car 🚄 bullettrain_side 🚅 bullettrain_front 🚆 train2 🚇 metro 🚈 light_rail 🚉 station 🚊 tram 🚝 monorail 🚞 mountain_railway 🚋 train 🚌 bus 🚍 oncoming_bus 🚎 trolleybus 🚐 minibus 🚑 ambulance 🚒 fire_engine 🚓 police_car 🚔 oncoming_police_car 🚕 taxi 🚖 oncoming_taxi 🚗 car red_car 🚘 oncoming_automobile 🚙 blue_car 🚚 truck 🚛 articulated_lorry 🚜 tractor 🏎️ racing_car 🏍 motorcycle 🛵 motor_scooter 🚲 bike 🛴 kick_scooter 🚏 busstop 🛣️ motorway 🛤️ railway_track 🛢️ oil_drum ⛽ fuelpump 🚨 rotating_light 🚥 traffic_light 🚦 vertical_traffic_light 🛑 stop_sign 🚧 construction ","date":"2019-10-01","objectID":"/loveit_emoji/:5:6","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"水路运输 图标 代码 图标 代码 ⚓ anchor ⛵ boat sailboat 🛶 canoe 🚤 speedboat 🛳️ passenger_ship ⛴️ ferry 🛥️ motor_boat 🚢 ship ","date":"2019-10-01","objectID":"/loveit_emoji/:5:7","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"空中运输 图标 代码 图标 代码 ✈️ airplane 🛩️ small_airplane 🛫 flight_departure 🛬 flight_arrival 💺 seat 🚁 helicopter 🚟 suspension_railway 🚠 mountain_cableway 🚡 aerial_tramway 🛰️ artificial_satellite 🚀 rocket ","date":"2019-10-01","objectID":"/loveit_emoji/:5:8","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"旅馆 icon code icon code 🛎️ bellhop_bell ","date":"2019-10-01","objectID":"/loveit_emoji/:5:9","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"时间 图标 代码 图标 代码 ⌛ hourglass ⏳ hourglass_flowing_sand ⌚ watch ⏰ alarm_clock ⏱️ stopwatch ⏲️ timer_clock 🕰️ mantelpiece_clock 🕛 clock12 🕧 clock1230 🕐 clock1 🕜 clock130 🕑 clock2 🕝 clock230 🕒 clock3 🕞 clock330 🕓 clock4 🕟 clock430 🕔 clock5 🕠 clock530 🕕 clock6 🕡 clock630 🕖 clock7 🕢 clock730 🕗 clock8 🕣 clock830 🕘 clock9 🕤 clock930 🕙 clock10 🕥 clock1030 🕚 clock11 🕦 clock1130 ","date":"2019-10-01","objectID":"/loveit_emoji/:5:10","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"天空与天气 图标 代码 图标 代码 🌑 new_moon 🌒 waxing_crescent_moon 🌓 first_quarter_moon 🌔 moon waxing_gibbous_moon 🌕 full_moon 🌖 waning_gibbous_moon 🌗 last_quarter_moon 🌘 waning_crescent_moon 🌙 crescent_moon 🌚 new_moon_with_face 🌛 first_quarter_moon_with_face 🌜 last_quarter_moon_with_face 🌡️ thermometer ☀️ sunny 🌝 full_moon_with_face 🌞 sun_with_face ⭐ star 🌟 star2 🌠 stars 🌌 milky_way ☁️ cloud ⛅ partly_sunny ⛈ cloud_with_lightning_and_rain 🌤 sun_behind_small_cloud 🌥 sun_behind_large_cloud 🌦 sun_behind_rain_cloud 🌧 cloud_with_rain 🌨 cloud_with_snow 🌩 cloud_with_lightning 🌪️ tornado 🌫️ fog 🌬 wind_face 🌀 cyclone 🌈 rainbow 🌂 closed_umbrella ☂️ open_umbrella ☂️ umbrella ⛱️ parasol_on_ground ⚡ zap ❄️ snowflake ☃️ snowman_with_snow ☃️ snowman ☄️ comet 🔥 fire 💧 droplet 🌊 ocean ","date":"2019-10-01","objectID":"/loveit_emoji/:5:11","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"活动 ","date":"2019-10-01","objectID":"/loveit_emoji/:6:0","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"事件 图标 代码 图标 代码 🎃 jack_o_lantern 🎄 christmas_tree 🎆 fireworks 🎇 sparkler ✨ sparkles 🎈 balloon 🎉 tada 🎊 confetti_ball 🎋 tanabata_tree 🎍 bamboo 🎎 dolls 🎏 flags 🎐 wind_chime 🎑 rice_scene 🎀 ribbon 🎁 gift 🎗️ reminder_ribbon 🎟 tickets 🎫 ticket ","date":"2019-10-01","objectID":"/loveit_emoji/:6:1","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"奖杯与奖牌 图标 代码 图标 代码 🎖️ medal_military 🏆 trophy 🏅 medal_sports 🥇 1st_place_medal 🥈 2nd_place_medal 🥉 3rd_place_medal ","date":"2019-10-01","objectID":"/loveit_emoji/:6:2","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"体育运动 图标 代码 图标 代码 ⚽ soccer ⚾ baseball 🏀 basketball 🏐 volleyball 🏈 football 🏉 rugby_football 🎾 tennis 🎳 bowling 🦗 cricket 🏑 field_hockey 🏒 ice_hockey 🏓 ping_pong 🏸 badminton 🥊 boxing_glove 🥋 martial_arts_uniform 🥅 goal_net ⛳ golf ⛸️ ice_skate 🎣 fishing_pole_and_fish 🎽 running_shirt_with_sash 🎿 ski ","date":"2019-10-01","objectID":"/loveit_emoji/:6:3","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"游戏 图标 代码 图标 代码 🎯 dart 🎱 8ball 🔮 crystal_ball 🎮 video_game 🕹️ joystick 🎰 slot_machine 🎲 game_die ♠️ spades ♥️ hearts ♦️ diamonds ♣️ clubs 🃏 black_joker 🀄 mahjong 🎴 flower_playing_cards ","date":"2019-10-01","objectID":"/loveit_emoji/:6:4","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"艺术与工艺 图标 代码 图标 代码 🎭 performing_arts 🖼 framed_picture 🎨 art ","date":"2019-10-01","objectID":"/loveit_emoji/:6:5","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"物品 ","date":"2019-10-01","objectID":"/loveit_emoji/:7:0","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"服装 图标 代码 图标 代码 👓 eyeglasses 🕶️ dark_sunglasses 👔 necktie 👕 shirt tshirt 👖 jeans 👗 dress 👘 kimono 👙 bikini 👚 womans_clothes 👛 purse 👜 handbag 👝 pouch 🛍️ shopping 🎒 school_satchel 👞 mans_shoe shoe 👟 athletic_shoe 👠 high_heel 👡 sandal 👢 boot 👑 crown 👒 womans_hat 🎩 tophat 🎓 mortar_board ⛑️ rescue_worker_helmet 📿 prayer_beads 💄 lipstick 💍 ring 💎 gem ","date":"2019-10-01","objectID":"/loveit_emoji/:7:1","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"声音 图标 代码 图标 代码 🔇 mute 🔈 speaker 🔉 sound 🔊 loud_sound 📢 loudspeaker 📣 mega 📯 postal_horn 🔔 bell 🔕 no_bell ","date":"2019-10-01","objectID":"/loveit_emoji/:7:2","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"音乐 图标 代码 图标 代码 🎼 musical_score 🎵 musical_note 🎶 notes 🎙️ studio_microphone 🎚️ level_slider 🎛️ control_knobs 🎤 microphone 🎧 headphones 📻 radio ","date":"2019-10-01","objectID":"/loveit_emoji/:7:3","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"乐器 图标 代码 图标 代码 🎷 saxophone 🎸 guitar 🎹 musical_keyboard 🎺 trumpet 🎻 violin 🥁 drum ","date":"2019-10-01","objectID":"/loveit_emoji/:7:4","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"电话 图标 代码 图标 代码 📱 iphone 📲 calling ☎️ phone telephone 📞 telephone_receiver 📟 pager 📠 fax ","date":"2019-10-01","objectID":"/loveit_emoji/:7:5","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"电脑 图标 代码 图标 代码 🔋 battery 🔌 electric_plug 💻 computer 🖥️ desktop_computer 🖨️ printer ⌨️ keyboard 🖱 computer_mouse 🖲️ trackball 💽 minidisc 💾 floppy_disk 💿 cd 📀 dvd ","date":"2019-10-01","objectID":"/loveit_emoji/:7:6","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"灯光与影像 图标 代码 图标 代码 🎥 movie_camera 🎞️ film_strip 📽️ film_projector 🎬 clapper 📺 tv 📷 camera 📸 camera_flash 📹 video_camera 📼 vhs 🔍 mag 🔎 mag_right 🕯️ candle 💡 bulb 🔦 flashlight 🏮 izakaya_lantern lantern ","date":"2019-10-01","objectID":"/loveit_emoji/:7:7","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"书与纸张 图标 代码 图标 代码 📔 notebook_with_decorative_cover 📕 closed_book 📖 book open_book 📗 green_book 📘 blue_book 📙 orange_book 📚 books 📓 notebook 📒 ledger 📃 page_with_curl 📜 scroll 📄 page_facing_up 📰 newspaper 🗞️ newspaper_roll 📑 bookmark_tabs 🔖 bookmark 🏷️ label ","date":"2019-10-01","objectID":"/loveit_emoji/:7:8","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"钱 图标 代码 图标 代码 💰 moneybag 💴 yen 💵 dollar 💶 euro 💷 pound 💸 money_with_wings 💳 credit_card 💹 chart ","date":"2019-10-01","objectID":"/loveit_emoji/:7:9","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"邮件 图标 代码 图标 代码 ✉️ email envelope 📧 📧 📨 incoming_envelope 📩 envelope_with_arrow 📤 outbox_tray 📥 inbox_tray 📦 package 📫 mailbox 📪 mailbox_closed 📬 mailbox_with_mail 📭 mailbox_with_no_mail 📮 postbox 🗳 ballot_box ","date":"2019-10-01","objectID":"/loveit_emoji/:7:10","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"书写 图标 代码 图标 代码 ✏️ pencil2 ✒️ black_nib 🖋 fountain_pen 🖊 pen 🖌 paintbrush 🖍 crayon 📝 memo pencil ","date":"2019-10-01","objectID":"/loveit_emoji/:7:11","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"办公 图标 代码 图标 代码 💼 briefcase 📁 file_folder 📂 open_file_folder 🗂️ card_index_dividers 📅 date 📆 calendar 🗒 spiral_notepad 🗓 spiral_calendar 📇 card_index 📈 chart_with_upwards_trend 📉 chart_with_downwards_trend 📊 bar_chart 📋 clipboard 📌 pushpin 📍 round_pushpin 📎 paperclip 🖇 paperclips 📏 straight_ruler 📐 triangular_ruler ✂️ scissors 🗃️ card_file_box 🗄️ file_cabinet 🗑️ wastebasket ","date":"2019-10-01","objectID":"/loveit_emoji/:7:12","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"锁 图标 代码 图标 代码 🔒 lock 🔓 unlock 🔏 lock_with_ink_pen 🔐 closed_lock_with_key 🔑 key 🗝️ old_key ","date":"2019-10-01","objectID":"/loveit_emoji/:7:13","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"工具 图标 代码 图标 代码 🔨 hammer ⛏️ pick ⚒️ hammer_and_pick 🛠️ hammer_and_wrench 🗡 dagger ⚔️ crossed_swords 🔫 gun 🏹 bow_and_arrow 🛡️ shield 🔧 wrench 🔩 nut_and_bolt ⚙️ gear 🗜 clamp ⚖ balance_scale 🔗 link ⛓️ chains ","date":"2019-10-01","objectID":"/loveit_emoji/:7:14","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"科学 图标 代码 图标 代码 ⚗️ alembic 🔬 microscope 🔭 telescope 🛰️ satellite ","date":"2019-10-01","objectID":"/loveit_emoji/:7:15","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"医疗 图标 代码 图标 代码 💉 syringe 💊 pill ","date":"2019-10-01","objectID":"/loveit_emoji/:7:16","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"生活用品 图标 代码 图标 代码 🚪 door 🛏️ bed 🛋️ couch_and_lamp 🚽 toilet 🚿 shower 🛁 bathtub 🛒 shopping_cart ","date":"2019-10-01","objectID":"/loveit_emoji/:7:17","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"其它物品 图标 代码 图标 代码 🚬 smoking ⚰️ coffin ⚱️ funeral_urn 🗿 moyai ","date":"2019-10-01","objectID":"/loveit_emoji/:7:18","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"符号 ","date":"2019-10-01","objectID":"/loveit_emoji/:8:0","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"交通标识 图标 代码 图标 代码 🏧 atm 🚮 put_litter_in_its_place 🚰 potable_water ♿ wheelchair 🚹 mens 🚺 womens 🚻 restroom 🚼 baby_symbol 🚾 wc 🛂 passport_control 🛃 customs 🛄 baggage_claim 🛅 left_luggage ","date":"2019-10-01","objectID":"/loveit_emoji/:8:1","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"警告 图标 代码 图标 代码 ⚠️ warning 🚸 children_crossing ⛔ no_entry 🚫 no_entry_sign 🚳 no_bicycles 🚭 no_smoking 🚯 do_not_litter 🚱 🚱 🚷 no_pedestrians 📵 no_mobile_phones 🔞 underage ☢ radioactive ☣ biohazard ","date":"2019-10-01","objectID":"/loveit_emoji/:8:2","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"箭头 图标 代码 图标 代码 ⬆️ arrow_up ↗️ arrow_upper_right ➡️ arrow_right ↘️ arrow_lower_right ⬇️ arrow_down ↙️ arrow_lower_left ⬅️ arrow_left ↖️ arrow_upper_left ↕️ arrow_up_down ↔️ left_right_arrow ↩️ leftwards_arrow_with_hook ↪️ arrow_right_hook ⤴️ arrow_heading_up ⤵️ arrow_heading_down 🔃 arrows_clockwise 🔄 arrows_counterclockwise 🔙 back 🔚 end 🔛 on 🔜 soon 🔝 top ","date":"2019-10-01","objectID":"/loveit_emoji/:8:3","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"宗教 图标 代码 图标 代码 🛐 place_of_worship ⚛️ atom_symbol 🕉 om ✡️ star_of_david ☸️ wheel_of_dharma ☯️ yin_yang ✝️ latin_cross ☦️ orthodox_cross ☪️ star_and_crescent ☮️ peace_symbol 🕎 menorah 🔯 six_pointed_star ","date":"2019-10-01","objectID":"/loveit_emoji/:8:4","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"生肖 图标 代码 图标 代码 ♈ aries ♉ taurus ♊ gemini ♋ cancer ♌ leo ♍ virgo ♎ libra ♏ scorpius ♐ sagittarius ♑ capricorn ♒ aquarius ♓ pisces ⛎ ophiuchus ","date":"2019-10-01","objectID":"/loveit_emoji/:8:5","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"影像符号 图标 代码 图标 代码 🔀 twisted_rightwards_arrows 🔁 repeat 🔂 repeat_one ▶️ arrow_forward ⏩ fast_forward ⏭ next_track_button ⏯ play_or_pause_button ◀️ arrow_backward ⏪ rewind ⏮️ previous_track_button 🔼 arrow_up_small ⏫ arrow_double_up 🔽 arrow_down_small ⏬ arrow_double_down ⏸ pause_button ⏹ stop_button ⏺ record_button 🎦 cinema 🔅 low_brightness 🔆 high_brightness 📶 signal_strength 📳 vibration_mode 📴 mobile_phone_off ","date":"2019-10-01","objectID":"/loveit_emoji/:8:6","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"数学 图标 代码 图标 代码 ✖️ heavy_multiplication_x ➕ heavy_plus_sign ➖ heavy_minus_sign ➗ heavy_division_sign ","date":"2019-10-01","objectID":"/loveit_emoji/:8:7","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"标点符号 图标 代码 图标 代码 ‼️ bangbang ⁉️ interrobang ❓ question ❔ grey_question ❕ grey_exclamation ❗ exclamation heavy_exclamation_mark 〰️ wavy_dash ","date":"2019-10-01","objectID":"/loveit_emoji/:8:8","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"货币 图标 代码 图标 代码 💱 currency_exchange 💲 heavy_dollar_sign ","date":"2019-10-01","objectID":"/loveit_emoji/:8:9","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"按键符号 图标 代码 图标 代码 #️⃣ hash *️⃣ asterisk 0️⃣ zero 1️⃣ one 2️⃣ two 3️⃣ three 4️⃣ four 5️⃣ five 6️⃣ six 7️⃣ seven 8️⃣ eight 9️⃣ nine 🔟 keycap_ten ","date":"2019-10-01","objectID":"/loveit_emoji/:8:10","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"字母符号 图标 代码 图标 代码 🔠 capital_abcd 🔡 abcd 🔢 1234 🔣 symbols 🔤 abc 🅰️ a 🆎 ab 🅱️ b 🆑 cl 🆒 cool 🆓 free ℹ️ information_source 🆔 id ⓜ️ m 🆕 new 🆖 ng 🅾️ o2 🆗 ok 🅿️ parking 🆘 sos 🆙 up 🆚 vs 🈁 koko 🈂️ sa 🈷️ u6708 🈶 u6709 🈯 u6307 🉐 ideograph_advantage 🈹 u5272 🈚 u7121 🈲 u7981 🉑 accept 🈸 u7533 🈴 u5408 🈳 u7a7a ㊗️ congratulations ㊙️ secret 🈺 u55b6 🈵 u6e80 ","date":"2019-10-01","objectID":"/loveit_emoji/:8:11","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"几何符号 图标 代码 图标 代码 🔴 red_circle 🔵 large_blue_circle ⚫ black_circle ⚪ white_circle ⬛ black_large_square ⬜ white_large_square ◼️ black_medium_square ◻️ white_medium_square ◾ black_medium_small_square ◽ white_medium_small_square ▪️ black_small_square ▫️ white_small_square 🔶 large_orange_diamond 🔷 large_blue_diamond 🔸 small_orange_diamond 🔹 small_blue_diamond 🔺 small_red_triangle 🔻 small_red_triangle_down 💠 diamond_shape_with_a_dot_inside 🔘 radio_button 🔳 white_square_button 🔲 black_square_button ","date":"2019-10-01","objectID":"/loveit_emoji/:8:12","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"其它符合 图标 代码 图标 代码 ♻️ recycle ⚜️ fleur_de_lis 🔱 trident 📛 name_badge 🔰 beginner ⭕ o ✅ white_check_mark ☑️ ballot_box_with_check ✔️ heavy_check_mark ❌ x ❎ negative_squared_cross_mark ➰ curly_loop ➿ loop 〽️ part_alternation_mark ✳️ eight_spoked_asterisk ✴️ eight_pointed_black_star ❇️ sparkle ©️ copyright ®️ registered ™️ tm ","date":"2019-10-01","objectID":"/loveit_emoji/:8:13","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"旗帜 ","date":"2019-10-01","objectID":"/loveit_emoji/:9:0","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"常用旗帜 图标 代码 图标 代码 🏁 checkered_flag 🚩 triangular_flag_on_post 🎌 crossed_flags 🏴 black_flag 🏳 white_flag 🏳️‍🌈 rainbow_flag ","date":"2019-10-01","objectID":"/loveit_emoji/:9:1","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"},{"categories":["loveit"],"content":"国家和地区旗帜 图标 代码 图标 代码 🇦🇩 andorra 🇦🇪 united_arab_emirates 🇦🇫 afghanistan 🇦🇬 antigua_barbuda 🇦🇮 anguilla 🇦🇱 albania 🇦🇲 armenia 🇦🇴 angola 🇦🇶 antarctica 🇦🇷 argentina 🇦🇸 american_samoa 🇦🇹 austria 🇦🇺 australia 🇦🇼 aruba 🇦🇽 aland_islands 🇦🇿 azerbaijan 🇧🇦 bosnia_herzegovina 🇧🇧 barbados 🇧🇩 bangladesh 🇧🇪 belgium 🇧🇫 burkina_faso 🇧🇬 bulgaria 🇧🇭 bahrain 🇧🇮 burundi 🇧🇯 benin 🇧🇱 st_barthelemy 🇧🇲 bermuda 🇧🇳 brunei 🇧🇴 bolivia 🇧🇶 caribbean_netherlands 🇧🇷 brazil 🇧🇸 bahamas 🇧🇹 bhutan 🇧🇼 botswana 🇧🇾 belarus 🇧🇿 belize 🇨🇦 canada 🇨🇨 cocos_islands 🇨🇩 congo_kinshasa 🇨🇫 central_african_republic 🇨🇬 congo_brazzaville 🇨🇭 switzerland 🇨🇮 cote_divoire 🇨🇰 cook_islands 🇨🇱 chile 🇨🇲 cameroon 🇨🇳 cn 🇨🇴 colombia 🇨🇷 costa_rica 🇨🇺 cuba 🇨🇻 cape_verde 🇨🇼 curacao 🇨🇽 christmas_island 🇨🇾 cyprus 🇨🇿 czech_republic 🇩🇪 de 🇩🇯 djibouti 🇩🇰 denmark 🇩🇲 dominica 🇩🇴 dominican_republic 🇩🇿 algeria 🇪🇨 ecuador 🇪🇪 estonia 🇪🇬 egypt 🇪🇭 western_sahara 🇪🇷 eritrea 🇪🇸 es 🇪🇹 ethiopia 🇪🇺 eu european_union 🇫🇮 finland 🇫🇯 fiji 🇫🇰 falkland_islands 🇫🇲 micronesia 🇫🇴 faroe_islands 🇫🇷 fr 🇬🇦 gabon 🇬🇧 gb uk 🇬🇩 grenada 🇬🇪 georgia 🇬🇫 french_guiana 🇬🇬 guernsey 🇬🇭 ghana 🇬🇮 gibraltar 🇬🇱 greenland 🇬🇲 gambia 🇬🇳 guinea 🇬🇵 guadeloupe 🇬🇶 equatorial_guinea 🇬🇷 greece 🇬🇸 south_georgia_south_sandwich_islands 🇬🇹 guatemala 🇬🇺 guam 🇬🇼 guinea_bissau 🇬🇾 guyana 🇭🇰 hong_kong 🇭🇳 honduras 🇭🇷 croatia 🇭🇹 haiti 🇭🇺 hungary 🇮🇨 canary_islands 🇮🇩 indonesia 🇮🇪 ireland 🇮🇱 israel 🇮🇲 isle_of_man 🇮🇳 india 🇮🇴 british_indian_ocean_territory 🇮🇶 iraq 🇮🇷 iran 🇮🇸 iceland 🇮🇹 it 🇯🇪 jersey 🇯🇲 jamaica 🇯🇴 jordan 🇯🇵 jp 🇰🇪 kenya 🇰🇬 kyrgyzstan 🇰🇭 cambodia 🇰🇮 kiribati 🇰🇲 comoros 🇰🇳 st_kitts_nevis 🇰🇵 north_korea 🇰🇷 kr 🇰🇼 kuwait 🇰🇾 cayman_islands 🇰🇿 kazakhstan 🇱🇦 laos 🇱🇧 lebanon 🇱🇨 st_lucia 🇱🇮 liechtenstein 🇱🇰 sri_lanka 🇱🇷 liberia 🇱🇸 lesotho 🇱🇹 lithuania 🇱🇺 luxembourg 🇱🇻 latvia 🇱🇾 libya 🇲🇦 morocco 🇲🇨 monaco 🇲🇩 moldova 🇲🇪 montenegro 🇲🇬 madagascar 🇲🇭 marshall_islands 🇲🇰 macedonia 🇲🇱 mali 🇲🇲 myanmar 🇲🇳 mongolia 🇲🇴 macau 🇲🇵 northern_mariana_islands 🇲🇶 martinique 🇲🇷 mauritania 🇲🇸 montserrat 🇲🇹 malta 🇲🇺 mauritius 🇲🇻 maldives 🇲🇼 malawi 🇲🇽 mexico 🇲🇾 malaysia 🇲🇿 mozambique 🇳🇦 namibia 🇳🇨 new_caledonia 🇳🇪 niger 🇳🇫 norfolk_island 🇳🇬 nigeria 🇳🇮 nicaragua 🇳🇱 netherlands 🇳🇴 norway 🇳🇵 nepal 🇳🇷 nauru 🇳🇺 niue 🇳🇿 new_zealand 🇴🇲 oman 🇵🇦 panama 🇵🇪 peru 🇵🇫 french_polynesia 🇵🇬 papua_new_guinea 🇵🇭 philippines 🇵🇰 pakistan 🇵🇱 poland 🇵🇲 st_pierre_miquelon 🇵🇳 pitcairn_islands 🇵🇷 puerto_rico 🇵🇸 palestinian_territories 🇵🇹 portugal 🇵🇼 palau 🇵🇾 paraguay 🇶🇦 qatar 🇷🇪 reunion 🇷🇴 romania 🇷🇸 serbia 🇷🇺 ru 🇷🇼 rwanda 🇸🇦 saudi_arabia 🇸🇧 solomon_islands 🇸🇨 seychelles 🇸🇩 sudan 🇸🇪 sweden 🇸🇬 singapore 🇸🇭 st_helena 🇸🇮 slovenia 🇸🇰 slovakia 🇸🇱 sierra_leone 🇸🇲 san_marino 🇸🇳 senegal 🇸🇴 somalia 🇸🇷 suriname 🇸🇸 south_sudan 🇸🇹 sao_tome_principe 🇸🇻 el_salvador 🇸🇽 sint_maarten 🇸🇾 syria 🇸🇿 swaziland 🇹🇨 turks_caicos_islands 🇹🇩 chad 🇹🇫 french_southern_territories 🇹🇬 togo 🇹🇭 thailand 🇹🇯 tajikistan 🇹🇰 tokelau 🇹🇱 timor_leste 🇹🇲 turkmenistan 🇹🇳 tunisia 🇹🇴 tonga 🇹🇷 tr 🇹🇹 trinidad_tobago 🇹🇻 tuvalu 🇹🇼 taiwan 🇹🇿 tanzania 🇺🇦 ukraine 🇺🇬 uganda 🇺🇸 us 🇺🇾 uruguay 🇺🇿 uzbekistan 🇻🇦 vatican_city 🇻🇨 st_vincent_grenadines 🇻🇪 venezuela 🇻🇬 british_virgin_islands 🇻🇮 us_virgin_islands 🇻🇳 vietnam 🇻🇺 vanuatu 🇼🇫 wallis_futuna 🇼🇸 samoa 🇽🇰 kosovo 🇾🇪 yemen 🇾🇹 mayotte 🇿🇦 south_africa 🇿🇲 zambia 🇿🇼 zimbabwe ","date":"2019-10-01","objectID":"/loveit_emoji/:9:2","tags":["loveit"],"title":"Loveit Emoji 支持","uri":"/loveit_emoji/"}]