<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="python 标准库,译文," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="本系列 blog 与 python wrat 模块相关，深入介绍了 Python 装饰器，猴子补订等相关内容，翻译于 https://github.com/GrahamDumpleton/wrapt/tree/master/blog  本篇内容: 使用通用装饰器接口实现类似 Java 的 synchronized 同步原语">
<meta name="keywords" content="python 标准库,译文">
<meta property="og:type" content="article">
<meta property="og:title" content="07 The missing @synchronized decorator">
<meta property="og:url" content="http://yoursite.com/2018/05/26/wrapt/07-the-missing-synchronized-decorator/index.html">
<meta property="og:site_name" content="song tao blogs">
<meta property="og:description" content="本系列 blog 与 python wrat 模块相关，深入介绍了 Python 装饰器，猴子补订等相关内容，翻译于 https://github.com/GrahamDumpleton/wrapt/tree/master/blog  本篇内容: 使用通用装饰器接口实现类似 Java 的 synchronized 同步原语">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-05-30T09:16:38.339Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="07 The missing @synchronized decorator">
<meta name="twitter:description" content="本系列 blog 与 python wrat 模块相关，深入介绍了 Python 装饰器，猴子补订等相关内容，翻译于 https://github.com/GrahamDumpleton/wrapt/tree/master/blog  本篇内容: 使用通用装饰器接口实现类似 Java 的 synchronized 同步原语">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/05/26/wrapt/07-the-missing-synchronized-decorator/"/>





  <title>07 The missing @synchronized decorator | song tao blogs</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">song tao blogs</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">漫步在大陆上的海龟</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/26/wrapt/07-the-missing-synchronized-decorator/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="song tao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="song tao blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">07 The missing @synchronized decorator</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-26T10:54:03+08:00">
                2018-05-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/函数装饰器/" itemprop="url" rel="index">
                    <span itemprop="name">函数装饰器</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/函数装饰器/猴子补订/" itemprop="url" rel="index">
                    <span itemprop="name">猴子补订</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/函数装饰器/猴子补订/wrapt/" itemprop="url" rel="index">
                    <span itemprop="name">wrapt</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>本系列 blog 与 python wrat 模块相关，深入介绍了 Python 装饰器，猴子补订等相关内容，<br>翻译于 <a href="https://github.com/GrahamDumpleton/wrapt/tree/master/blog" target="_blank" rel="external">https://github.com/GrahamDumpleton/wrapt/tree/master/blog</a></p>
</blockquote>
<p>本篇内容: 使用通用装饰器接口实现类似 Java 的 synchronized 同步原语<br><a id="more"></a></p>
<h3 id="The-missing-synchronized-decorator"><a href="#The-missing-synchronized-decorator" class="headerlink" title="The missing @synchronized decorator"></a>The missing @synchronized decorator</h3><p>This is the seventh post in my series of blog posts about Python decoratorsand how I believe they are generally poorly implemented. It follows on fromthe previous post titled <a href="06-maintaining-decorator-state-using-a-class.md">Maintaining decorator state using aclass</a>, with the veryfirst post in the series being <a href="01-how-you-implemented-your-python-decorator-is-wrong.md">How you implemented your Python decoratoris wrong</a>.<br><strong>这是Python装饰器系列博客的第七篇</strong></p>
<p>In the previous post I effectively rounded out the discussion on the implementation of the decorator pattern, or at least the key parts that I care to cover at this point. I may expand on a few other things that can be<br>done at a later time.<br><strong>在之前的博客中，我着重讨论了装饰器的实现模式，在接下来的时间我将对此做一些扩展。</strong></p>
<p>At this point I want to start looking at ways this decorator pattern can be used to implement better decorators. For this post I want to look at the <code>@synchronized</code> decorator.<br><strong>我将开始研究如何使用这个装饰模式来实现更好的装饰器。在这篇文章中，将以@synchronized 装饰器为例进行说明。</strong></p>
<p>The concept of the <code>@synchronized</code> decorator originates from Java and theidea of being able to write such a decorator in Python was a bit of aposter child when decorators were first added to Python. Despite this,there is no standard <code>@synchronized</code> decorator in the Python standardlibrary. If this was such a good example of why decorators are so useful,why is this the case?</p>
<p><strong><code>@synchronized</code>装饰器的来自 Java，当装饰器被第一次引进Python 时，它也被作为使用装饰器的经典示例。尽管如此，在Python 标准库中并没有 <code>@synchronized</code>的标准实现。如果它是装饰器如此易用的经典示例，为什么会出现这种情况呢？</strong></p>
<h3 id="Stealing-ideas-from-the-Java-language"><a href="#Stealing-ideas-from-the-Java-language" class="headerlink" title="Stealing ideas from the Java language"></a>Stealing ideas from the Java language</h3><p>The equivalent synchronization primitive from Java comes in two forms. These are synchronized methods and synchronized statements.<br><strong>java 的同步原语有两种形式，分别是同步方法和同步状态</strong></p>
<p>In Java, to make a method synchronized, you simply add the synchronized keyword to its declaration:<br><strong>在Java 中创建同步方法，只需要在其定义时添加synchronized关键字即可。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class SynchronizedCounter &#123;</div><div class="line">    private int c = 0;</div><div class="line">    public synchronized void increment() &#123;</div><div class="line">        c++;</div><div class="line">    &#125;</div><div class="line">    public synchronized void decrement() &#123;</div><div class="line">        c--;</div><div class="line">    &#125;</div><div class="line">    public synchronized int value() &#123;</div><div class="line">        return c;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Making a method synchronized means it is not possible for two invocationsof synchronized methods on the same object to interleave. When one threadis executing a synchronized method for an object, all other threads thatinvoke synchronized methods for the same object block (suspend execution)until the first thread is done with the object.<br><strong>使一个方法同步意味着不可能在同一个对象上同时调用多个同步方法。当一个线程正在执行一个对象的同步方法时，所有其他调用相同对象块的同步方法的线程(暂停执行)直到第一个线程完成对象。</strong></p>
<p>In other words, each instance of the class has an intrinsic lock object and upon entering a method the lock is being acquired, with it subsequently being released when the method returns. The lock is what is called a re-entrant lock, meaning that a thread can while it holds the lock, acquire it again without blocking. This is so that from one synchronized method it is possible to call another synchronized method on the same object.<br><strong>换句话说，类的每个实例都有一个内在的锁对象，并且在进入一个方法时，锁会被获取，当方法返回时它会被释放。锁是所谓的重入锁，这意味着线程可以在它持有锁的同时，再次获得它，而不会阻塞。正因为如此，一个同步的方法可以调用同一个对象上的另一个同步方法。</strong></p>
<p>The second way to create synchronized code in Java is with synchronized statements. Unlike synchronized methods, synchronized statements must specify the object that provides the intrinsic lock:<br><strong>在Java中创建同步代码的第二种方法是同步语句。与同步方法不同，同步语句必须指定提供内在锁的对象</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public void addName(String name) &#123;</div><div class="line">    synchronized(this) &#123;</div><div class="line">        lastName = name;</div><div class="line">        nameCount++;</div><div class="line">    &#125;</div><div class="line">    nameList.add(name);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Of note is that in Java one can use any object as the source of the lock, it is not necessary to create an instance of a specific lock type to synchronize on. If more fined grained locking is required within a class one can simply create or use an existing arbitrary object to synchronize on.<br><strong>值得注意的是，在Java中，可以使用任何对象作为锁的源，不需要创建特定锁类型的实例来同步。如果在类中需要更细粒度的锁，那么可以简单地创建或使用现有的任意对象进行同步。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class MsLunch &#123;</div><div class="line">    private long c1 = 0;</div><div class="line">    private long c2 = 0;</div><div class="line">    private Object lock1 = new Object();</div><div class="line">    private Object lock2 = new Object();</div><div class="line">    public void inc1() &#123;</div><div class="line">        synchronized(lock1) &#123;</div><div class="line">            c1++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    public void inc2() &#123;</div><div class="line">        synchronized(lock2) &#123;</div><div class="line">            c2++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>These synchronization primitives looks relatively simple to use, so how close did people come to actually achieving the level of simplicity by using decorators to do the same in Python.<br><strong>这些同步原语使用起来相对简单，因此，如何才能通过装饰器在Python中让类似操作以同样简单的方式实现呢。</strong></p>
<h3 id="Synchronizing-off-a-thread-mutex"><a href="#Synchronizing-off-a-thread-mutex" class="headerlink" title="Synchronizing off a thread mutex"></a>Synchronizing off a thread mutex</h3><p><strong>同步线程的互斥锁</strong></p>
<p>In Python it isn’t possible to synchronize off an arbitrary object. Instead it is necessary to create a specific lock object which internally holds a thread mutex. Such a lock object provides an acquire() and release() method for manipulating the lock.<br><strong>在Python中，不可能使用任意对象做同步。相反，有必要创建一个特定的锁对象，该对象内部持有一个线程互斥锁。这样的锁对象提供了一个 acquire()和release()方法来操作锁。</strong></p>
<p>Since context managers were introduced to Python however, locks also support being used in conjunction with the with statement. Using this specific feature, the typical recipe given for implementing a @synchronized decorator for Python is:<br><strong>但是，由于上下文管理器被引入到Python中，所以锁也支持与with语句一起使用。使用这个特定的特性，用于实现Python的@synchronized 装饰器的典型实现是:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">def synchronized(lock=None):</div><div class="line">    def _decorator(wrapped):</div><div class="line">        @functools.wraps(wrapped)</div><div class="line">        def _wrapper(*args, **kwargs):</div><div class="line">            with lock:</div><div class="line">                return wrapped(*args, **kwargs)</div><div class="line">        return _wrapper</div><div class="line">    return _decorator</div><div class="line"></div><div class="line">lock = threading.RLock()</div><div class="line"></div><div class="line">@synchronized(lock)</div><div class="line">def function():</div><div class="line">    pass</div></pre></td></tr></table></figure></p>
<p>Using this approach becomes annoying after a while because for every distinct function that needs to be synchronized, you have to first create a companion thread lock to go with it.<br><strong>使用此方法在一段时间后变得很烦人，因为对于需要同步的每个不同的函数，必须首先创建一个线程锁。</strong></p>
<p>The alternative to needing to pass in the lock object each time, is to create one automatically for each use of the decorator.<br><strong>每次需要传入锁对象的替代方法是，为每个装饰器自动创建一个。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">def synchronized(wrapped):</div><div class="line">    lock = threading.RLock()</div><div class="line">    @functools.wraps(wrapped)</div><div class="line">    def _wrapper(*args, **kwargs):</div><div class="line">        with lock:</div><div class="line">            return wrapped(*args, **kwargs)</div><div class="line">    return _wrapper</div><div class="line"></div><div class="line">@synchronized</div><div class="line">def function():</div><div class="line">    pass</div></pre></td></tr></table></figure>
<p>We can even use the pattern described previously for allowing optional decorator arguments to permit either approach.<br><strong>我们甚至可以使用前面描述的模式，为每次调用提供一个可选的参数</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">def synchronized(wrapped=None, lock=None):</div><div class="line">    if wrapped is None:</div><div class="line">        return functools.partial(synchronized, lock=lock)</div><div class="line">    if lock is None:</div><div class="line">        lock = threading.RLock()</div><div class="line">    @functools.wraps(wrapped)</div><div class="line">    def _wrapper(*args, **kwargs):</div><div class="line">        with lock:</div><div class="line">            return wrapped(*args, **kwargs)</div><div class="line">    return _wrapper</div><div class="line"></div><div class="line">@synchronized</div><div class="line">def function1():</div><div class="line">    pass</div><div class="line"></div><div class="line">lock = threading.Lock()</div><div class="line"></div><div class="line">@synchronized(lock=lock)</div><div class="line">def function2():</div><div class="line">    pass</div></pre></td></tr></table></figure></p>
<p>Whatever the approach, the decorator being based on a function closure suffers all the problems we have already outlined. The first step we can therefore take is to update it to use our new decorator factory instead.<br><strong>无论方法如何，基于函数闭包的装饰器都会遇到我们已经列出的所有问题。因此，我们可以采取的第一步是使用我们新的装饰器工厂函数替代它。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">def synchronized(wrapped=None, lock=None):</div><div class="line">    if wrapped is None:</div><div class="line">        return functools.partial(synchronized, lock=lock)</div><div class="line"></div><div class="line">    if lock is None:</div><div class="line">        lock = threading.RLock()</div><div class="line"></div><div class="line">    @decorator</div><div class="line">    def _wrapper(wrapped, instance, args, kwargs):</div><div class="line">        with lock:</div><div class="line">            return wrapped(*args, **kwargs)</div><div class="line"></div><div class="line">    return _wrapper(wrapped)</div></pre></td></tr></table></figure>
<p>Because this is using our decorator factory, it also means that the same code is safe to use on instance, class or static methods as well.<br><strong>因为使用了我们的装饰器工厂函数，这意味着相同的代码可以安全的应在实例、类或静态方法上。</strong></p>
<p>Using this on methods of a class though starts to highlight why this simplistic approach isn’t particularly useful. This is because the locking only applies to calls made to the specific method which is wrapped. Plus that it will be across that one method on all instances of the class. This isn’t really want we want and doesn’t mirror how synchronized methods in Java work.<br><strong>需要强调的是在类方法上使用此装饰器看似简单，但并不是很有用。因为锁仅仅对被装饰的方法有用，并且会对类的所有实例在同一方法上施加同步锁。这并不是我们想要的，也不能同java的同步方法相对应。</strong></p>
<p>Reiterating what we are after again, for all instance methods of a specific instance of a class, if they have been decorated as being synchronized, we want them to synchronize off a single lock object associated with the class instance.<br><strong>在次重申我们要实现的目标是，被装饰器标识为同步的所有实例方法，我们希望每个类实例都有一个独立的同步锁来实现实例内的方法同步。<br>(读者注:不同类实例之间不要同步)</strong></p>
<p>Now there have been posts describing how to improve on this in the past, including for example this quite involved attempt. Personally though I find the way in which it is done is quite clumsy and even suspect it isn’t actually thread safe, with a race condition over the creation of some of the locks.<br><strong>过去已经有一些文章描述了如何改进这一点，包括这个很复杂的尝试。个人觉得它的实现方式是相当笨拙的，甚至怀疑它实际上不是线程安全的，因为在创建一些锁的过程中有一个竞争条件。</strong></p>
<p>Because it used function closures and didn’t have our concept of a universal decorator, it was also necessary to create a multitude of different decorators and then try and plaster them together under a single decorator entry point. Obviously, we should now be able to do a lot better than this.<br><strong>因为它使用了函数闭包，并且没有我们的通用装饰器的概念，所以还需要创建大量不同的装饰器，然后在一个装饰器入口点上尝试将它们整合在一起。显然，我们现在应该能够做得更好。</strong></p>
<h3 id="Storing-the-thread-mutex-on-objects"><a href="#Storing-the-thread-mutex-on-objects" class="headerlink" title="Storing the thread mutex on objects"></a>Storing the thread mutex on objects</h3><p>Starting over, lets take a fresh look at how we can manage the thread locks we need to have. Rather than requiring the lock be passed in, or creating it within a function closure which is then available to the nested wrapper, lets try and manage the locks within the wrapper itself.<br><strong>重新开始，让我们重新审视一下如何管理我们需要的线程锁。相对于需要传入锁，或者在函数闭包中创建锁，让我们尝试在包装器本身中的创建和管理锁。</strong></p>
<p>In doing this the issue is where can we store the thread lock. The only options for storing any data between invocations of the wrapper are going to be on the wrapper itself, on the wrapped function object, in the case of wrapping an instance method, on the class instance, or for a class method, on the class.<br><strong>解决这个问题的关键在于我们可以在哪里存储线程锁。在被包装对象调用之间存储任何数据的惟一选项将是被包装对象本身，包括被包装的函数，类实例方法和类方法。</strong></p>
<p>Lets first consider the case of a normal function. In that case what we can do is store the required thread lock on the wrapped function object itself.<br><strong>首先考虑一个正常函数的情况。在这种情况下，我们所能做的就是将所需的线程锁存储在包装的函数对象本身上。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">@decorator</div><div class="line">def synchronized(wrapped, instance, args, kwargs):</div><div class="line">    lock = vars(wrapped).get(&apos;_synchronized_lock&apos;, None)</div><div class="line">    if lock is None:</div><div class="line">        lock = vars(wrapped).setdefault(&apos;_synchronized_lock&apos;, threading.RLock())</div><div class="line">    with lock:</div><div class="line">        return wrapped(*args, **kwargs)</div><div class="line"></div><div class="line">@synchronized</div><div class="line">def function():</div><div class="line">    pass</div><div class="line"></div><div class="line">&gt;&gt;&gt; function()</div><div class="line">&gt;&gt;&gt; function._synchronized_lock</div><div class="line">&lt;_RLock owner=None count=0&gt;</div></pre></td></tr></table></figure>
<p>A key issue we have to deal with in doing this is how to create the thread lock the first time it is required. To do that the first thing we need do is to see if we already have created a thread lock.<br><strong>我们要处理的一个关键问题是如何第一次创建线程锁。为此我们需要做的是查看线程锁是否已被创建。</strong></p>
<p><code>lock = vars(wrapped).get(&#39;_synchronized_lock&#39;, None)</code></p>
<p>If this returns a valid thread lock object we are fine and can continue on to attempt to acquire the lock. If however it didn’t exist we need to create it, but we have to be careful how we do this in order to avoid a race condition when two threads have entered this section of code at the same time and both believe it is responsible for creating the thread lock.<br><strong>如果返回一个有效的线程锁对象，那么我们就可以继续尝试获取锁。如果锁不存在我们需要创建锁,但是我们必需小心避免竞态条件，因为当两个线程同时进入这部分代码时，它们都会判断需要第一次创建锁。</strong></p>
<p>The trick we use to solve this is to use:<br><strong>我们用来解决这个问题的窍门是:</strong></p>
<p><code>lock = vars(wrapped).setdefault(&#39;_synchronized_lock&#39;, threading.RLock())</code></p>
<p>In the case of two threads trying to set the lock at the same time, they will both actually create an instance of a thread lock, but by virtue of using dict.setdefault(), only one of them will win and actually be able to set it to the instance of the thread lock it created.<br><strong>当两个线程同时尝试创建锁时，它们都可能创建一个锁实例，但是由于使用了dict.setdefault()，只会有一个进程会成功。</strong></p>
<p>As dict.setdefault() then returns whichever is the first value to be stored, both threads will then continue on and attempt to acquire the same thread lock object. It doesn’t matter here that one of the thread objects gets thrown away as it will only occur at the time of initialisation and only if there was actually a race to set it.<br><strong>因为 dict.setdefault() 总是返回它第一次存储的值。所以所有的线程都会继续运行并且尝试获取相同的锁对象。其中一个线程对象会被丢弃也不存在任何问题，因为这只会在初始化并出现竞争条件时才会发生。</strong></p>
<p>We have therefore managed to replicate what we had originally, the difference though being that the thread lock is stored on the wrapped function, rather than on the stack of an enclosing function. We still have the issue that every instance method will have a distinct lock.<br><strong>因此，我们已经成功地复制了最初的内容，不同之处在于线程锁存储在被包装的函数上，而不是存储在一个封闭函数的堆栈上。我们仍然有一个问题，即每个实例方法都有一个不同的锁。(而不是一个实例内的所有同步方法共用一个锁)</strong></p>
<p>The simple solution is that we use the fact that this is what we are calling a universal decorator and use the ability to detect in what context the decorator was used.<br><strong>简单的解决方案是利用我们的通用装饰器，它提供了判断装饰器被使用的上下文的能力。</strong></p>
<p>Specifically, what we want to do is detect when we are being used on an instance method or class method, and store the lock on the object passed as the instance argument instead.<br><strong>具体点说，我们需要判断当前是否在装饰一个类方法或实例方法，如果是，则将锁对象存储在 instance 参数上</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">@decorator</div><div class="line">def synchronized(wrapped, instance, args, kwargs):</div><div class="line">    if instance is None:</div><div class="line">        context = vars(wrapped)</div><div class="line">    else:</div><div class="line">        context = vars(instance)</div><div class="line"></div><div class="line">    lock = context.get(&apos;_synchronized_lock&apos;, None)</div><div class="line"></div><div class="line">    if lock is None:</div><div class="line">        lock = context.setdefault(&apos;_synchronized_lock&apos;, threading.RLock())</div><div class="line"></div><div class="line">    with lock:</div><div class="line">        return wrapped(*args, **kwargs)</div><div class="line"></div><div class="line">class Object(object):</div><div class="line"></div><div class="line">    @synchronized</div><div class="line">    def method_im(self):</div><div class="line">        pass</div><div class="line"></div><div class="line">    @synchronized</div><div class="line">    @classmethod</div><div class="line">    def method_cm(cls):</div><div class="line">        pass</div><div class="line"></div><div class="line">o1 = Object()</div><div class="line">o2 = Object()</div><div class="line"></div><div class="line">&gt;&gt;&gt; o1.method_im()</div><div class="line">&gt;&gt;&gt; o1._synchronized_lock</div><div class="line">&lt;_RLock owner=None count=0&gt;</div><div class="line">&gt;&gt;&gt; id(o1._synchronized_lock)</div><div class="line">4386605392</div><div class="line"></div><div class="line">&gt;&gt;&gt; o2.method_im()</div><div class="line">&gt;&gt;&gt; o2._synchronized_lock</div><div class="line">&lt;_RLock owner=None count=0&gt;</div><div class="line">&gt;&gt;&gt; id(o2._synchronized_lock)</div><div class="line">4386605456</div></pre></td></tr></table></figure></p>
<p>This simple change has actually achieved the result we desired. If the synchronized decorator is used on a normal function then the thread lock will be stored on the function itself and it will stand alone and only be synchronized with calls to the same function.<br><strong>这个简单的改变实际上已经达到了我们想要的结果。如果同步的装饰器被用于一个正常的函数，那么线程锁将被存储在函数本身上，并且它将单独存在，并且只在调用相同的函数之间进行同步。</strong></p>
<p>For the case of the instance method, the thread lock will be stored on the instance of the class the instance methods are bound too and any instance methods marked as being synchronized on that class will all synchronize on that single thread lock, thus mimicking how Java behaves.<br><strong>对于实例方法，线程锁将被存储在类的实例上，实例方法会绑定到类，因此在该类上标记为同步的任何实例方法都将在该线程锁上同步，从而模拟Java的行为。</strong></p>
<p>Now what about that class method. In this case the instance argument is actually the class type. If the thread lock is stored on the type, then the result would be that if there were multiple class methods and they were all marked as synchronized, they would exclude each other. The thread lock in this case is distinct from any used by instance methods, but that is also actually what we want.<br><strong>那类方法呢。在这种情况下，instance 参数实际上是类。如果线程锁被存储在类上，那么结果将是，如果有多个类方法，并且它们都被标记为synchronized，那么它们将相互排斥。这种情况下线程锁的使用方式将不同于实例方法，但这实际上也是我们想要的。</strong></p>
<p>Does the code work though for a class method?<br><strong>代码是否对类方法有效?</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; Object.method_cm()</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">  File &quot;test.py&quot;, line 38, in __call__</div><div class="line">    return self.wrapper(self.wrapped, instance, args, kwargs)</div><div class="line">  File &quot;synctest.py&quot;, line 176, in synchronized</div><div class="line">    lock = context.setdefault(&apos;_synchronized_lock&apos;,</div><div class="line">AttributeError: &apos;dictproxy&apos; object has no attribute &apos;setdefault&apos;</div></pre></td></tr></table></figure>
<p>Unfortunately not.<br><strong>很不幸，无效。</strong></p>
<p>The reason this is the case is that the __dict__ of a class type is not a normal dictionary, but a dictproxy. A dictproxy doesn’t share the same methods as a normal dict and in particular, it does not provide the setdefault() method.<br><strong>这种情况的原因是，类__dict__不是一个普通的字典，而是一个dictproxy。一个dictproxy不与普通的dict共享相同的方法，特别是它不提供setdefault()方法。</strong></p>
<p>We therefore need a different way of synchronizing the creation of the thread lock the first time for the case where instance is a class.<br><strong>因此，我们需要一种不同的方法来为类创建同步线程锁。</strong></p>
<p>We also have another issue due to a dictproxy being used. That is that dictproxy doesn’t support item assignment.<br><strong>dictproxy 还导致了另一个问题，即它不支持属性设置</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; vars(Object)[&apos;_synchronized_lock&apos;] = threading.RLock()</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">TypeError: &apos;dictproxy&apos; object does not support item assignment</div></pre></td></tr></table></figure></p>
<p>What it does still support though is attribute assignment.<br><strong>但是类本身支持属性设置。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; setattr(Object, &apos;_synchronized_lock&apos;, threading.RLock())</div><div class="line">&gt;&gt;&gt; Object._synchronized_lock</div><div class="line">&lt;_RLock owner=None count=0&gt;</div></pre></td></tr></table></figure></p>
<p>and since both function objects and class instances do as well, we will need to switch to that method of updating attributes.<br><strong>由于函数对象和类实例都可以，所以我们需要切换更新属性的方法。</strong></p>
<h3 id="Storing-a-meta-lock-on-the-decorator"><a href="#Storing-a-meta-lock-on-the-decorator" class="headerlink" title="Storing a meta lock on the decorator"></a>Storing a meta lock on the decorator</h3><p>As to an alternative for using dict.setdefault() as an atomic way of setting the lock the first time, what we can do instead is use a meta thread lock stored on the @synchronized decorator itself. With this we still have the issue though of ensuring that only one thread can get to set it. We therefore use dict.setdefault() to control creation of the meta lock at least.<br><strong>作为dict.setdefault()第一次设置锁的原子方式的替代方法，我们可以做的是使用存储在@synchronized 装饰器本身上的元线程锁。由于元线程锁的创建仍存在竞争条件，因此需要使用dict.setdefault()实现元线程锁的原子性创建。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">@decorator</div><div class="line">def synchronized(wrapped, instance, args, kwargs):</div><div class="line">    if instance is None:</div><div class="line">        owner = wrapped</div><div class="line">    else:</div><div class="line">        owner = instance</div><div class="line"></div><div class="line">    lock = vars(owner).get(&apos;_synchronized_lock&apos;, None)</div><div class="line"></div><div class="line">    if lock is None:</div><div class="line">        meta_lock = vars(synchronized).setdefault(</div><div class="line">                &apos;_synchronized_meta_lock&apos;, threading.Lock())</div><div class="line"></div><div class="line">        with meta_lock:</div><div class="line">            lock = vars(owner).get(&apos;_synchronized_lock&apos;, None)</div><div class="line">            if lock is None:</div><div class="line">                lock = threading.RLock()</div><div class="line">                setattr(owner, &apos;_synchronized_lock&apos;, lock)</div><div class="line"></div><div class="line">    with lock:</div><div class="line">        return wrapped(*args, **kwargs)</div></pre></td></tr></table></figure></p>
<p>Note that because of the gap between checking for the existence of the lock for the wrapped function and creating the meta lock, after we have acquired the meta lock we need to once again check to see if the lock exists. This is to handle the case where two threads came into the code at the same time and are racing to be the first to create the lock.<br><strong>请注意，由于对封装函数的锁存在的检查与创建元锁之间的间隙，在我们获得了元锁之后，我们需要再次检查锁是否存在。这是为了避免两个线程同时在尝试创建锁而发生竞争条件。</strong></p>
<p>Now one thing which is very important in this change is that we only swapped to using attribute access for updating the lock for the wrapped function. We have not changed to using getattr() for looking up the lock in the first place and are still looking it up in __dict__ as returned by vars().<br><strong>这里有一点很重要，我们仅仅在更新被包装对象上的锁时使用了属性访问方法。而在查找被包装对象上是否存在锁时，没有使用getattr()方法，而是继续在vars()返回的__dict__中查找它</strong></p>
<p>This is necessary because when getattr() is used on an instance of a class, if that attribute doesn’t exist on the instance of the class, then the lookup rules mean that if the attribute instead existed on the class type, then that would be returned instead.<br><strong>这是必要的，因为当在类的实例上使用getattr()时，如果该属性在类的实例中不存在，那么查找规则意味着如果该属性在类类型上存在，那么将返回该属性。</strong></p>
<p>This would cause problems if a synchronized class method was the first to be called, because it would then leave a lock on the class type. When the instance method was subsequently called, if getattr() were used, it would find the lock on the class type and return it and it would be wrongly used. Thus we stay with looking for the lock via __dict__ as that will only contain what actually exists in the instance.<br><strong>如果一个同步的类方法是第一个被调用的，这会导致问题，因为它会在类类型上留下一个锁。当随后调用实例方法时，如果使用了getattr()，它会找到类类型的锁并返回它，并且会被错误地使用。因此，我们继续通过__dict__寻找锁，因为它只包含实例中实际存在的内容。</strong></p>
<p>With these changes we are now all done and all lock creation is now completely automatic, with an appropriate lock created for the different contexts the decorator is used in.<br><strong>有了这些修改，所有锁的创建都可以自动完成，并在不同的上下文中创建一个适当的锁。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">@synchronized</div><div class="line">def function():</div><div class="line">    pass</div><div class="line"></div><div class="line">class Object(object):</div><div class="line"></div><div class="line">    @synchronized</div><div class="line">    def method_im(self):</div><div class="line">        pass</div><div class="line"></div><div class="line">    @synchronized</div><div class="line">    @classmethod</div><div class="line">    def method_cm(cls):</div><div class="line">        pass</div><div class="line"></div><div class="line">o = Object()</div><div class="line"></div><div class="line">&gt;&gt;&gt; function()</div><div class="line">&gt;&gt;&gt; id(function._synchronized_lock)</div><div class="line">4338158480</div><div class="line"></div><div class="line">&gt;&gt;&gt; Object.method_cm()</div><div class="line">&gt;&gt;&gt; id(Object._synchronized_lock)</div><div class="line">4338904656</div><div class="line"></div><div class="line">&gt;&gt;&gt; o.method_im()</div><div class="line">&gt;&gt;&gt; id(o._synchronized_lock)</div><div class="line">4338904592</div></pre></td></tr></table></figure></p>
<p>The code also works for where @synchronized is used on a static method or class type. In summary, the result for the different places @synchronized can be placed is:<br><strong>代码也适用于在静态方法或类中使用@synchronized。综上所述，@synchronized可以被应用的场景如下:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">@synchronized # lock bound to function1</div><div class="line">def function1():</div><div class="line">    pass</div><div class="line"></div><div class="line">@synchronized # lock bound to function2</div><div class="line">def function2():</div><div class="line">    pass</div><div class="line"></div><div class="line">@synchronized # lock bound to Class</div><div class="line">class Class(object):</div><div class="line"></div><div class="line">    @synchronized # lock bound to instance of Class</div><div class="line">    def function_im(self):</div><div class="line">        pass</div><div class="line"></div><div class="line">    @synchronized # lock bound to Class</div><div class="line">    @classmethod</div><div class="line">    def function_cm(cls):</div><div class="line">        pass</div><div class="line"></div><div class="line">    @synchronized # lock bound to function_sm</div><div class="line">    @staticmethod</div><div class="line">    def function_sm():</div><div class="line">        pass</div></pre></td></tr></table></figure></p>
<h3 id="Implementing-synchronized-statements"><a href="#Implementing-synchronized-statements" class="headerlink" title="Implementing synchronized statements"></a>Implementing synchronized statements</h3><p>So we are all done with implementing support for synchronized methods, but what about those synchronized statements. The goal here is that we want to be able to write:<br><strong>所以，我们已经完成了对同步方法的支持，如何实现同步原语呢。要实现的目标是能按照下面的方式编写代码:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class Object(object):</div><div class="line"></div><div class="line">    @synchronized</div><div class="line">    def function_im_1(self):</div><div class="line">        pass</div><div class="line"></div><div class="line">    def function_im_2(self):</div><div class="line">        with synchronized(self):</div><div class="line">            pass</div></pre></td></tr></table></figure></p>
<p>That is, we need for synchronized to not only be usable as a decorator, but for it also be able to be used as a context manager.<br><strong>也就是说，我们需要 synchronized 装饰器不仅可以用作装饰器，而且还可以作为上下文管理器使用。</strong></p>
<p>In this role, similar to with Java, it would be supplied the object on which synchronization is to occur, which for instance methods would be the self object or instance of the class.<br><strong>在synchronized作为上下文管理器时，类似于Java，需要提供给它执行同步操作的对象，对于实例方法而言，这个对象是 self 参数或者类的实例。</strong></p>
<p>For an explanation of how we can do this though, you will need to wait for the next instalment in this series of posts.<br><strong>为了解释我们如何做到这一点，您将需要等待下一篇文章。</strong></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/python-标准库/" rel="tag"># python 标准库</a>
          
            <a href="/tags/译文/" rel="tag"># 译文</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/05/25/wrapt/06-maintaining-decorator-state-using-a-class/" rel="next" title="06 Maintaining decorator state using a class">
                <i class="fa fa-chevron-left"></i> 06 Maintaining decorator state using a class
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/05/28/wrapt/08-the-synchronized-decorator-as-context-manager/" rel="prev" title="08 The @synchronized decorator as context manager">
                08 The @synchronized decorator as context manager <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.jpg"
               alt="song tao" />
          <p class="site-author-name" itemprop="name">song tao</p>
           
              <p class="site-description motion-element" itemprop="description">有些东西写下来是想告诉自己，别太着急</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">22</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/hotttao" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://weibo.com/2622065365/profile" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                    
                      微博
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#The-missing-synchronized-decorator"><span class="nav-number">1.</span> <span class="nav-text">The missing @synchronized decorator</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Stealing-ideas-from-the-Java-language"><span class="nav-number">2.</span> <span class="nav-text">Stealing ideas from the Java language</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Synchronizing-off-a-thread-mutex"><span class="nav-number">3.</span> <span class="nav-text">Synchronizing off a thread mutex</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Storing-the-thread-mutex-on-objects"><span class="nav-number">4.</span> <span class="nav-text">Storing the thread mutex on objects</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Storing-a-meta-lock-on-the-decorator"><span class="nav-number">5.</span> <span class="nav-text">Storing a meta lock on the decorator</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Implementing-synchronized-statements"><span class="nav-number">6.</span> <span class="nav-text">Implementing synchronized statements</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">song tao</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
