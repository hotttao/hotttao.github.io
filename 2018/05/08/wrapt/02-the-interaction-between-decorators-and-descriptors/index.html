<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="python 标准库,译文," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="本系列 blog 与 python wrat 模块相关，深入介绍了 Python 装饰器，猴子补订等相关内容，翻译于 https://github.com/GrahamDumpleton/wrapt/tree/master/blog  本篇内容: Python 装饰器与描述符协议">
<meta name="keywords" content="python 标准库,译文">
<meta property="og:type" content="article">
<meta property="og:title" content="02 The interaction between decorators and descriptors">
<meta property="og:url" content="http://yoursite.com/2018/05/08/wrapt/02-the-interaction-between-decorators-and-descriptors/index.html">
<meta property="og:site_name" content="song tao blogs">
<meta property="og:description" content="本系列 blog 与 python wrat 模块相关，深入介绍了 Python 装饰器，猴子补订等相关内容，翻译于 https://github.com/GrahamDumpleton/wrapt/tree/master/blog  本篇内容: Python 装饰器与描述符协议">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-05-22T08:41:13.451Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="02 The interaction between decorators and descriptors">
<meta name="twitter:description" content="本系列 blog 与 python wrat 模块相关，深入介绍了 Python 装饰器，猴子补订等相关内容，翻译于 https://github.com/GrahamDumpleton/wrapt/tree/master/blog  本篇内容: Python 装饰器与描述符协议">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/05/08/wrapt/02-the-interaction-between-decorators-and-descriptors/"/>





  <title>02 The interaction between decorators and descriptors | song tao blogs</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">song tao blogs</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">漫步在大陆上的海龟</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/08/wrapt/02-the-interaction-between-decorators-and-descriptors/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="song tao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="song tao blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">02 The interaction between decorators and descriptors</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-08T13:54:03+08:00">
                2018-05-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/函数装饰器/" itemprop="url" rel="index">
                    <span itemprop="name">函数装饰器</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/函数装饰器/猴子补订/" itemprop="url" rel="index">
                    <span itemprop="name">猴子补订</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/函数装饰器/猴子补订/wrapt/" itemprop="url" rel="index">
                    <span itemprop="name">wrapt</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>本系列 blog 与 python wrat 模块相关，深入介绍了 Python 装饰器，猴子补订等相关内容，<br>翻译于 <a href="https://github.com/GrahamDumpleton/wrapt/tree/master/blog" target="_blank" rel="external">https://github.com/GrahamDumpleton/wrapt/tree/master/blog</a></p>
</blockquote>
<p>本篇内容: Python 装饰器与描述符协议<br><a id="more"></a></p>
<h3 id="The-interaction-between-decorators-and-descriptors"><a href="#The-interaction-between-decorators-and-descriptors" class="headerlink" title="The interaction between decorators and descriptors"></a>The interaction between decorators and descriptors</h3><p>This is the second post in my series of blog posts about Python decorators and how I believe they are generally poorly implemented. It follows on from the first post titled How you implemented your Python decorator is wrong<br><strong>这是Python 装饰器系列博客中的第二篇</strong></p>
<p>In that first post I described a number of ways in which the traditional way that Python decorators are implemented is lacking. These were:<br><strong>在第一篇文章中，我描述了一些 Python decorator 传统实现方式存在的缺陷:</strong></p>
<ul>
<li>Preservation of function __name__ and __doc__.<strong>(无法保留函数的自省属性)</strong></li>
<li>Preservation of function argument specification.<strong>(无法获取函数签名信息)</strong></li>
<li>Preservation of ability to get function source code.<strong>(无法获取函数源代码)</strong></li>
<li>Ability to apply decorators on top of other decorators that are implemented as descriptors.<strong>(无法将装饰器应用于另一个为实现描述符的装饰器之上)</strong><br>I described previously how functools.wraps() attempts to solve the problem with preservation of the introspection of the <strong>name</strong> and <strong>doc</strong> attributes, but highlight one case in Python 2 where it can fail, and also note that it doesn’t help with the preservation of the function argument specification nor the ability to access the source code.<br><strong>我说过 functools.wraps()可以帮助解决 <strong>name</strong>, <strong>doc</strong> 自省属性问题，但是在Python2的某种情况下，它会调用失败，并且它不能解决无法获取函数签名信息以及无法自省源代码问题</strong></li>
</ul>
<p>In this post I want to focus mainly on the last of the issues above. That is the interaction between decorators and descriptors, where a function wrapper is applied to a Python object which is actually a descriptor.<br><strong>在本文中，我将着眼于之前阐述的最后一个问题。如何在描述符，和装饰器之间进行交互，即将装饰器应用到一个描述符上</strong></p>
<h3 id="What-are-descriptors"><a href="#What-are-descriptors" class="headerlink" title="What are descriptors?"></a>What are descriptors?</h3><p>I am not going to give an exhaustive analysis of what descriptors are or how they work so if you want to understand them in depth, I would suggest reading up about them elsewhere.<br><strong>我不打算详细解释描述符是什么以及他们的工作原理，如果你想深入了解他们，我建议你去别处找找看</strong></p>
<p>In short though, a descriptor is an object attribute with binding behaviour, one whose attribute access has been overridden by methods in the descriptor protocol. Those methods are <strong>get</strong>(), <strong>set</strong>(), and <strong>delete</strong>(). If any of those methods are defined for an object, it is said to be a descriptor.<br><strong>简而言之，描述符就是存在绑定行文的对象，即属性访问会描述符协议实现的方法所覆盖。这些方法是 <strong>get</strong>(), <strong>set</strong>(), 和 <strong>delete</strong>()。如果任意一中方法在一个对象中被定义，就可以说该对象是一个描述符</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">obj.attribute                  attribute.__get_(obj.type(obj))</div><div class="line">obj.attribute = value    attribute.__set_(obj, value)</div><div class="line">del obj.attribute           attribute.__delete_(obj, value)</div></pre></td></tr></table></figure>
<p>What this means is that if an attribute of a class has any of these special methods defined, when the corresponding operation is performed on that attribute of a class, then those methods will be called instead of the default action. This allows an attribute to override how those operations are going to work.<br><strong>上述描述的是，如果一个类的属性包含上述任意一中特殊方法，当相应操作在类属性被执行时，这些特殊方法将取代默认方法被调用。这就允许一个属性去覆盖将发生默认操作</strong></p>
<p>You may well be thinking that you have never made use of descriptors, but fact is that function objects are actually descriptors. When a function is originally added to a class definition it is as a normal function. When you access that function using a dotted attribute path, you are invoking the <strong>get</strong>() method to bind the function to the class instance, turning it into a bound method of that object.<br><strong>也许你以为你从未使用过描述符，事实上，函数对象就是描述符。当在类中定义函数时，函数就是普通的函数。当你通过’.’属性访问函数时，你将调用函数的 <strong>get</strong>()方法，将函数与一个类实例绑定，进而返回一个绑定方法对象</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">def f(obj): pass</div><div class="line"></div><div class="line">&gt;&gt;&gt; hasattr(f, &apos;__get__&apos;)</div><div class="line">True</div><div class="line"></div><div class="line">&gt;&gt;&gt; f</div><div class="line">&lt;function f at 0x10e963cf8&gt;</div><div class="line"></div><div class="line">&gt;&gt;&gt; obj = object()</div><div class="line"></div><div class="line">&gt;&gt;&gt; f.__get__(obj, type(obj))</div><div class="line">&lt;bound method object.f of &lt;object object at 0x10e8ac0b0&gt;&gt;</div></pre></td></tr></table></figure>
<p>So when calling a method of a class, it is not the <strong>call</strong>() method of the original function object that is called, but the <strong>call</strong>() method of the temporary bound object that is created as a result of accessing the function.<br><strong>所以当你调用类方式时，并不是原始函数的 <strong>call</strong>() 方法被调用，而是访问函数时临时创建的绑定方法对象的<strong>call</strong>()方法被调用</strong></p>
<p>You of course don’t usually see all these intermediary steps and just see the outcome.<br><strong>当然，你通常不会看到所有这些中间步骤，只看到结果。*</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; class Object(object):</div><div class="line">...   def f(self): pass</div><div class="line"></div><div class="line">&gt;&gt;&gt; obj = Object()</div><div class="line"></div><div class="line">&gt;&gt;&gt; obj.f</div><div class="line">&lt;bound method Object.f of &lt;__main__.Object object at 0x10abf29d0&gt;&gt;</div></pre></td></tr></table></figure>
<p>Looking back now at the example given in the first blog post where we wrapped a decorator around a class method, we encountered the error:<br><strong>现在回想一下在第一个博客文章中给出的例子，当我们对一个类方法应用了装饰器时，我们遇到了如下错误:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class Class(object):</div><div class="line">    @function_wrapper</div><div class="line">    @classmethod</div><div class="line">    def cmethod(cls):</div><div class="line">        pass</div><div class="line"></div><div class="line">&gt;&gt;&gt; Class.cmethod()</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;classmethod.py&quot;, line 15, in &lt;module&gt;</div><div class="line">    Class.cmethod()</div><div class="line">  File &quot;classmethod.py&quot;, line 6, in _wrapper</div><div class="line">    return wrapped(*args, **kwargs)</div><div class="line">TypeError: &apos;classmethod&apos; object is not callable</div></pre></td></tr></table></figure></p>
<p>The problem with this example was that for the @classmethod decorator to work correctly, it is dependent on the descriptor protocol being applied properly. This is because the <strong>call</strong>() method only exists on the result returned by <strong>get</strong>() when it is called, there is no <strong>call</strong>() method on the @classmethod decorator itself.<br><strong>示例中的问题在于，@classmethod 描述符对象并没有正确工作，它依赖于描述符协议被正确执行。因为<strong>call</strong>()方法仅存在于<strong>get</strong>()被调用时返回的结果中，而@classmethod描述符本身并没有 <strong>call</strong>()方法</strong></p>
<p>More specifically, the simple type of decorator that people normally use is not itself honouring the descriptor protocol and applying that to the wrapped object to yield the bound function object which should actually be called. Instead it is simply calling the wrapped object directly, which will fail if it doesn’t have a <strong>call</strong>().<br><strong>更具体的说， 人们使用的简单装饰器，并没有对被包装的描述符对象执行描述符协议以产生的一个可调用对象。想反，只是简单的直接调用被包装对象。因为其没有 <strong>call</strong>() 方法，结果当然会失败</strong></p>
<p>Why then does applying a decorator to a normal instance method still work?<br><strong>那为什么将装饰器应用在普通的实例方法上仍然可以运行呢？</strong></p>
<p>This still works because a normal function still has a <strong>call</strong>() method. In bypassing the descriptor protocol of the wrapped function it is calling this. Although the binding protocol is side stepped, things still work out because the wrapper will pass the ‘self’ argument for the instance explicitly as the first argument when calling the original unbound function object.<br><strong>它仍能工作是因为，一个普通函数本身具有<strong>call</strong>()方法。在绕过包装函数的描述符协议时，它调用的是此方法。尽管绑定步骤被跳过，仍能正常工作是因为包装器函数将 self 包含的实例对象通过第一参数显示传递给了原始的未绑定函数对象</strong></p>
<p>For a normal instance method the result in this situation is effectively the same. It only falls apart when the wrapped object, as in the case of @classmethod, are dependent on the descriptor protocol being applied correctly.<br><strong>对于一个普通的实例方法，这种情况下的结果实际上是相同的。只有当被包装的对象(如@classmethod)依赖于正确应用的描述符协议时，它才会崩溃。</strong></p>
<h3 id="Wrappers-as-descriptors"><a href="#Wrappers-as-descriptors" class="headerlink" title="Wrappers as descriptors"></a>Wrappers as descriptors</h3><p>The way to solve this problem where the wrapper is not honouring the descriptor protocol and performing binding on the wrapped object in the case of a method on a class, is for wrappers to also be descriptors.<br><strong>解决包装器不能在类方法执行描述符协议获取绑定对象的方法是，让包装器也成为一个描述符对象</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class bound_function_wrapper(object):</div><div class="line">    def __init__(self, wrapped):</div><div class="line">        self.wrapped = wrapped</div><div class="line">    def __call__(self, *args, **kwargs):</div><div class="line">        return self.wrapped(*args, **kwargs)</div><div class="line"></div><div class="line">class function_wrapper(object):</div><div class="line">    def __init__(self, wrapped):</div><div class="line">        self.wrapped = wrapped</div><div class="line">    def __get__(self, instance, owner):</div><div class="line">        wrapped = self.wrapped.__get__(instance, owner)</div><div class="line">        return bound_function_wrapper(wrapped)</div><div class="line">    def __call__(self, *args, **kwargs):</div><div class="line">        return self.wrapped(*args, **kwargs)</div></pre></td></tr></table></figure></p>
<p>If the wrapper is applied to a normal function, the <strong>call</strong>() method of the wrapper is used. If the wrapper is applied to a method of a class, the <strong>get</strong>() method is called, which returns a new bound wrapper and the <strong>call</strong>() method of that is invoked instead. This allows our wrapper to be used around descriptors as it propagates the descriptor protocol.<br><strong>如果将包装器应用于一个正常的函数，则使用包装器的<strong>call</strong>()方法。如果将包装器应用于类的方法，则调用<strong>get</strong>()方法，该方法返回一个新的绑定包装器，并调用该方法的<strong>call</strong>()方法。这样我们的包装器就可以在描述符的传播过程中使用。</strong></p>
<p>So since using a function closure will ultimately fail if used around a decorator which is implemented as a descriptor, the situation we therefore have is that if we want everything to work, then decorators should always use a class based wrapper, where the class implements the descriptor protocol as shown.<br><strong>因为将装饰器实现为一个描述符对象时，使用闭包总是会失败，因此这种情况下为了让所有的事都能正常工作，我们必需总是使用类实现装饰器。装饰器类将实现描述符协议，如上所式</strong></p>
<p>The question now is how do we address the other issues that were listed.<br><strong>现在的问题是，我们如何解决我们列出的其他问题</strong></p>
<p>We solved naming using functools.wrap()/functools.update_wrapper() before, but what do they do and can we still use them.<br><strong>我们使用functools.wrap()/functools.update_wrapper()解决命名问题，现在我们应该怎么做以便继续使用他们</strong></p>
<p>Well wraps() just uses update_wrapper(), so we just need to look at it.<br><strong>因为 wraps() 内部使用 update_wrapper(),所以我们只需要看看它如何实现</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">WRAPPER_ASSIGNMENTS = (&apos;__module__&apos;,</div><div class="line">       &apos;__name__&apos;, &apos;__qualname__&apos;, &apos;__doc__&apos;,</div><div class="line">       &apos;__annotations__&apos;)</div><div class="line">WRAPPER_UPDATES = (&apos;__dict__&apos;,)</div><div class="line"></div><div class="line">def update_wrapper(wrapper, wrapped,</div><div class="line">        assigned = WRAPPER_ASSIGNMENTS,</div><div class="line">        updated = WRAPPER_UPDATES):</div><div class="line">    wrapper.__wrapped__ = wrapped</div><div class="line">    for attr in assigned:</div><div class="line">        try:</div><div class="line">            value = getattr(wrapped, attr)</div><div class="line">        except AttributeError:</div><div class="line">            pass</div><div class="line">        else:</div><div class="line">            setattr(wrapper, attr, value)</div><div class="line">    for attr in updated:</div><div class="line">        getattr(wrapper, attr).update(</div><div class="line">                getattr(wrapped, attr, &#123;&#125;))</div></pre></td></tr></table></figure>
<p>What is shown here is what is in Python 3.3, although that actually has a bug in it, which is fixed in Python 3.4. :-)<br><strong>如上展示的是Python3.3中的代码，事实上它还存在一个bug，在Python3.4中已经修复</strong></p>
<p>Looking at the body of the function, three things are being done. First off a reference to the wrapped function is saved as <strong>wrapped</strong>. This is the bug, as it should be done last.<br><strong>在函数体中，3件事需要被做。第一件是将被包装函数保存为包装函数的<strong>wrapped</strong>属性。这就是那个bug，因为它应该在最后实现</strong></p>
<p>The second is to copy those attributes such as <strong>name</strong> and <strong>doc</strong>.<br><strong>第二步，复制诸如<strong>name</strong> 和 <strong>doc</strong>属性</strong></p>
<p>Finally the third thing is to copy the contents of <strong>dict</strong> from the wrapped function into the wrapper, which could actually result in quite a lot of objects needing to be copied.<br><strong>最后一步，复制被包装函数<strong>dict</strong>属性值到包装函数，结果是很多对象需要被复制</strong></p>
<p>If we are using a function closure or straight class wrapper this copying is able to be done at the point that the decorator is applied.<br><strong>如果我们使用的是一个函数闭包或直接的类包装器，那么这个复制就可以在decorator应用的时候完成。</strong></p>
<p>With the wrapper being a descriptor though, it technically now also needs to be done in the bound wrapper.<br><strong>当装饰器被实现为描述符时，也需要在 bound wrapper 中完成上述工作</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class bound_function_wrapper(object):</div><div class="line">    def __init__(self, wrapped):</div><div class="line">        self.wrapped = wrapped</div><div class="line">        functools.update_wrapper(self, wrapped)</div><div class="line"></div><div class="line">class function_wrapper(object):</div><div class="line">    def __init__(self, wrapped):</div><div class="line">        self.wrapped = wrapped</div><div class="line">        functools.update_wrapper(self, wrapped)</div></pre></td></tr></table></figure></p>
<p>As the bound wrapper is created every time the wrapper is called for a function bound to a class, this is going to be too slow. We need a more performant way of handling this.<br><strong>因为bound wrapper 在包装器每次被作为类的绑定方法调用时都会被创建，所有将非常慢。我们需要更高效的方式处理它</strong></p>
<h3 id="Transparent-object-proxy"><a href="#Transparent-object-proxy" class="headerlink" title="Transparent object proxy"></a>Transparent object proxy</h3><p>The solution to the performance issue is to use what is called an object proxy. This is a special wrapper class which looks and behaves like what it wraps.<br><strong>性能问题的解决方法是，使用代理对象。这是一个特殊的包装类，因为它的行为跟它包装的东西看起来很像</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class object_proxy(object):</div><div class="line"></div><div class="line">    def __init__(self, wrapped):</div><div class="line">        self.wrapped = wrapped</div><div class="line">        try:</div><div class="line">            self.__name__= wrapped.__name__</div><div class="line">        except AttributeError:</div><div class="line">            pass</div><div class="line"></div><div class="line">    @property</div><div class="line">    def __class__(self):</div><div class="line">        return self.wrapped.__class__</div><div class="line"></div><div class="line">    def __getattr__(self, name):</div><div class="line">        return getattr(self.wrapped, name)</div></pre></td></tr></table></figure>
<p>A fully transparent object proxy is a complicated beast in its own right, so I am going to gloss over the details for the moment and cover it in a separate blog post at some point.<br><strong>一个完全透明的对象代理本身就是一个复杂的怪物，所以我打算暂时把细节掩盖起来，并在一个单独的博客文章中讨论它。</strong></p>
<p>The above example though is a minimal representation of what it does. In practice it actually needs to do a lot more than this though if it is to serve as a general purpose object proxy usable in the more generic use case of monkey patching.<br><strong>上面的例子是它所做事情的最小表示。实际上，它实际上需要做更多的工作，但如果它是一个通用的对象代理，可以在更通用的monkey patching用例中使用。</strong></p>
<p>In short though, it copies limited attributes from the wrapped object to itself, and otherwise uses special methods, properties and <strong>getattr</strong>() to fetch attributes from the wrapped object only when required thereby avoiding the need to copy across lots of attributes which may never actually be accessed.<br><strong>简而言之，它将有限的属性从包装的对象复制到自身，并使用特殊的方法、属性和<strong>getattr</strong>()来从包装对象中获取属性，从而避免需要复制许多可能永远不会被访问的属性。</strong></p>
<p>What we now do is derive our wrapper class from the object proxy and do away with calling update_wrapper().<br><strong>我们现在要做的是从对象代理中派生出包装器类，并取消调用update_wrapper()。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">class bound_function_wrapper(object_proxy):</div><div class="line"></div><div class="line">    def __init__(self, wrapped):</div><div class="line">        super(bound_function_wrapper, self).__init__(wrapped)</div><div class="line"></div><div class="line">    def __call__(self, *args, **kwargs):</div><div class="line">        return self.wrapped(*args, **kwargs)  </div><div class="line"></div><div class="line">class function_wrapper(object_proxy):</div><div class="line"></div><div class="line">    def __init__(self, wrapped):</div><div class="line">       super(function_wrapper, self).__init__(wrapped)</div><div class="line"></div><div class="line">    def __get__(self, instance, owner):</div><div class="line">        wrapped = self.wrapped.__get__(instance, owner)</div><div class="line">        return bound_function_wrapper(wrapped)</div><div class="line"></div><div class="line">    def __call__(self, *args, **kwargs):</div><div class="line">        return self.wrapped(*args, **kwargs)</div></pre></td></tr></table></figure>
<p>In doing this, attributes like <strong>name</strong> and <strong>doc</strong>, when queried from the wrapper, return the values from the wrapped function. We don’t therefore as a result have the problem we did before where details were being returned from the wrapper instead.<br><strong>在这样做的时候，当从包装器中查询像<strong>name</strong>和<strong>doc</strong>这样的属性时，将从被包装函数返回值。因而不会像之前，我们从包装函数返回值而产生问题</strong></p>
<p>Using a transparent object proxy in this way also means that calls like inspect.getargspec() and inspect.getsource() will now work and return what we expect. So we have actually managed to solve those two problems at the same time without any extra effort, which is a bonus.<br><strong>用这种方式使用透明的对象代理也意味着像检查。getargspec()和inspection .getsource()这样的调用将工作并返回我们所期望的。所以我们实际上在没有任何额外努力的情况下同时解决了这两个问题，这是一个额外的好处。</strong></p>
<h3 id="Making-this-all-more-usable"><a href="#Making-this-all-more-usable" class="headerlink" title="Making this all more usable"></a>Making this all more usable</h3><p>Although this pattern addresses the problems which were originally identified, it consists of a lot of boiler plate code. Further, you now have two places in the code where the wrapped function is actually being called where you would need to insert the code to implement what the decorator was intended to do.<br><strong>尽管这种模式解决了最初确定的问题，但它包含了大量的重复样板代码。此外，在现在的代码中有两个位置，调用被包装函数。因而需要在两个地方重复实现包装逻辑</strong></p>
<p>Replicating this every time you need to implement a decorator would therefore be a bit of a pain.<br><strong>因此，每次需要实现一个装饰器时都要复制这一点，因此会有点痛苦。</strong></p>
<p>What we can instead do is wrap this all up and package it up into a decorator factory, thereby avoiding the need for this all to be done manually each time. How to do that will be the subject of the next blog post in this series.<br><strong>我们可以做的是将其打包并打包到一个装饰器工厂函数中，从而避免每次都需要手工完成这一切。如何做到这一点将成为本系列下一篇博客文章的主题。</strong></p>
<p>From that point we can start to look at how we can further improve the functionality and introduce new capabilities which are generally hard to pull off with the way that decorators are normally implemented.<br><strong>从这一点开始，我们可以开始研究如何进一步改进功能，并引入新的功能，这些都是使用常规的装饰器实现方法难以实现的</strong></p>
<p>And before people start to complain that using this pattern is going to be too slow in the general use case, I will also address that in a future post as well, so just hold your complaints for now.<br><strong>在人们开始抱怨使用这个模式在一般用例中会太慢的时候，我也会在以后的文章中提到这一点，所以现在就暂时不要抱怨了。</strong></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/python-标准库/" rel="tag"># python 标准库</a>
          
            <a href="/tags/译文/" rel="tag"># 译文</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/05/04/wrapt/01-how-you-implemented-your-python-decorator-is-wrong/" rel="next" title="01 How you implemented your Python decorator is wrong">
                <i class="fa fa-chevron-left"></i> 01 How you implemented your Python decorator is wrong
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/05/12/wrapt/03-implementing-a-factory-for-creating-decorators/" rel="prev" title="03 Implementing a factory for creating decorators">
                03 Implementing a factory for creating decorators <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.jpg"
               alt="song tao" />
          <p class="site-author-name" itemprop="name">song tao</p>
           
              <p class="site-description motion-element" itemprop="description">有些东西写下来是想告诉自己，别太着急</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">22</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/hotttao" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://weibo.com/2622065365/profile" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                    
                      微博
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#The-interaction-between-decorators-and-descriptors"><span class="nav-number">1.</span> <span class="nav-text">The interaction between decorators and descriptors</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#What-are-descriptors"><span class="nav-number">2.</span> <span class="nav-text">What are descriptors?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Wrappers-as-descriptors"><span class="nav-number">3.</span> <span class="nav-text">Wrappers as descriptors</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Transparent-object-proxy"><span class="nav-number">4.</span> <span class="nav-text">Transparent object proxy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Making-this-all-more-usable"><span class="nav-number">5.</span> <span class="nav-text">Making this all more usable</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">song tao</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
