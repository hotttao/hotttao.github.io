<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="python 标准库,译文," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="本系列 blog 与 python wrat 模块相关，深入介绍了 Python 装饰器，猴子补订等相关内容，翻译于 https://github.com/GrahamDumpleton/wrapt/tree/master/blog  本篇内容: Python 装饰器语法，通过闭包实现装饰器存在的问题">
<meta name="keywords" content="python 标准库,译文">
<meta property="og:type" content="article">
<meta property="og:title" content="01 How you implemented your Python decorator is wrong">
<meta property="og:url" content="http://yoursite.com/2018/05/04/wrapt/01-how-you-implemented-your-python-decorator-is-wrong/index.html">
<meta property="og:site_name" content="song tao blogs">
<meta property="og:description" content="本系列 blog 与 python wrat 模块相关，深入介绍了 Python 装饰器，猴子补订等相关内容，翻译于 https://github.com/GrahamDumpleton/wrapt/tree/master/blog  本篇内容: Python 装饰器语法，通过闭包实现装饰器存在的问题">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-05-22T08:41:08.599Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="01 How you implemented your Python decorator is wrong">
<meta name="twitter:description" content="本系列 blog 与 python wrat 模块相关，深入介绍了 Python 装饰器，猴子补订等相关内容，翻译于 https://github.com/GrahamDumpleton/wrapt/tree/master/blog  本篇内容: Python 装饰器语法，通过闭包实现装饰器存在的问题">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/05/04/wrapt/01-how-you-implemented-your-python-decorator-is-wrong/"/>





  <title>01 How you implemented your Python decorator is wrong | song tao blogs</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">song tao blogs</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">漫步在大陆上的海龟</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/04/wrapt/01-how-you-implemented-your-python-decorator-is-wrong/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="song tao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="song tao blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">01 How you implemented your Python decorator is wrong</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-04T13:54:03+08:00">
                2018-05-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/函数装饰器/" itemprop="url" rel="index">
                    <span itemprop="name">函数装饰器</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/函数装饰器/猴子补订/" itemprop="url" rel="index">
                    <span itemprop="name">猴子补订</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/函数装饰器/猴子补订/wrapt/" itemprop="url" rel="index">
                    <span itemprop="name">wrapt</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>本系列 blog 与 python wrat 模块相关，深入介绍了 Python 装饰器，猴子补订等相关内容，<br>翻译于 <a href="https://github.com/GrahamDumpleton/wrapt/tree/master/blog" target="_blank" rel="external">https://github.com/GrahamDumpleton/wrapt/tree/master/blog</a></p>
</blockquote>
<p>本篇内容: Python 装饰器语法，通过闭包实现装饰器存在的问题<br><a id="more"></a><br><strong>内容摘要</strong>:</p>
<ol>
<li>使用常规的函数闭包，类实现装饰器，无法保留函数自省信息</li>
<li>使用 functools.wraps() 和 functools.update_wrapper() 能保留常规的自省属性，但是存在以下问题<ul>
<li>无法保留函数签名信息</li>
<li>由于 Python2 的bug，无法将装饰器直接应用于类方法和静态方法(导入时即报错)**</li>
<li>Python3 中即便修复了Python2 中的bug，但是由于\@classmethod 返回一个描述符，而非一个直接可调用对象，将装饰器应用于类方法时依旧会报错(导入时正常，运行时异常)**</li>
</ul>
</li>
</ol>
<h2 id="How-you-implemented-your-Python-decorator-is-wrong"><a href="#How-you-implemented-your-Python-decorator-is-wrong" class="headerlink" title="How you implemented your Python decorator is wrong"></a>How you implemented your Python decorator is wrong</h2><p>The rest of the Python community is currently doing lots of navel gazing over the issue of Python 3 adoption and the whole unicode/bytes divide. I am so over that and gave up caring when my will to work on WSGI stuff was leached away by how long it took to get the WSGI specification updated for Python 3.<br><strong>(Python 社区当前的精力集中于 Python3，由于WSGI相关原因，我并没有对此过多的关注)</strong></p>
<p>Instead my current favourite gripe these days is about how people implement Python decorators. Unfortunately, it appears to be a favourite topic for blogging by Python developers. It is like how when WSGI was all the rage and everyone wanted to write their own WSGI server or framework. Now it is like a rite of passage that one must blog about how to implement Python decorators as a way of showing that you understand Python. As such, I get lots of opportunity to grumble and wince. If only they did truly understand what they were describing and what problems exist with the approach they use.<br><strong>(相反，我对于人们怎么使用 Python 装饰器很感兴趣。就像当初 WSGI 大火的时候一样，Python 装饰器成为了众多博客的经典话题。很多人通过 Python 装饰器展现<br>  他们对 Python 的理解。然而很遗憾的是，按照他们所说的使用装饰器的方式存在众多问题)</strong></p>
<p>So what is my gripe then. My gripe is that although one can write a very simple decorator using a function closure, the scope it can be used in is usually limited. The most basic pattern for implementing a Python decorator also breaks various stuff related to introspection.<br>（尽管可以简单通过闭包实现一个装饰器，但是这种方式存在很多局限，这种最单的使用方式也打断了 Python 内部的自省）</p>
<p>Now most people will say who cares, it does the job I want to do and I don’t have time to care whether it is correct in all situations.<br><strong>(大多数人可能会说谁关心呢，只要它按照我预期的方式在工作，我可没有时间关心，它是否在所有情形下都能正常工作)</strong></p>
<p>As people will know from when I did care more about WSGI, I am a pedantic arse though and when one does something, I like to see it done correctly.<br><strong>(我是一个学究式的人，当一个人做某事时，我喜欢看它做的正确)</strong></p>
<p>Besides my overly obsessive personal trait, it actually does also affect me in my day job as well. This is because I write tools which are dependent upon being able to introspect into code and I need the results I get back to be correct. If they aren’t, then the data I generate becomes useless as information can get grouped against the wrong thing.<br><strong>(除了我个人比较执着外，通过闭包创建装饰器的方式的确影响到了我的工作。因为我编写的工具依赖于能够对代码进行内省)</strong></p>
<p>As well as using introspection, I also do lots of evil stuff with monkey patching. As it happens, monkey patching and the function wrappers one applies aren’t much different to decorators, it is just how they get applied which is different. Because though monkey patching entails going in and modifying other peoples code when they were not expecting it, or designing for it, means that when you do go in and wrap a function that how you do it is very important. If you do not do it correctly then you can crash the users application or inadvertently change how it runs.<br><strong>(除了使用内省，我还使用monkey patching(猴子打补丁)。碰巧的是，monkey patching 和通过函数包装一个应用与decorator没有太大区别，只是它们应用的场景不同。因为 monkey patching 会再他人未预期的情况下，进入并修改其他人的代码。所以如果没能以正确的方式使用monkey patching，很可能会使用户应用程序奔溃，或者无意中更改它的运行方式。)</strong></p>
<p>The first thing that is vitally important is preserving introspection for the wrapped function. Another not so obvious thing though is that you need to ensure that you do not mess with how the execution model for the Python object model works.<br><strong>(最重要的是保持对包装函数的内省。另一个不太明显的事情是，你需要完全理解 Python 对象模型的执行方式)</strong></p>
<p>Now I can in my own function wrappers that are used when performing monkey patching ensure that these two requirements are met so as to ensure that the function wrapper is transparent, but it can all fall in a heap when one needs to monkey patch functions which already have other decorators applied.<br><strong>(为了能同时使用函数包装器和猴子补丁，函数包装器必需是透明的，并且内部维护了一个堆，以便多个装饰器，猴子补订能按照预期的顺序执行)</strong></p>
<p>So when you implement a Python decorator and do it poorly it can affect me and what I want to do. If I have to subsequently work around when you do it wrong, I get somewhat annoyed and grumpy as more often than not that entails a lot of pain.<br><strong>(所以当你错误的使用装饰器并影响到我时。我就会变得有些生气和暴躁，因为这通常会带来很多痛苦)</strong></p>
<p>To cover everything there is to know about what is wrong with your typical Python decorators and wrapping of functions, plus how to fix it, will take a lot of explaining, so one blog post isn’t going to be enough. See this blog post therefore as just part one of an extended discussion.<br><strong>(为了涵盖所有的内容，我们需要了解闭包方式的装饰器错误在哪里，以及如何修复它，这需要大量的解释，所以一个博客帖子是不够的。因此，请把这篇博文看作是扩展讨论的一部分。)</strong></p>
<p>For this first instalment I will simply go through the various ways in which your typical Python decorator can cause problems.<br><strong>(在第一期中，我将简单介绍闭包方式的装饰器可能导致的各种问题。)</strong></p>
<h3 id="Basics-of-a-Python-decorator"><a href="#Basics-of-a-Python-decorator" class="headerlink" title="Basics of a Python decorator"></a>Basics of a Python decorator</h3><p>Everyone should know what the Python decorator syntax is.<br><strong>(python 装饰器语法如下)</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@function_wrapper</div><div class="line">def function():</div><div class="line">    pass</div></pre></td></tr></table></figure>
<p>The @ annotation to denote the application of a decorator was only added in Python 2.4. It is actually though only fancy syntactic sugar. It is actually equivalent to writing:and what you would have done prior to Python 2.4.<br><strong>(@ 符应用一个装饰器在Python2.4 中被加入。它仅仅是如下方式的语法糖，并且在 Python2.4 之前，你必须这么做)</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">def function():</div><div class="line">    pass</div><div class="line"></div><div class="line">function = function_wrapper(function)**</div></pre></td></tr></table></figure></p>
<p>The decorator syntax is therefore just a short hand way of being able to apply a wrapper around an existing function, or otherwise modify the existing function in place, while the definition of the function is being setup.<br><strong>(因此，装饰器语法只是一种将包装器应用于现有的函数的简单方式，或者在其他地方修改现有的函数。包装器作用于函数定义完成之后)</strong></p>
<p>What is referred to as monkey patching achieves pretty much the same outcome, the difference being that when monkey patching the wrapper isn’t being applied at the time the definition of the function is being setup, but is applied retrospectively from a different context after the fact.<br><strong>(所谓的“猴子补丁”的实现的效果几乎是相同的，不同的是，猴子补订作用的时间不是函数定义完成之后，而是应用在不同的上下文环境中)</strong><br><strong>(读者理解: 猴子补订在函数导入模块时被应用)</strong></p>
<h3 id="Anatomy-of-a-function-wrapper"><a href="#Anatomy-of-a-function-wrapper" class="headerlink" title="Anatomy of a function wrapper"></a>Anatomy of a function wrapper</h3><p>Although I mentioned using function closures to implement a decorator, to understand how the more generic case of a function wrapper works it is more illustrative to show how to implement it using a class.<br><strong>(虽然我之前提到使用函数闭包实现装饰器，但是能展示它工作原理的更好的示例是使用一个类实现它)</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class function_wrapper(object):</div><div class="line">    def __init__(self, wrapped):</div><div class="line">        self.wrapped = wrapped</div><div class="line">    def __call__(self, *args, **kwargs):</div><div class="line">        return self.wrapped(*args, **kwargs)**</div><div class="line"></div><div class="line">@function_wrapper</div><div class="line">def function():</div><div class="line">    pass</div></pre></td></tr></table></figure>
<p>The class instance in this example is initialised with and records the original function object. When the now wrapped function is called, it is actually the __call__() method of the wrapper object which is invoked. This in turn would then call the original wrapped function.<br><strong>(示例中的类实例被初始化，并记录了被包装函数，当被包装函数被调用时，包装类的 __call__ 方法被调用，并进而调用原始的被包装函数)</strong></p>
<p>Simply passing through the call to the wrapper alone isn’t particularly useful, so normally you would actually want to do some work either before or after the wrapped function is called. Or you may want to modify the input arguments or the result as they pass through the wrapper. This is just a matter of modifying the __call__() method appropriately to do what you want.<br><strong>(简单的传递被包装函数并没有什么作用，所以通常情况下，你可能会再被包装函数被调用之前或之后做一些其他有用的事。比如，修改输入的参数或被包装函数的返回结果。这些只需要你按需适当修改 __call__ 方法即可)</strong></p>
<p>Using a class to implement the wrapper for a decorator isn’t actually that popular. Instead a function closure is more often used. In this case a nested function is used as the wrapper and it is that which is returned by the decorator function. When the now wrapped function is called, the nested function is actually being called. This in turn would again then call the original wrapped function.<br><strong>(使用函数闭包实现一个装饰器，比使用类更加常用。在这个实例中，包装函数创建并返回一个内嵌函数，当被包装函数被调用时，内嵌的函数被调用，进而调用原始的被包装函数)</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">def function_wrapper(wrapped):</div><div class="line">    def _wrapper(*args, **kwargs):</div><div class="line">        return wrapped(*args, **kwargs)**</div><div class="line">    return _wrapper</div><div class="line"></div><div class="line">@function_wrapper</div><div class="line">def function():</div><div class="line">    pass</div></pre></td></tr></table></figure></p>
<p>In this example the nested function doesn’t actually get passed the original wrapped function explicitly. But it will still have access to it via the arguments given to the outer function call. This does away with the need to create a class to hold what was the wrapped function and thus why it is convenient and generally more popular.<br><strong>(在这个实例中，内嵌函数不需要显示获取被包装函数，但是仍然可以通过外部函数访问到它。这和类必需包含被包装函数不同，也是函数闭包更便利常用的原因)</strong></p>
<h3 id="Introspecting-a-function"><a href="#Introspecting-a-function" class="headerlink" title="Introspecting a function"></a>Introspecting a function</h3><p><strong>(内省一个函数)</strong></p>
<p>Now when we talk about functions, we expect them to specify properties which describe them as well as document what they do. These include the __name__ and __doc__ attributes. When we use a wrapper though, this no longer works as we expect as in the case of using a function closure, the details of the nested function are returned.<br><strong>(当我们讨论函数闭包时，我们会预期函数的自省属性和函数的外在表现相一致。这些包括__name__ and __doc__ 属性。但是当使用函数闭包时，原函数的自省属性会被内嵌函数所替代，因为函数闭包返回的是内嵌函数)</strong><br><strong>(函数闭包使的被包装函数自省属性丢失)</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">def function_wrapper(wrapped):</div><div class="line">    def _wrapper(*args, **kwargs):</div><div class="line">        return wrapped(*args, **kwargs)**</div><div class="line">    return _wrapper</div><div class="line"></div><div class="line">@function_wrapper</div><div class="line">def function():</div><div class="line">    pass</div><div class="line"></div><div class="line">&gt;&gt;&gt; print(function.__name__)**</div><div class="line">_wrapper</div></pre></td></tr></table></figure></p>
<p>If we use a class to implement the wrapper, as class instances do not normally have a __name__ attribute, attempting to access the name of the function will actually result in an AttributeError exception.<br><strong>(当使用类实现闭包时，类实例没有 __name__属性，访问此属性时，会导致 AttributeError 异常)</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class function_wrapper(object):</div><div class="line">    def __init__(self, wrapped):</div><div class="line">        self.wrapped = wrapped</div><div class="line">    def __call__(self, *args, **kwargs):</div><div class="line">        return self.wrapped(*args, **kwargs)**</div><div class="line"></div><div class="line">@function_wrapper</div><div class="line">def function():</div><div class="line">    pass</div><div class="line"></div><div class="line">&gt;&gt;&gt; print(function.__name__)**</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">AttributeError: &apos;function_wrapper&apos; object has no attribute &apos;__name__&apos;</div></pre></td></tr></table></figure></p>
<p>The solution here when using a function closure is to copy the attributes of interest from the wrapped function to the nested wrapper function. This will then result in the function name and documentation strings being correct.<br><strong>(此处的解决方式是，在函数闭包内，将被包装函数的内省属性复制到内嵌函数上。这样函数名称和文档字符串属性就能表现正常)</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">def function_wrapper(wrapped):</div><div class="line">    def _wrapper(*args, **kwargs):</div><div class="line">        return wrapped(*args, **kwargs)**</div><div class="line">    _wrapper.__name__ = wrapped.__name__</div><div class="line">    _wrapper.__doc__ = wrapped.__doc__</div><div class="line">    return _wrapper</div><div class="line"></div><div class="line">@function_wrapper</div><div class="line">def function():</div><div class="line">    pass</div><div class="line"></div><div class="line">&gt;&gt;&gt; print(function.__name__)**</div><div class="line">function</div></pre></td></tr></table></figure>
<p>Needing to manually copy the attributes is laborious, and would need to be updated if any further special attributes were added which needed to be copied. For example, we should also copy the __module__ attribute, and in Python 3 the __qualname__ and __annotations__ attributes were added. To aid in getting this right, the Python standard library provides the functools.wraps() decorator which does this task for you.<br><strong>(手动复制属性是费劲的，如果未来扩展了其他自省属性，代码需要被更新。例如需要复制 __module__ 属性，在Python3 中需要复制  __qualname__ 和 __annotations__属性。为了避免这么做，Python 标准库为我们提供了 functools.wraps() 装饰器，完成自省属性的复制)</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">import functools</div><div class="line"></div><div class="line">def function_wrapper(wrapped):</div><div class="line">    @functools.wraps(wrapped)**</div><div class="line">    def _wrapper(*args, **kwargs):</div><div class="line">        return wrapped(*args, **kwargs)**</div><div class="line">    return _wrapper</div><div class="line"></div><div class="line">@function_wrapper</div><div class="line">def function():</div><div class="line">    pass</div><div class="line"></div><div class="line">&gt;&gt;&gt; print(function.__name__)**</div><div class="line">function</div></pre></td></tr></table></figure></p>
<p>If using a class to implement the wrapper, instead of the functools.wraps() decorator, we would use the functools.update_wrapper() function.<br><strong>(使用类实现装饰器时，我们需要使用 functools.update_wrapper() 函数)</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">import functools</div><div class="line"></div><div class="line">class function_wrapper(object):</div><div class="line">    def __init__(self, wrapped):</div><div class="line">        self.wrapped = wrapped</div><div class="line">        functools.update_wrapper(self, wrapped)**</div><div class="line">    def __call__(self, *args, **kwargs):</div><div class="line">        return self.wrapped(*args, **kwargs)**</div></pre></td></tr></table></figure></p>
<p>So we might have a solution to ensuring the function name and any documentation string is correct in the form of functools.wraps(), but actually we don’t and this will not always work as I will show below.<br><strong>(我们或许认为通过 functolls.wraps 函数我们能确保函数的自省属性是正确的，但事实上如我接下来展示的，它并不能一直有效)</strong></p>
<p>Now what if we want to query the argument specification for a function. This also fails and instead of returning the argument specification for the wrapped function, it returns that of the wrapper. In the case of using a function closure, this is the nested function. The decorator is therefore not signature preserving.<br><strong>(假如我们去访问函数的参数信息，返回的将是包装函数的参数信息而不是被包装函数的。即，在使用闭包的方式中，内嵌函数的参数信息被返回。因此包装器没能保留函数签名信息)</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">import inspect</div><div class="line"></div><div class="line">def function_wrapper(wrapped): ...</div><div class="line"></div><div class="line">@function_wrapper</div><div class="line">def function(arg1, arg2): pass</div><div class="line"></div><div class="line">&gt;&gt;&gt; print(inspect.getargspec(function))**</div><div class="line">ArgSpec(args=[], varargs=&apos;args&apos;, keywords=&apos;kwargs&apos;, defaults=None)**</div></pre></td></tr></table></figure></p>
<p>A worse situation again occurs with the class based wrapper. This time we get an exception complaining that the wrapped function isn’t actually a function. As a result it isn’t possible to derive an argument specification at all, even though the wrapped function is actually still callable.<br><strong>(类包装器更加严重，因为会触发异常，并解释称被包装函数不是一个函数。我们完全不能获取函数签名信息，即使被包装函数是可调用的)</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class function_wrapper(object): ...</div><div class="line"></div><div class="line">@function_wrapper</div><div class="line">def function(arg1, arg2): pass</div><div class="line"></div><div class="line">&gt;&gt;&gt; print(inspect.getargspec(function))**</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;...&quot;, line XXX, in &lt;module&gt;</div><div class="line">    print(inspect.getargspec(function))**</div><div class="line">  File &quot;.../inspect.py&quot;, line 813, in getargspec</div><div class="line">    raise TypeError(&apos;&#123;!r&#125; is not a Python function&apos;.format(func))**</div><div class="line">TypeError: &lt;__main__.function_wrapper object at 0x107e0ac90&gt; is not a Python function</div></pre></td></tr></table></figure></p>
<p>Another example of introspection one can do is to use inspect.getsource() to get back the source code related to a function. This also will fail, with it giving the source code for the nested wrapper function in the case of a function closure and again failing outright with an exception in the case of the class based wrapper.<br><strong>(另外一个自省的示例是使用 inspect.getsource() 获取函数源代码。闭包装饰器返回的是内嵌函数的源代码，而类装饰器则会触发异常)</strong></p>
<h3 id="Wrapping-class-methods"><a href="#Wrapping-class-methods" class="headerlink" title="Wrapping class methods"></a>Wrapping class methods</h3><p>Now, as well as normal functions, decorators can also be applied to methods of classes. Python even includes a couple of special decorators called \@classmethod and \@staticmethod for converting normal instance methods into these special method types. Methods of classes do provide a number of potential problems though.<br><strong>(同函数类似，装饰器也可以应用于类方法。Python 包含了两个特殊的装饰器\@classmethod 和 \@staticmethod 将实例方法转换为特殊的类方法。装饰器应用于类方法同样隐含着几个问题)</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class Class(object):</div><div class="line"></div><div class="line">    @function_wrapper</div><div class="line">    def method(self):</div><div class="line">        pass</div><div class="line"></div><div class="line">    @classmethod</div><div class="line">    def cmethod(cls):</div><div class="line">        pass</div><div class="line"></div><div class="line">    @staticmethod</div><div class="line">    def smethod():</div><div class="line">        pass</div></pre></td></tr></table></figure></p>
<p>The first is that even if using functools.wraps() or functools.update_wrapper() in your decorator, when the decorator is applied around \@classmethod or \@staticmethod, it can fail with an exception. This is because the wrappers created by these, do not have some of the attributes being copied.<br><strong>(第一即使使用了 functools.wraps 或者 functools.update_wrapper，当装饰器被用在 \@classmethod or \@staticmethod 上时，仍然会导致异常。这是因为这两个特殊的装饰器没能将一些必要的属性复制过来)</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class Class(object):</div><div class="line">    @function_wrapper</div><div class="line">    @classmethod</div><div class="line">    def cmethod(cls):</div><div class="line">        pass</div><div class="line"></div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 3, in Class</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 2, in wrapper</div><div class="line">  File &quot;.../functools.py&quot;, line 33, in update_wrapper</div><div class="line">    setattr(wrapper, attr, getattr(wrapped, attr))**</div><div class="line">AttributeError: &apos;classmethod&apos; object has no attribute &apos;__module__&apos;</div></pre></td></tr></table></figure>
<p>As it happens, this is a Python 2 bug and it is fixed in Python 3 by ignoring missing attributes.<br><strong>(这是一个Python2 的bug，并在Python3中通过忽略丢失的属性修复了)</strong></p>
<p>Even when we run it under Python 3, we still hit trouble though. This is because both wrapper types assume that the wrapped function is directly callable. This need not actually be the case. A wrapped function can actually be what is called a descriptor, meaning that in order to get back a callable, the descriptor has to be correctly bound to the instance first.<br><strong>(即使我们运行在 Python3 上，我们依然会遇到问题。这是因为所有类型的装饰器都假设被包装函数是直接可调用的。事实上并非如此。一个被包装函数，本质上是一个描述符，即描述符只有在正确绑定了一个实例后，才能被调用)</strong><br><strong>(</strong>读者理解: Python classmethod 装饰器返回一个描述符，这个描述符不是直接可调用的，但是装饰器假设被包装函数直接可调用，因此会出错<strong>)</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class Class(object):</div><div class="line">    @function_wrapper</div><div class="line">    @classmethod</div><div class="line">    def cmethod(cls):</div><div class="line">        pass</div><div class="line"></div><div class="line">&gt;&gt;&gt; Class.cmethod()**</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;classmethod.py&quot;, line 15, in &lt;module&gt;</div><div class="line">    Class.cmethod()**</div><div class="line">  File &quot;classmethod.py&quot;, line 6, in _wrapper</div><div class="line">    return wrapped(*args, **kwargs)**</div><div class="line">TypeError: &apos;classmethod&apos; object is not callable</div></pre></td></tr></table></figure></p>
<h3 id="Simple-does-not-imply-correctness"><a href="#Simple-does-not-imply-correctness" class="headerlink" title="Simple does not imply correctness"></a>Simple does not imply correctness</h3><p>So although the usual way that people implement decorators is simple, that doesn’t mean they are necessarily correct and will always work.<br><strong>(虽然实现一个装饰器很简单，但并不意味着它总是正确并能一直正常运行)</strong></p>
<p>The issues highlighted so far are:<br><strong>(主要问题如下)</strong></p>
<ul>
<li>Preservation of function __name__ and __doc__.(无法保留函数的自省属性)</li>
<li>Preservation of function argument specification.(无法获取函数签名信息)</li>
<li>Preservation of ability to get function source code.(无法获取函数源代码)</li>
<li>Ability to apply decorators on top of other decorators that are implemented as descriptors.(无法将装饰器应用于另一个为实现描述符的装饰器之上)<br>The functools.wraps() function is given as a solution to the first but doesn’t always work, at least in Python 2. It doesn’t help at all though with preserving the introspection of a functions argument specification and ability to get the source code for a function.<br><strong>(functools.wraps 函数可以解决部分第一类问题，但并不是总能正常运行，至少在Pyhton2中如此。也不帮助解决第二类问题和第三类问题)</strong></li>
</ul>
<p>Even if one could solve the introspection problem, the simple decorator implementation that is generally offered up as the way to do things, breaks the execution model for the Python object model, not honouring the descriptor protocol of anything which is wrapped by the decorator.<br><strong>(即使可以解决内省问题，简单的装饰器实现不会遵守被包装对象的描述符协议，因而破坏了Python对象的执行模型)</strong></p>
<p>Third party packages do exist which try and solve these issues, such as the decorator module available on PyPi. This module in particular though only helps with the first two and still has potential issues with how it works that may cause problems when trying to dynamically apply function wrappers via monkey patching.<br><strong>(确实存在第三方包，尝试解决这些问题，例如PyPi上的decorator模块。这个模块虽然对前两类问题有所帮助，但仍然存在一些潜在的问题，当尝试通过猴子补丁动态应用函数包装时，可能会导致问题。)</strong></p>
<p>This doesn’t mean these problems aren’t solvable, and solvable in a way that doesn’t sacrifice performance. In my search at least, I could not actually find any one who has described a comprehensive solution or offered up a package which performs all the required magic so you don’t have to worry about it yourself.<br><strong>(这并不意味着这些问题是不可解决的，而且可以以一种不牺牲性能的方式解决。但是至少在我的搜索中，我没有找到一个全面的解决方案，或者一个能解决所有问题的包)</strong></p>
<p>This blog post is therefore the first step in me explaining how it can be all made to work. I have stated the problems to be solved and in subsequent posts I will explain how they can be solved and what extra capabilities that gives you which enables the ability to write even more magic decorators than what is possible now with traditional ways that decorators have been implemented.<br><strong>(因此，这篇博客文章是我第一步，解释它是如何运作的。我已经说明了要解决的问题，在随后的文章中，我将解释如何解决这些问题，以及提供哪些额外的功能，使您能够编写更多的具有魔力的装饰器)</strong></p>
<p>So stay tuned for the next instalment. Hopefully I can keep the momentum up and keep them coming. Pester me if I don’t.<br><strong>(请继续收看下一期文章。希望我能保持势头，尽快写出接下来的文章。如果没有，就去找我。)</strong></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/python-标准库/" rel="tag"># python 标准库</a>
          
            <a href="/tags/译文/" rel="tag"># 译文</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/09/04/linux_operations/virtualenv/" rel="next" title="virtualenv">
                <i class="fa fa-chevron-left"></i> virtualenv
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/05/08/wrapt/02-the-interaction-between-decorators-and-descriptors/" rel="prev" title="02 The interaction between decorators and descriptors">
                02 The interaction between decorators and descriptors <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.jpg"
               alt="song tao" />
          <p class="site-author-name" itemprop="name">song tao</p>
           
              <p class="site-description motion-element" itemprop="description">有些东西写下来是想告诉自己，别太着急</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">22</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/hotttao" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://weibo.com/2622065365/profile" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                    
                      微博
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#How-you-implemented-your-Python-decorator-is-wrong"><span class="nav-number">1.</span> <span class="nav-text">How you implemented your Python decorator is wrong</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Basics-of-a-Python-decorator"><span class="nav-number">1.1.</span> <span class="nav-text">Basics of a Python decorator</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Anatomy-of-a-function-wrapper"><span class="nav-number">1.2.</span> <span class="nav-text">Anatomy of a function wrapper</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Introspecting-a-function"><span class="nav-number">1.3.</span> <span class="nav-text">Introspecting a function</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Wrapping-class-methods"><span class="nav-number">1.4.</span> <span class="nav-text">Wrapping class methods</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Simple-does-not-imply-correctness"><span class="nav-number">1.5.</span> <span class="nav-text">Simple does not imply correctness</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">song tao</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
