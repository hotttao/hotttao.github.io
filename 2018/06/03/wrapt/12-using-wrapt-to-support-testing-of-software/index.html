<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="python 标准库,译文," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="本系列 blog 与 python wrat 模块相关，深入介绍了 Python 装饰器，猴子补订等相关内容，翻译于 https://github.com/GrahamDumpleton/wrapt/tree/master/blog  本篇内容: 如何将 wrapt 用于测试，和 wrapt 与 mock 实现的对比">
<meta name="keywords" content="python 标准库,译文">
<meta property="og:type" content="article">
<meta property="og:title" content="12 Using wrapt to support testing of software">
<meta property="og:url" content="http://yoursite.com/2018/06/03/wrapt/12-using-wrapt-to-support-testing-of-software/index.html">
<meta property="og:site_name" content="song tao blogs">
<meta property="og:description" content="本系列 blog 与 python wrat 模块相关，深入介绍了 Python 装饰器，猴子补订等相关内容，翻译于 https://github.com/GrahamDumpleton/wrapt/tree/master/blog  本篇内容: 如何将 wrapt 用于测试，和 wrapt 与 mock 实现的对比">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-06-07T11:04:18.347Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="12 Using wrapt to support testing of software">
<meta name="twitter:description" content="本系列 blog 与 python wrat 模块相关，深入介绍了 Python 装饰器，猴子补订等相关内容，翻译于 https://github.com/GrahamDumpleton/wrapt/tree/master/blog  本篇内容: 如何将 wrapt 用于测试，和 wrapt 与 mock 实现的对比">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/06/03/wrapt/12-using-wrapt-to-support-testing-of-software/"/>





  <title>12 Using wrapt to support testing of software | song tao blogs</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">song tao blogs</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">漫步在大陆上的海龟</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/03/wrapt/12-using-wrapt-to-support-testing-of-software/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="song tao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="song tao blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">12 Using wrapt to support testing of software</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-03T10:54:03+08:00">
                2018-06-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/函数装饰器/" itemprop="url" rel="index">
                    <span itemprop="name">函数装饰器</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/函数装饰器/猴子补订/" itemprop="url" rel="index">
                    <span itemprop="name">猴子补订</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/函数装饰器/猴子补订/wrapt/" itemprop="url" rel="index">
                    <span itemprop="name">wrapt</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>本系列 blog 与 python wrat 模块相关，深入介绍了 Python 装饰器，猴子补订等相关内容，<br>翻译于 <a href="https://github.com/GrahamDumpleton/wrapt/tree/master/blog" target="_blank" rel="external">https://github.com/GrahamDumpleton/wrapt/tree/master/blog</a></p>
</blockquote>
<p>本篇内容: 如何将 wrapt 用于测试，和 wrapt 与 mock 实现的对比<br><a id="more"></a></p>
<h3 id="Using-wrapt-to-support-testing-of-software"><a href="#Using-wrapt-to-support-testing-of-software" class="headerlink" title="Using wrapt to support testing of software"></a>Using wrapt to support testing of software</h3><p>When talking about unit testing in Python, one of the more popular packages used to assist in that task is the Mock package. I will no doubt be labelled as a heretic but when I have tried to use it for things it just doesn’t seem to sit right with my way of thinking.<br><strong>在Python中讨论单元测试时，用于辅助该任务的比较流行的包之一是 mock 包。毫无疑问，我会被贴上异教徒的标签，但当我试图用它来做一些事情时，它似乎并不符合我的思维方式。</strong></p>
<p>It may also just be that what I am trying to apply it to isn’t a good fit. In what I want to test it usually isn’t so much that I want to mock out lower layers, but more that I simply want to validate data being passed through to the next layer or otherwise modify results. In other words I usually still need the system as a whole to function end to end and possibly over an extended time.<br><strong>也可能只是我试图应用它的东西不太适合。在我想要测试的内容中，通常我不仅想要模拟更低的层，而且我想要验证传递到下一层的数据，或者修改结果。换句话说，我通常仍然需要系统作为一个整体来结束，并可能在很长一段时间内。</strong></p>
<p>So for the more complex testing I need to do I actually keep falling back on the monkey patching capabilities of wrapt. It may well just be that since I wrote wrapt that I am more familiar with its paradigm, or that I prefer the more explicit way that wrapt requires you to do things. Either way, for me at least wrapt helps me to get the job done quicker.<br><strong>因此，对于我需要做的更复杂的测试，我实际上一直在依靠wrapt的猴子补丁功能。很有可能，因为我写了wrapt，我更熟悉它的范例，或者我更倾向于更明确的方式，而wrapt要求你做一些事情。不管怎样，至少对我来说，wrapt能帮助我更快地完成工作。</strong></p>
<p>To explain a bit more about the monkey patching capabilities of wrapt, I am in this blog post going to show how some of the things you can do in Mock you can do with wrapt. Just keep in mind that I am an absolute novice when it comes to Mock and so I could also just be too dumb to understand how to use it properly for what I want to do easily.<br><strong>为了进一步解释wrapt的猴子补丁功能，我在这篇博客文章中向大家展示了用wrapt模块实现部分 Mock 包的功能。只要记住，对于Mock模块我是一个绝对的新手，也可能也我太笨了，不能理解如何正确简单地使用它来做我想做的事情。</strong></p>
<h3 id="Return-values-and-side-effects"><a href="#Return-values-and-side-effects" class="headerlink" title="Return values and side effects"></a>Return values and side effects</h3><p>If one is using Mock and you want to temporarily override the value returned by a method of a class when called, one way is to use:<br><strong>如果你正在使用Mock，并且希望在调用时临时覆盖类的方法返回的值，一种方法是:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">from mock import Mock, patch</div><div class="line"></div><div class="line">class ProductionClass(object):</div><div class="line">    def method(self, a, b, c, key):</div><div class="line">        print a, b, c, key</div><div class="line"></div><div class="line">@patch(__name__+&apos;.ProductionClass.method&apos;, return_value=3)</div><div class="line">def test_method(mock_method):</div><div class="line">    real = ProductionClass()</div><div class="line">    result = real.method(3, 4, 5, key=&apos;value&apos;)</div><div class="line">    mock_method.assert_called_with(3, 4, 5, key=&apos;value&apos;)</div><div class="line">    assert result == 3</div></pre></td></tr></table></figure></p>
<p>With what I have presented so far of the wrapt package, an equivalent way of doing this would be:<br><strong>就我迄今为止提出的wrapt包而言，一种类似的做法是:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">from wrapt import patch_function_wrapper</div><div class="line"></div><div class="line">class ProductionClass(object):</div><div class="line">    def method(self, a, b, c, key):</div><div class="line">        print a, b, c, key</div><div class="line"></div><div class="line">@patch_function_wrapper(__name__, &apos;ProductionClass.method&apos;)</div><div class="line">def wrapper(wrapped, instance, args, kwargs):</div><div class="line">    assert args == (3, 4, 5) and kwargs.get(&apos;key&apos;) == &apos;value&apos;</div><div class="line">    return 3</div><div class="line"></div><div class="line">def test_method():</div><div class="line">    real = ProductionClass()</div><div class="line">    result = real.method(3, 4, 5, key=&apos;value&apos;)</div><div class="line">    assert result == 3</div></pre></td></tr></table></figure>
<p>An issue with this though is that the ‘wrapt.patch_function_wrapper()’ function I previously described applies a permanent patch. This is okay where it does need to survive for the life of the process, but in the case of testing we usually want to only have a patch apply to the single unit test function being run at that time. So the patch should be removed at the end of that test and before the next function is called.<br><strong>不过，这里的一个问题是，我前面描述的“wrapt.patch_function_wrapper()”函数应用了一个永久补丁。在这个过程的生命周期中，这是可以的，但是在测试的情况下，我们通常希望一个补丁只应用于当时正在运行的单个单元测试函数。因此，补丁应该在测试结束时和调用下一个函数之前应该被删除。</strong></p>
<p>For that scenario, the wrapt package provides an alternate decorator ‘@wrapt.transient_function_wrapper’. This can be used to create a wrapper function that will only be applied for the scope of a specific call that the decorated function is applied to. We can therefore write the above as:<br><strong>对于该场景，wrapt包提供了另一个装饰器“@wrapt.transient_function_wrapper”。用来创建一个包装函数，该函数只应用于修饰函数所应用的特定调用的范围。因此，我们可以把上面写为:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">from wrapt import transient_function_wrapper</div><div class="line"></div><div class="line">class ProductionClass(object):</div><div class="line">    def method(self, a, b, c, key):</div><div class="line">        print a, b, c, key</div><div class="line"></div><div class="line">@transient_function_wrapper(__name__, &apos;ProductionClass.method&apos;)</div><div class="line">def apply_ProductionClass_method_wrapper(wrapped, instance, args, kwargs):</div><div class="line">    assert args == (3, 4, 5) and kwargs.get(&apos;key&apos;) == &apos;value&apos;</div><div class="line">    return 3</div><div class="line"></div><div class="line">@apply_ProductionClass_method_wrapper</div><div class="line">def test_method():</div><div class="line">    real = ProductionClass()</div><div class="line">    result = real.method(3, 4, 5, key=&apos;value&apos;)</div><div class="line">    assert result == 3</div></pre></td></tr></table></figure></p>
<p>Although this example shows how to return a substitute for the method being called, the more typical case is that I still want to call the original wrapped function. Thus, perhaps validating the arguments being passed in or the return value being passed back from the lower layers.<br><strong>尽管这个示例展示了如何返回要调用的方法的替代品，但更典型的情况是，我仍然希望调用原始的包装函数。因此，可能验证传入的参数或从底层返回的返回值。</strong></p>
<p>For this blog post when I tried to work out how to do that with Mock the general approach I came up with was the following.<br><strong>当我尝试用Mock解决这个问题时，我想到的一般方法如下。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">from mock import Mock, patch</div><div class="line"></div><div class="line">class ProductionClass(object):</div><div class="line">    def method(self, a, b, c, key):</div><div class="line">        print a, b, c, key</div><div class="line"></div><div class="line">def wrapper(wrapped):</div><div class="line">    def _wrapper(self, *args, **kwargs):</div><div class="line">        assert args == (3, 4, 5) and kwargs.get(&apos;key&apos;) == &apos;value&apos;</div><div class="line">        return wrapped(self, *args, **kwargs)</div><div class="line">    return _wrapper</div><div class="line"></div><div class="line">@patch(__name__+&apos;.ProductionClass.method&apos;, autospec=True,</div><div class="line">        side_effect=wrapper(ProductionClass.method))</div><div class="line">def test_method(mock_method):</div><div class="line">    real = ProductionClass()</div><div class="line">    result = real.method(3, 4, 5, key=&apos;value&apos;)</div></pre></td></tr></table></figure>
<p>There were two tricks here. The first is the ‘autospec=True’ argument to ‘@Mock.patch’ to have it perform method binding, and the second being the need to capture the original method from the ‘ProductionClass’ before any mock had been applied to it, so I could then in turn call it when the side effect function for the mock was called.<br><strong>这里有两个技巧。第一个是@Mock.path 的 ‘autospec=True’参数’，执行方法绑定，第二个是需要在对它应用任何mock之前从’ProductionClass’捕获原始方法，这样当调用mock的副作用函数时，我就可以反过来调用它。</strong></p>
<p>No doubt someone will tell me that I am doing this all wrong and there is a simpler way, but that is the best I could come up with after 10 minutes of reading the Mock documentation.<br><strong>毫无疑问，有人会告诉我，我做错了，有一种更简单的方法，但这是我在阅读模拟文档10分钟后所能想到的最好的方法。</strong></p>
<p>When using wrapt to do the same thing, what is used is little different to what was used when mocking the return value. This is because the wrapt function wrappers will work with both normal functions or methods and so nothing special has to be done when wrapping methods. Further, when the wrapt wrapper function is called, it is always passed the original function which was wrapped, so no magic is needed to stash that away.<br><strong>当使用wrapt执行相同的操作时，使用的方式与模拟返回值没有什么不同。这是因为wrapt函数包装器能同时适用普通函数或方法，所以在包装方法时不需要额外处理。此外，当调用wrapt包装函数时，它总是传递被包装的原始函数，因此不需要使用任何魔法来隐藏它。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">from wrapt import transient_function_wrapper</div><div class="line"></div><div class="line">class ProductionClass(object):</div><div class="line">    def method(self, a, b, c, key):</div><div class="line">        print a, b, c, key</div><div class="line"></div><div class="line">@transient_function_wrapper(__name__, &apos;ProductionClass.method&apos;)</div><div class="line">def apply_ProductionClass_method_wrapper(wrapped, instance, args, kwargs):</div><div class="line">    assert args == (3, 4, 5) and kwargs.get(&apos;key&apos;) == &apos;value&apos;</div><div class="line">    return wrapped(*args, **kwargs)</div><div class="line"></div><div class="line">@apply_ProductionClass_method_wrapper</div><div class="line">def test_method():</div><div class="line">    real = ProductionClass()</div><div class="line">    result = real.method(3, 4, 5, key=&apos;value&apos;)</div></pre></td></tr></table></figure>
<p>Using this ability to easily intercept a call to perform validation of data being passed, but still call the original, I can relatively easily create a whole bunch of decorators for performing validation on data as is it is passed through different parts of the system. I can then stack up these decorators on any test function that I need to add them to.<br><strong>使用此功能可以轻松地拦截调用来执行传递的数据的验证，但仍然调用原始数据，我可以相对轻松地创建一大堆装饰器，以便对数据执行验证，因为数据可能是通过系统的不同部分传递的。然后，我可以将这些装饰器堆叠在任何需要添加它们的测试函数上。</strong></p>
<h3 id="Wrapping-of-return-values"><a href="#Wrapping-of-return-values" class="headerlink" title="Wrapping of return values"></a>Wrapping of return values</h3><p>The above recipes cover being able to return a fake return value, returning the original, or some slight modification of the original where it is some primitive data type or collection. In some cases though I actually want to put a wrapper around the return value to modify how subsequent code interacts with it.<br><strong>上面的示例包括能够返回一个假的返回值，返回原始值，或者在部分原始数据类型或集合上进行一些轻微的修改。但在某些情况下，我实际上希望在返回值周围放置一个包装器，以修改后续代码与返回值的交互方式。</strong></p>
<p>The first example of this is where the wrapped function returns another function which would then be called by something higher up the call chain. Here I may want to put a wrapper around the returned function to allow me to then intercept when it is called.<br><strong>第一个例子是包装函数返回另一个函数，这个函数将被调用链中更高的函数调用。在这里，我可能想在返回的函数周围放置一个包装器，以便在调用它时拦截它。</strong></p>
<p>In the case of using Mock I would do something like:<br><strong>Mock 包的使用方式:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">from mock import Mock, patch</div><div class="line"></div><div class="line">def function():</div><div class="line">    pass</div><div class="line"></div><div class="line">class ProductionClass(object):</div><div class="line">    def method(self, a, b, c, key):</div><div class="line">        return function</div><div class="line"></div><div class="line">def wrapper2(wrapped):</div><div class="line">    def _wrapper2(*args, **kwargs):</div><div class="line">        return wrapped(*args, **kwargs)</div><div class="line">    return _wrapper2</div><div class="line"></div><div class="line">def wrapper1(wrapped):</div><div class="line">    def _wrapper1(self, *args, **kwargs):</div><div class="line">        func = wrapped(self, *args, **kwargs)</div><div class="line">        return Mock(side_effect=wrapper2(func))</div><div class="line">    return _wrapper1</div><div class="line"></div><div class="line">@patch(__name__+&apos;.ProductionClass.method&apos;, autospec=True,</div><div class="line">        side_effect=wrapper1(ProductionClass.method))</div><div class="line">def test_method(mock_method):</div><div class="line">    real = ProductionClass()</div><div class="line">    func = real.method(3, 4, 5, key=&apos;value&apos;)</div><div class="line">    result = func()</div></pre></td></tr></table></figure></p>
<p>And with wrapt I would instead do:<br><strong>wrapt 包的使用方式:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">from wrapt import transient_function_wrapper, function_wrapper</div><div class="line"></div><div class="line">def function():</div><div class="line">    pass</div><div class="line"></div><div class="line">class ProductionClass(object):</div><div class="line">    def method(self, a, b, c, key):</div><div class="line">        return function</div><div class="line"></div><div class="line">@function_wrapper</div><div class="line">def result_function_wrapper(wrapped, instance, args, kwargs):</div><div class="line">    return wrapped(*args, **kwargs)</div><div class="line"></div><div class="line">@transient_function_wrapper(__name__, &apos;ProductionClass.method&apos;)</div><div class="line">def apply_ProductionClass_method_wrapper(wrapped, instance, args, kwargs):</div><div class="line">    return result_function_wrapper(wrapped(*args, **kwargs))</div><div class="line"></div><div class="line">@apply_ProductionClass_method_wrapper</div><div class="line">def test_method():</div><div class="line">    real = ProductionClass()</div><div class="line">    func = real.method(3, 4, 5, key=&apos;value&apos;)</div><div class="line">    result = func()</div></pre></td></tr></table></figure>
<p>In this example I have used a new decorator called ‘@wrapt.function_wrapper’. I could also have used ‘@wrapt.decorator’ in this example. The ‘@wrapt.function_wrapper’ decorator is actually just a cut down version of ‘@wrapt.decorator’, lacking some of the bells and whistles that one doesn’t generally need when doing explicit monkey patching, but otherwise it can be used in the same way.<br><strong>在本例中，我使用了一个名为“@wrapt.function_wrapper”的新装饰器。在本例中，我还可以使用“@wrapt.decorator”。“@wrapt.function_wrapper’ decorator实际上只是’@wrapt.decorator’的一个简化版本，它缺少一些在做显式的猴子补丁时通常不需要的铃铛和口子，但除此之外，它也可以用同样的方式使用。</strong></p>
<p>I can therefore apply a wrapper around a function returned as a result. I could could even apply the same principal where a function is being passed in as an argument to some other function.<br><strong>因此，我可以对结果返回的函数应用一个包装器。我甚至可以应用相同的原理应用在当函数作为参数传递给另一个函数时。</strong></p>
<p>A different scenario to a function being returned is where an instance of a class is returned. In this case I may want to apply a wrapper around a specific method of just that instance of the class.<br><strong>返回函数的另一个场景是返回类的实例。在这种情况下，我可能想要对类的实例的特定方法应用一个包装器。</strong></p>
<p>With the Mock library it again comes down to using its ‘Mock’ class and having to apply it in different ways to achieve the result you want. I am going to step back from Mock now though and just focus on how one can do things using wrapt.<br><strong>在mock 包中，需要再次使用“Mock”类，并且必须以不同的方式应用它来实现您想要的结果。现在我将不再关注mock，只关注wrapt的实现方式。</strong></p>
<p>So, depending on the requirements there are a couple of ways one could do this with wrapt.<br><strong>所以，根据需求，有几种方法可以用wrapt来实现。</strong></p>
<p>The first approach is to replace the method on the instance directly with a wrapper which encapsulates the original method.<br><strong>第一个方法是用封装原始方法的包装器直接替换实例上的方法。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">from wrapt import transient_function_wrapper, function_wrapper</div><div class="line"></div><div class="line">class StorageClass(object):</div><div class="line">    def run(self):</div><div class="line">        pass</div><div class="line"></div><div class="line">storage = StorageClass()</div><div class="line"></div><div class="line">class ProductionClass(object):</div><div class="line">    def method(self, a, b, c, key):</div><div class="line">        return storage</div><div class="line"></div><div class="line">@function_wrapper</div><div class="line">def run_method_wrapper(wrapped, instance, args, kwargs):</div><div class="line">    return wrapped(*args, **kwargs)</div><div class="line"></div><div class="line">@transient_function_wrapper(__name__, &apos;ProductionClass.method&apos;)</div><div class="line">def apply_ProductionClass_method_wrapper(wrapped, instance, args, kwargs):</div><div class="line">    storage = wrapped(*args, **kwargs)</div><div class="line">    storage.run = run_method_wrapper(storage.run)</div><div class="line">    return storage</div><div class="line"></div><div class="line">@apply_ProductionClass_method_wrapper</div><div class="line">def test_method():</div><div class="line">    real = ProductionClass()</div><div class="line">    data = real.method(3, 4, 5, key=&apos;value&apos;)</div><div class="line">    result = data.run()</div></pre></td></tr></table></figure></p>
<p>This will create the desired result but in this example actually turns out to be a bad way of doing it.<br><strong>这样可以得到想要的结果，但在本例中，实际上是一种糟糕的方法。</strong></p>
<p>The problem in this case is that the object being returned is one which has a life time beyond the test. That is, we are modifying an object stored at global scope and which might be used for a different test. By simply replacing the method on the instance, we have made a permanent change.<br><strong>在这种情况下，问题是返回的对象是一个在测试之外有生命时间的对象。也就是说，我们正在修改一个存储在全局范围内的对象，该对象可能用于其他测试。通过简单地替换实例上的方法，我们进行了永久性的更改。</strong></p>
<p>This would be okay if it was a temporary instance of a class created on demand just for that one call, but not where it is persistent like in this case.<br><strong>如果它是一个仅为一次调用而按需创建的类的临时实例，那么这是可以的，但是在这种情况下，它是持久的。</strong></p>
<p>We can’t therefore modify the instance itself, but need to wrap the instance in some other way to intercept the method call.<br><strong>因此，我们不能修改实例本身，但需要以其他方式封装实例来拦截方法调用。</strong></p>
<p>To do this we make use of what is called an object proxy. This is a special object type which we can create an instance of to wrap another object. When accessing the proxy object, any attempts to access attributes will actually return the attribute from the wrapped object. Similarly, calling a method on the proxy will call the method on the wrapped object.<br><strong>为此，我们使用了所谓的对象代理。这是一个特殊的对象类型，我们可以创建一个实例来包装另一个对象。当访问代理对象时，任何访问属性的尝试都会从包装对象返回属性。类似地，调用代理上的方法将调用包装对象上的方法。</strong></p>
<p>Having a distinct proxy object though allows us to change the behaviour on the proxy object and so change how code interacts with the wrapped object. We can therefore avoid needing to change the original object itself.<br><strong>但是，拥有一个不同的代理对象允许我们更改代理对象上的行为，从而更改代码与包装对象的交互方式。因此，我们可以避免更改原始对象本身。</strong></p>
<p>For this example what we can therefore do is:<br><strong>因此，对于这个例子，我们可以做的是:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">from wrapt import transient_function_wrapper, ObjectProxy</div><div class="line"></div><div class="line">class StorageClass(object):</div><div class="line">    def run(self):</div><div class="line">        pass</div><div class="line"></div><div class="line">storage = StorageClass()</div><div class="line"></div><div class="line">class ProductionClass(object):</div><div class="line">    def method(self, a, b, c, key):</div><div class="line">        return storage</div><div class="line"></div><div class="line">class StorageClassProxy(ObjectProxy):</div><div class="line">    def run(self):</div><div class="line">        return self.__wrapped__.run()</div><div class="line"></div><div class="line">@transient_function_wrapper(__name__, &apos;ProductionClass.method&apos;)</div><div class="line">def apply_ProductionClass_method_wrapper(wrapped, instance, args, kwargs):</div><div class="line">    storage = wrapped(*args, **kwargs)</div><div class="line">    return StorageClassProxy(storage)</div><div class="line"></div><div class="line">@apply_ProductionClass_method_wrapper</div><div class="line">def test_method():</div><div class="line">    real = ProductionClass()</div><div class="line">    data = real.method(3, 4, 5, key=&apos;value&apos;)</div><div class="line">    result = data.run()</div></pre></td></tr></table></figure></p>
<p>That is, we define the ‘run()’ method on the proxy object to intercept the call of the same method on the original object. We can then proceed to return fake values, validate arguments or results, or modify them as necessary.<br><strong>也就是说，我们在代理对象上定义“run()”方法，以拦截原始对象上相同方法的调用。然后我们可以继续返回假值，验证参数或结果，或者根据需要修改它们。</strong></p>
<p>With the proxy we can even intercept access to an attribute of the original object by adding a property to the proxy object.<br><strong>通过代理，我们甚至可以通过向代理对象添加属性来拦截对原始对象属性的访问。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">from wrapt import transient_function_wrapper, ObjectProxy</div><div class="line"></div><div class="line">class StorageClass(object):</div><div class="line">    def __init__(self):</div><div class="line">        self.name = &apos;name&apos;</div><div class="line"></div><div class="line">storage = StorageClass()</div><div class="line"></div><div class="line">class ProductionClass(object):</div><div class="line">    def method(self, a, b, c, key):</div><div class="line">        return storage</div><div class="line"></div><div class="line">class StorageClassProxy(ObjectProxy):</div><div class="line">    @property</div><div class="line">    def name(self):</div><div class="line">        return self.__wrapped__.name</div><div class="line"></div><div class="line">@transient_function_wrapper(__name__, &apos;ProductionClass.method&apos;)</div><div class="line">def apply_ProductionClass_method_wrapper(wrapped, instance, args, kwargs):</div><div class="line">    storage = wrapped(*args, **kwargs)</div><div class="line">    return StorageClassProxy(storage)</div><div class="line"></div><div class="line">@apply_ProductionClass_method_wrapper</div><div class="line">def test_method():</div><div class="line">    real = ProductionClass()</div><div class="line">    data = real.method(3, 4, 5, key=&apos;value&apos;)</div><div class="line">    assert data.name == &apos;name&apos;</div></pre></td></tr></table></figure></p>
<h3 id="Building-a-better-Mock"><a href="#Building-a-better-Mock" class="headerlink" title="Building a better Mock"></a>Building a better Mock</h3><p>You might be saying at this point that Mock does a lot more than this. You might even want to point out how Mock can save away details about the call which can be checked later at the level of the test harness, rather than having to resort to raising assertion errors down in the wrappers themselves which can be an issue if code catches the exceptions before you see them.<br><strong>这时你可能会说Mock做的远不止这些。你甚至可能想指出 mock 如何保存了调用的细节。。。。。。。。</strong></p>
<p>This is all true, but the goal at this point for wrapt has been to provide monkey patching mechanisms which do respect introspection, the descriptor protocol and other things besides. That I can use it for the type of testing I do is a bonus.<br><strong>这是正确的，但是wrapt的目标是提供猴补丁机制，它尊重内省、描述符协议和其他东西。我可以将它用于我所做的测试类型，这是一种奖励。</strong></p>
<p>You aren’t limited to using just the basic building blocks themselves though and personally I think wrapt could be a great base on which to build a better Mock library for testing.<br><strong>您不仅限于使用基本的构建块本身，而且我个人认为wrapt可能是构建更好的模拟库进行测试的一个很好的基础。</strong></p>
<p>I therefore leave you with one final example to get you thinking about the ways this might be done if you are partial to the way that Mock does things.<br><strong>因此，我留给你们最后一个例子来让你们思考，如何使用 mock 来实现</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">from wrapt import transient_function_wrapper</div><div class="line"></div><div class="line">class ProductionClass(object):</div><div class="line">    def method(self, a, b, c, key):</div><div class="line">        pass</div><div class="line"></div><div class="line">def patch(module, name):</div><div class="line">    def _decorator(wrapped):</div><div class="line">        class Wrapper(object):</div><div class="line">            @transient_function_wrapper(module, name)</div><div class="line">            def __call__(self, wrapped, instance, args, kwargs):</div><div class="line">                self.args = args</div><div class="line">                self.kwargs = kwargs</div><div class="line">                return wrapped(*args, **kwargs)</div><div class="line">        wrapper = Wrapper()</div><div class="line">        @wrapper</div><div class="line">        def _wrapper():</div><div class="line">            return wrapped(wrapper)</div><div class="line">        return _wrapper</div><div class="line">    return _decorator</div><div class="line"></div><div class="line">@patch(__name__, &apos;ProductionClass.method&apos;)</div><div class="line">def test_method(mock_method):</div><div class="line">    real = ProductionClass()</div><div class="line">    result = real.method(3, 4, 5, key=&apos;value&apos;)</div><div class="line">    assert real.method.__name__ == &apos;method&apos;</div><div class="line">    assert mock_method.args == (3, 4, 5)</div><div class="line">    assert mock_method.kwargs.get(&apos;key&apos;) == &apos;value&apos;</div></pre></td></tr></table></figure></p>
<p>So that is a quick run down of the main parts of the functionality provided by wrapt for doing monkey patching. There are a few others things, but that is in the main all you usually require. I use monkey patching for actually adding instrumentation into existing code to support performance monitoring, but I have shown here how the same techniques can be used in writing tests for your code as an alternative to a package like Mock.<br><strong>这是 wrapt 包实现猴子补丁的概览。还有一些其他的东西，但这是核心部分。我使用猴子补丁将工具添加到现有代码中以支持性能监视，但是我在这里展示了如何将相同的技术用于编写代码测试，以替代Mock等包。</strong></p>
<p>As I mentioned in my previous post though, one of the big problems with monkey patching is the order in which modules get imported relative to when the monkey patching is done. I will talk more about that issue in the next post.<br><strong>正如我在上一篇文章中提到的，猴子补丁的一个主要问题是模块的导入结果与打补丁完成的时间相关。我将在下一篇文章中进一步讨论这个问题。</strong></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/python-标准库/" rel="tag"># python 标准库</a>
          
            <a href="/tags/译文/" rel="tag"># 译文</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/06/02/wrapt/11-safely-applying-monkey-patches-in-python/" rel="next" title="11 Safely applying monkey patches in Python">
                <i class="fa fa-chevron-left"></i> 11 Safely applying monkey patches in Python
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/06/04/wrapt/13-ordering-issues-when-monkey-patching-in-python/" rel="prev" title="13 Ordering issues when monkey patching in Python">
                13 Ordering issues when monkey patching in Python <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.jpg"
               alt="song tao" />
          <p class="site-author-name" itemprop="name">song tao</p>
           
              <p class="site-description motion-element" itemprop="description">有些东西写下来是想告诉自己，别太着急</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">22</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/hotttao" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://weibo.com/2622065365/profile" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                    
                      微博
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Using-wrapt-to-support-testing-of-software"><span class="nav-number">1.</span> <span class="nav-text">Using wrapt to support testing of software</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Return-values-and-side-effects"><span class="nav-number">2.</span> <span class="nav-text">Return values and side effects</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Wrapping-of-return-values"><span class="nav-number">3.</span> <span class="nav-text">Wrapping of return values</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Building-a-better-Mock"><span class="nav-number">4.</span> <span class="nav-text">Building a better Mock</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">song tao</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
