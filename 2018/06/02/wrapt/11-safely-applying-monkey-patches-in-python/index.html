<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="python 标准库,译文," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="本系列 blog 与 python wrat 模块相关，深入介绍了 Python 装饰器，猴子补订等相关内容，翻译于 https://github.com/GrahamDumpleton/wrapt/tree/master/blog  本篇内容: 猴子补丁与装饰器的区别，如何使用 wrapt 创建猴子补丁，以及再应用猴子补丁时可能存在的问题">
<meta name="keywords" content="python 标准库,译文">
<meta property="og:type" content="article">
<meta property="og:title" content="11 Safely applying monkey patches in Python">
<meta property="og:url" content="http://yoursite.com/2018/06/02/wrapt/11-safely-applying-monkey-patches-in-python/index.html">
<meta property="og:site_name" content="song tao blogs">
<meta property="og:description" content="本系列 blog 与 python wrat 模块相关，深入介绍了 Python 装饰器，猴子补订等相关内容，翻译于 https://github.com/GrahamDumpleton/wrapt/tree/master/blog  本篇内容: 猴子补丁与装饰器的区别，如何使用 wrapt 创建猴子补丁，以及再应用猴子补丁时可能存在的问题">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-06-06T11:40:43.148Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="11 Safely applying monkey patches in Python">
<meta name="twitter:description" content="本系列 blog 与 python wrat 模块相关，深入介绍了 Python 装饰器，猴子补订等相关内容，翻译于 https://github.com/GrahamDumpleton/wrapt/tree/master/blog  本篇内容: 猴子补丁与装饰器的区别，如何使用 wrapt 创建猴子补丁，以及再应用猴子补丁时可能存在的问题">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/06/02/wrapt/11-safely-applying-monkey-patches-in-python/"/>





  <title>11 Safely applying monkey patches in Python | song tao blogs</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">song tao blogs</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">漫步在大陆上的海龟</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/02/wrapt/11-safely-applying-monkey-patches-in-python/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="song tao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="song tao blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">11 Safely applying monkey patches in Python</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-02T10:54:03+08:00">
                2018-06-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/函数装饰器/" itemprop="url" rel="index">
                    <span itemprop="name">函数装饰器</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/函数装饰器/猴子补订/" itemprop="url" rel="index">
                    <span itemprop="name">猴子补订</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/函数装饰器/猴子补订/wrapt/" itemprop="url" rel="index">
                    <span itemprop="name">wrapt</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>本系列 blog 与 python wrat 模块相关，深入介绍了 Python 装饰器，猴子补订等相关内容，<br>翻译于 <a href="https://github.com/GrahamDumpleton/wrapt/tree/master/blog" target="_blank" rel="external">https://github.com/GrahamDumpleton/wrapt/tree/master/blog</a></p>
</blockquote>
<p>本篇内容: 猴子补丁与装饰器的区别，如何使用 wrapt 创建猴子补丁，以及再应用猴子补丁时可能存在的问题<br><a id="more"></a></p>
<h3 id="Safely-applying-monkey-patches-in-Python"><a href="#Safely-applying-monkey-patches-in-Python" class="headerlink" title="Safely applying monkey patches in Python"></a>Safely applying monkey patches in Python</h3><p>Monkey patching in Python is often see as being one of those things you should never do. Some do regard it as a useful necessity you can’t avoid in order to patch bugs in third party code. Others will argue though that with so much software being Open Source these days that you should simply submit a fix to the upstream package maintainer.<br><strong>通常在Python中永远不应该做的事情之一就是编写猴子补丁。但有些人认为这是一种有用的必需品，你可能无法避免修补第三方代码中的错误。其他人则可能会争辩说，现在有这么多的软件是开源的，所以您应该简单地向上游包维护人员提交一个补丁。</strong></p>
<p>Monkey patching has its uses well beyond just patching bugs though. The two most commonly used forms of monkey patching in Python which you might not even equate with monkey patching are decorators and the use of mocking libraries to assist in performing unit testing. Another not some common case of monkey patching is to add instrumentation to existing Python code in order to add performance monitoring capabilities.<br><strong>猴子补丁除了补丁还有其他用途。在Python中最常用的两种形式的猴子补丁是修饰符和使用模拟库来帮助执行单元测试，甚至你可能不把它与猴子补丁等同起来。另一个不常见的猴子补丁的例子是将插装添加到现有的Python代码中，以添加性能监视功能。</strong></p>
<p>On the issue of decorators I wrote a quite detailed series of blog posts at the start of last year about where decorators can cause problems. The primary problem there was decorators which aren’t implemented in a way which preserve proper introspection capabilities, and which don’t preserve the correct semantics of the Python descriptor protocol when applied to methods of classes.<br><strong>关于装饰器的问题，我在去年年初写了一篇非常详细的博客文章，介绍了装饰器可能会导致什么问题。主要的问题就是，装饰器的实现方式可能没有保留适当的自省能力，当应用于类的方法时，它们可能也没有保留Python描述符协议的正确语义。</strong></p>
<p>When one starts to talk about monkey patching arbitrary code, rather than simply applying decorators to your own code, both of these issues become even more important as you could quite easily interfere with the behaviour of the existing code you are monkey patching in unexpected ways.<br><strong>当人们开始讨论如何修改任意代码，而不是简单地对自己的代码应用装饰器时，这两个问题就变得更加重要了，因为可能很容易地干扰现有代码的行为，或者以意想不到的方式打补丁。</strong></p>
<p>This is especially the case when monkey patching methods of a class. This is because when using decorators they would be applied while the class definition is being constructed. When doing monkey patching you are coming in after the class definition already exists and as a result you have to deal with a number of non obvious problems.<br><strong>典型的案例是，对一个类方法打补丁。与装饰器在类被创建时即运行不同，补丁代码运行时，类已经被创建，因此需要额外处理一些潜在问题。</strong></p>
<p>Now when I went and wrote the blog posts last year on decorators it was effectively the result of what I learnt from implementing the wrapt package. Although that package is known as providing a way for creating well behaved decorators, that wasn’t the primary aim in creating the package. The real reason for creating the package was actually to implement robust mechanisms for monkey patching code. It just so happened that the same underlying principles and mechanism required to safely do monkey patching apply to implementing the function wrappers required for decorators.<br><strong>去年写的博客，实际上是我从执行wrapt包中学到的结果。尽管 wrapt 模块提供了创建装饰器的良好方式，但这并不是创建该包的主要目标。创建wrapt包的真正原因实际上是为猴子补丁代码实现健壮的机制。碰巧，安全执行猴子补丁所需的基本原则和机制也适用于实现装饰器。</strong></p>
<p>What I am going to do with this blog post is start to explain the monkey patching capabilities of the wrapt package.<br><strong>我打算用这篇博文来解释wrapt包的猴补丁功能。</strong></p>
<h3 id="Creating-a-decorator"><a href="#Creating-a-decorator" class="headerlink" title="Creating a decorator"></a>Creating a decorator</h3><p>Before we jump into monkey patching of arbitrary code we first need to recap how the wrapt package could be used to create a decorator. The primary pattern for this was:<br><strong>在开始修改任意代码之前，我们首先需要重新复述一下wrapt包如何用于创建装饰器。主要模式是:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">import wrapt</div><div class="line">import inspect</div><div class="line"></div><div class="line">@wrapt.decorator</div><div class="line">def universal(wrapped, instance, args, kwargs):</div><div class="line">    if instance is None:</div><div class="line">        if inspect.isclass(wrapped):</div><div class="line">            # Decorator was applied to a class.</div><div class="line">            return wrapped(*args, **kwargs)</div><div class="line">        else:</div><div class="line">            # Decorator was applied to a function or staticmethod.</div><div class="line">            return wrapped(*args, **kwargs)</div><div class="line">    else:</div><div class="line">        if inspect.isclass(instance):</div><div class="line">            # Decorator was applied to a classmethod.</div><div class="line">            return wrapped(*args, **kwargs)</div><div class="line">        else:</div><div class="line">            # Decorator was applied to an instancemethod.</div><div class="line">            return wrapped(*args, **kwargs)</div></pre></td></tr></table></figure>
<p>A special feature of the decorators that could be created by the wrapt package was that within the decorator you could determine the context the decorator was used in. That is, whether the decorator was applied to a class, a function or static method, a class method or an instance method.<br><strong>wrapt包可以创建装饰器的一个特殊特性是，在装饰器中，您可以确定装饰器所使用的上下文。也就是说，修饰符是否应用于类、函数或静态方法、类方法或实例方法。</strong></p>
<p>For the case where the decorator was applied to an instance method you are provided a separate argument to the instance of the class. For a class method the separate argument is a reference to the class itself. In both cases these are separated from the ‘args’ and ‘kwargs’ argument so you do not need to fiddle around with extracting it yourself.<br><strong>对于将装饰器应用于实例方法的情况，为类的实例提供了一个单独的参数。对于类方法，单独的参数是对类本身的引用。在这两种情况下，它们都与“args”和“kwargs”参数相分离，因此不需要自己动手提取它们。</strong></p>
<p>A decorator created using wrapt is therefore what I call a universal decorator. In other words, it is possible to create a single decorator implementation that can be used across functions, methods and classes and you can tell at the time of the call the scenario and adjust the behaviour of the decorator accordingly. You no longer have to create multiple implementations of a decorator and ensure that you are using the correct one in each scenario.<br><strong>因此，我将使用wrapt创建的装饰器称为通用装饰器。换句话说，可以创建一个单独的装饰器，它可以跨函数、方法和类使用，可以在不同的调用场景中相应地调整装饰器的行为。而不再需要创建一个装饰器的多个实现，并确保在每个场景中都使用了正确的实现。</strong></p>
<p>Using this decorator is then no different to any other way that decorators would be used.<br><strong>这种装饰器的使用与其他方式创建的装饰器无异。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class Example(object):</div><div class="line"></div><div class="line">    @universal</div><div class="line">    def name(self):</div><div class="line">        return &apos;name&apos;</div></pre></td></tr></table></figure>
<p>For those who have used Python long enough though, you would remember that the syntax for applying a decorator in this way hasn’t always existed. Before the ‘@’ syntax was allowed you could still create and use decorators, but you had to be more explicit in applying them. That is, you had to write:<br><strong>对于那些已经使用Python足够长时间的人来说，应该记得，以这种方式应用装饰器的语法并不总是存在的。在允许使用“@”语法之前，您仍然可以创建和使用装饰器，但在应用它们时必须更加明确。也就是说，你必须写:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class Example(object):</div><div class="line"></div><div class="line">    def name(self):</div><div class="line">        return &apos;name&apos;</div><div class="line">    name = universal(name)</div></pre></td></tr></table></figure>
<p>This can still be done and when written this way it makes it clearer how decorators are in a way a form of monkey patching. This is because often all they are doing is introducing a wrapper around some existing function which allows the call to the original function to be intercepted. The wrapper function then allows you to perform actions either before or after the call to the original function, or allow you to modify the arguments passed to the wrapped function, or otherwise modify the result in some way, or even substitute the result completely.<br><strong>这么写仍然可行，当以这种方式编写时，它使装饰者在某种程度上成为一种猴子补丁。这是因为猴子补丁通常所做的就是在一些现有函数周围引入一个包装器，这样就可以对原始函数进行拦截。然后，包装器函数允许在调用原始函数之前或之后执行操作，或者允许修改传递给包装函数的参数，或者以某种方式修改结果，或者甚至完全替换结果。</strong></p>
<p>What is an important distinction though with decorators is that the wrapper function is being applied at the time the class containing the method is being defined. In contrast more arbitrary monkey patching involves coming in some time later after the class definition has been created and applying the function wrapper at that point.</p>
<p><strong>与装饰器的一个重要区别是，包装器函数在类被创建时即运行。相比之下，猴子补丁更随意，通常在类创建并在应用包装器的一段时间之后再执行。</strong></p>
<p>In effect you are doing:<br><strong>事实上你所作的是:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class Example(object):</div><div class="line">    def name(self):</div><div class="line">        return &apos;name&apos;</div><div class="line"></div><div class="line">Example.name = universal(Example.name)</div></pre></td></tr></table></figure></p>
<p>Although a decorator function created using the wrapt package can be used in this way and will still work as expected, in general I would discourage this pattern for monkey patching an existing method of a class.<br><strong>尽管使用wrapt包创建的装饰器函数可以以这种方式使用，并且仍将按预期工作，但总体而言，我不建议以这种模式，给类的现有方法添加补丁。</strong></p>
<p>This is because it isn’t actually equivalent to doing the same thing within the body of the class when it is defined. In particular the access of ‘Example.name’ actually invokes the descriptor protocol and so is returning an instance method. We can see this by running the code:<br><strong>这是因为当类被定义时，它实际上并不等同于在类的主体内做同样的事情。特别是“Example.name”的访问实际上调用了描述符协议，因此返回了实例方法。我们可以通过运行代码看到这一点:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class Example(object):</div><div class="line">    def name(self):</div><div class="line">        return &apos;name&apos;</div><div class="line">    print type(name)</div><div class="line"></div><div class="line">print type(Example.name)</div><div class="line">which produces:</div><div class="line"></div><div class="line">&lt;type &apos;function&apos;&gt;</div><div class="line">&lt;type &apos;instancemethod&apos;&gt;</div></pre></td></tr></table></figure></p>
<p>In general this may not matter, but I have seen some really strange corner cases where the distinction has mattered. To deal with this therefore, the wrapt package provides an alternate way of applying wrapper functions when doing monkey patching after the fact. In the case of adding wrappers to methods of class, this will use a mechanism which avoids any problems caused by this subtle distinction.<br><strong>一般来说，这可能并不重要，但我看到过一些非常奇怪的情况，它们的区别很重要。因此，为了解决这个问题，wrapt包提供了在事后执行猴子补丁时应用包装函数的另一种方法。在为类的方法添加包装器的情况下，将使用一种机制来避免由这种细微差别所引起的任何问题。</strong></p>
<h3 id="Adding-function-wrappers"><a href="#Adding-function-wrappers" class="headerlink" title="Adding function wrappers"></a>Adding function wrappers</h3><p>For general monkey patching using the wrapt package, rather than using the decorator factory to create a decorator and then apply that to a function, you instead define just the wrapper function and then use a separate function to apply it to the target function.<br><strong>通常情况下，使用wrapt包的猴子补丁创建一个装饰器，而不是使用装饰器工厂函数，只需定义好包装器函数，然后使用一个单独的函数调用将其应用到目标函数即可。</strong></p>
<p>The prototype for the wrapper function is the same as before, but we simply do not apply the ‘@wrapt.decorator’ to it.<br><strong>包装器函数的原型和以前一样，我们只是不使用“@wrapt.decorator”。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">def wrapper(wrapped, instance, args, kwargs):</div><div class="line">    return wrapped(*args, **kwargs)</div></pre></td></tr></table></figure>
<p>To add the wrapper function to a target function we now use the ‘wrapt.wrap_function_wrapper()’ function.<br><strong>为了将包装函数应用于目标函数，我们现在需要使用 wrapt.wrap_function_wrapper() 函数。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class Example(object):</div><div class="line">    def name(self):</div><div class="line">        return &apos;name&apos;</div><div class="line"></div><div class="line">import wrapt</div><div class="line"></div><div class="line">wrapt.wrap_function_wrapper(Example, &apos;name&apos;, wrapper)</div></pre></td></tr></table></figure>
<p>In this case we had the class in the same code file, but we could also have done:<br><strong>在这种情况下，我们将类放在同一个代码文件中，但是我们也可以这样做:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">import example</div><div class="line"></div><div class="line">import wrapt</div><div class="line"></div><div class="line">wrapt.wrap_function_wrapper(example, &apos;Example.name&apos;, wrapper)</div></pre></td></tr></table></figure>
<p>That is, we provide the first argument as the module the target is defined in, with the second argument being the object path to the method we wished to apply the wrapper to.<br><strong>也就是说，我们将目标所在的模块作为第一参数，第二个参数则是我们希望应用包装器的目标方法对象的路径。</strong></p>
<p>We could also skip importing the module altogether and just used the name of the module.<br><strong>我们也可以完全跳过导入模块，只使用模块的名称。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">import wrapt</div><div class="line"></div><div class="line">wrapt.wrap_function_wrapper(&apos;example&apos;, &apos;Example.name&apos;, wrapper)</div></pre></td></tr></table></figure>
<p>Just to prove that just about anything can be simplified by the user of a decorator, we finally could write the whole thing as:<br><strong>为了证明任何东西都可以被使用装饰器的用户简化，我们最终可以把整个东西写成:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">import wrapt</div><div class="line"></div><div class="line">@wrapt.patch_function_wrapper(&apos;example&apos;, &apos;Example.name&apos;)</div><div class="line">def wrapper(wrapped, instance, args, kwargs):</div><div class="line">    return wrapped(*args, **kwargs)</div></pre></td></tr></table></figure>
<p>What will happen in this final example is that as soon as the module this is contained in is imported, the specified target function defined in the ‘example’ module will automatically be monkey patched with the wrapper function.<br><strong>在这个最后的示例中，将会发生的事情是，一旦导入了包含上述代码的模块，在“示例”模块中定义的指定目标函数将自动地使用包装器函数进行修补。</strong></p>
<h3 id="Delayed-patching-is-bad"><a href="#Delayed-patching-is-bad" class="headerlink" title="Delayed patching is bad"></a>Delayed patching is bad</h3><p>Now a very big warning is required at this point. Applying monkey patches after the fact like this will not always work.<br><strong>现在需要着重提醒的是。在上述的操作之后应用补丁并不总是有效的。</strong></p>
<p>The problem is that you are trying to apply a patch after the module has been imported. In this case the ‘wrapt.wrap_function_wrapper()’ call will ensure the module is imported if it wasn’t already, but if the module had already been imported previously by some other part of your code or by a third party package you may have issues.<br><strong>问题的核心在于，是否正在对一个已导入的模块应用补丁。如果模块没有导入，“wrap .wrap_function_wrapper()”调用将确保模块被导入，但是如果模块已经被代码的其他部分或第三方包导入，那么可能就会有问题。</strong></p>
<p>In particular, it the target function you were trying to monkey patch was a normal global function of the module, some other code could have grabbed a direct reference to it by doing:<br><strong>特别的是，您尝试打补丁的目标函数是模块的一个正常的全局函数，其他一些代码可以通过以下步骤直接获取对它的引用:</strong></p>
<p><code>from example import function</code></p>
<p>If you come along later and have:<br><strong>如果你后来来了</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">import wrapt</div><div class="line"></div><div class="line">@wrapt.patch_function_wrapper(&apos;example&apos;, &apos;function&apos;)</div><div class="line">def wrapper(wrapped, instance, args, kwargs):</div><div class="line">    return wrapped(*args, **kwargs)</div></pre></td></tr></table></figure>
<p>then yes the copy of the function contained in the target module will have the wrapper applied, but the reference to it created by the other code will not have the wrapper.<br><strong>最后，目标模块中包含的函数的副本将应用包装器，但是其他代码创建的对它的引用将没有包装器。<br>（读者注: 再打补丁之后导入的目标函数都是被包装的，之前的都是未被包装的）</strong></p>
<p>To ensure that your wrapper is always used in this scenario you would need to patch it not just in the original module, but in any modules where a reference had been stored. This would only be practical in very limited circumstances because in reality you are not going to have any idea where the function might be getting used if it is a common function.<br><strong>为了确保在此场景中始终使用包装器，您不仅需要在原始模块中，而且还需要在存储引用的任何模块中对其进行补丁。这只在非常有限的情况下是可行的因为在现实中，如果函数是一个普通的函数，你将不知道函数在哪里被使用。</strong></p>
<p>This exact problem is one of the shortcomings in the way that monkey patching is applied by packages such as gevent or eventlet. Both these packages do delayed patching of functions and so are sensitive to the order in which modules are imported. To get around this problem at least for modules in the Python standard library, the ‘time.sleep()’ function which they need to monkey patch, has to be patched not only in the ‘time’ module, but also in the ‘threading’ module.<br><strong>这个问题的一个确切体现就是对gevent或eventlet等包打补丁时存在的问题。这两个包都延迟了功能的修补，因此对导入模块的顺序非常敏感。要解决这个问题，至少对于Python标准库中的模块来说，要打补丁的“time.sleep()”函数不仅需要在“time”模块中进行修补，还需要在“threading”模块中进行修补。</strong></p>
<p>There are some techniques one can use to try and avoid such problems but I will defer explaining those to some time down the track.<br><strong>有一些技术可以用来尝试和避免这些问题，但我将把这些解释推迟到以后的一段时间。</strong></p>
<p>Instead for my next blog post I want to move onto some examples for where monkey patching could be used by looking at how wrapt can be used as alternative to packages such as the mock package when doing testing.<br><strong>在我的下一篇博客文章中，我想介绍一些使用使用猴子补丁示例，看看如何在进行测试时使用wrapt替代 mock 模块。</strong></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/python-标准库/" rel="tag"># python 标准库</a>
          
            <a href="/tags/译文/" rel="tag"># 译文</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/06/01/wrapt/10-performance-overhead-when-applying-decorators-to-methods/" rel="next" title="10 Performance overhead when applying decorators to methods">
                <i class="fa fa-chevron-left"></i> 10 Performance overhead when applying decorators to methods
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/06/03/wrapt/12-using-wrapt-to-support-testing-of-software/" rel="prev" title="12 Using wrapt to support testing of software">
                12 Using wrapt to support testing of software <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.jpg"
               alt="song tao" />
          <p class="site-author-name" itemprop="name">song tao</p>
           
              <p class="site-description motion-element" itemprop="description">有些东西写下来是想告诉自己，别太着急</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">22</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/hotttao" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://weibo.com/2622065365/profile" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                    
                      微博
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Safely-applying-monkey-patches-in-Python"><span class="nav-number">1.</span> <span class="nav-text">Safely applying monkey patches in Python</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Creating-a-decorator"><span class="nav-number">2.</span> <span class="nav-text">Creating a decorator</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Adding-function-wrappers"><span class="nav-number">3.</span> <span class="nav-text">Adding function wrappers</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Delayed-patching-is-bad"><span class="nav-number">4.</span> <span class="nav-text">Delayed patching is bad</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">song tao</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
