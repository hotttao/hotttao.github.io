<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="python 标准库,译文," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="本系列 blog 与 python wrat 模块相关，深入介绍了 Python 装饰器，猴子补订等相关内容，翻译于 https://github.com/GrahamDumpleton/wrapt/tree/master/blog  本篇内容: 通过 Python 包模块导入的 .pth 机制实现猴子补丁通过环境变量自动优先导入">
<meta name="keywords" content="python 标准库,译文">
<meta property="og:type" content="article">
<meta property="og:title" content="14 Automatic patching of Python applications">
<meta property="og:url" content="http://yoursite.com/2018/06/07/wrapt/14-automatic-patching-of-python-applications/index.html">
<meta property="og:site_name" content="song tao blogs">
<meta property="og:description" content="本系列 blog 与 python wrat 模块相关，深入介绍了 Python 装饰器，猴子补订等相关内容，翻译于 https://github.com/GrahamDumpleton/wrapt/tree/master/blog  本篇内容: 通过 Python 包模块导入的 .pth 机制实现猴子补丁通过环境变量自动优先导入">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-06-11T03:14:38.146Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="14 Automatic patching of Python applications">
<meta name="twitter:description" content="本系列 blog 与 python wrat 模块相关，深入介绍了 Python 装饰器，猴子补订等相关内容，翻译于 https://github.com/GrahamDumpleton/wrapt/tree/master/blog  本篇内容: 通过 Python 包模块导入的 .pth 机制实现猴子补丁通过环境变量自动优先导入">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/06/07/wrapt/14-automatic-patching-of-python-applications/"/>





  <title>14 Automatic patching of Python applications | song tao blogs</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">song tao blogs</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">漫步在大陆上的海龟</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/07/wrapt/14-automatic-patching-of-python-applications/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="song tao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="song tao blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">14 Automatic patching of Python applications</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-07T10:54:03+08:00">
                2018-06-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/函数装饰器/" itemprop="url" rel="index">
                    <span itemprop="name">函数装饰器</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/函数装饰器/猴子补订/" itemprop="url" rel="index">
                    <span itemprop="name">猴子补订</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/函数装饰器/猴子补订/wrapt/" itemprop="url" rel="index">
                    <span itemprop="name">wrapt</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>本系列 blog 与 python wrat 模块相关，深入介绍了 Python 装饰器，猴子补订等相关内容，<br>翻译于 <a href="https://github.com/GrahamDumpleton/wrapt/tree/master/blog" target="_blank" rel="external">https://github.com/GrahamDumpleton/wrapt/tree/master/blog</a></p>
</blockquote>
<p>本篇内容: 通过 Python 包模块导入的 .pth 机制实现猴子补丁通过环境变量自动优先导入<br><a id="more"></a></p>
<h3 id="Automatic-patching-of-Python-applications"><a href="#Automatic-patching-of-Python-applications" class="headerlink" title="Automatic patching of Python applications"></a>Automatic patching of Python applications</h3><p>In my previous posts on monkey patching I discussed the ordering problem. That is, that the ability to properly monkey patch is dependent on whether we can get in before any other code has already imported the module we want to patch. The specific issue in this case is where other code has imported a reference to a function within a module by name and stored that in it is own namespace. In other words, where it has used:<br><strong>在我之前关于猴子修补的文章中，我讨论了导入次序问题。也就是说，正确使用猴子补丁取决于我们能在任何其他代码导入我们想要修补的模块之前打补丁。在这种情况下的具体问题是，其他代码是否已经按名称导入了对模块内函数的引用，并将其存储在它自己的名称空间中。换句话说，是否已经使用:</strong></p>
<p><code>from module import function</code></p>
<p>If we can’t get in early enough, then it becomes necessary to monkey patch all such uses of a target function as well, which in the general case is impossible as we will not know where the function has been imported.<br><strong>如果我们不能尽早进入，那么就需要对目标函数的所有使用进行monkey patch，这在一般情况下是不可能的，因为我们不知道函数在哪里被导入。</strong></p>
<p>Part of the solution I described for this was to use a post import hook mechanism to allow us to get access to a module for monkey patching before the module is even returned back to any code where it is being imported. This technique is still though dependent on the post import hook mechanism itself being installed before any other code is effectively run. This means having to manually modify the main Python script file for an application, something which isn’t always practical.<br><strong>我所描述的一种解决方案是使用导入后钩子机制，使我们能够在模块被任何代码导入之前访问模块并打补丁。这种技术仍然依赖于在有效运行其他代码之前安装导入后钩子机制本身。这意味着必须手动修改应用程序的主Python脚本文件，这并不总是实用的。</strong></p>
<p>The point of this post is to look at how we can avoid the need to even modify that main Python script file. For this there are a few techniques that could be used. I am going to look at the most evil of those techniques first and then talk about others in a subsequent post.<br><strong>本文的目的是研究如何避免修改主Python脚本文件。为此，可以使用一些技术。我将先看看这些技术中最邪恶的部分，然后在后面的文章中讨论其他的。</strong></p>
<h3 id="Executable-code-in-pth-files"><a href="#Executable-code-in-pth-files" class="headerlink" title="Executable code in .pth files"></a>Executable code in .pth files</h3><p>As part of the Python import system and how it determines what directories are searched for Python modules, there is a mechanism whereby for a package it is possible to install a file with a .pth extension into the Python ‘site-packages’ directory. The actual Python package code itself then might actually be installed in a different location not actually on the Python module search path, most often actually in a versioned subdirectory of the ‘site-packages’ directory. The purpose of the .pth file is to act as a pointer to where the actual code for the Python package lives.<br><strong>作为Python导入系统的一部分，以及在那些目录中搜索Python模块，有一种扩展机制，即可以将一个.pth扩展名文件安装到Python的“site-packages”目录中。用于指明Python包代码并不在默认的Python模块搜索路径上，而是存在于其他位置，通常是在“site-packages”的子目录中。.pth文件的目的是充当指向Python包的实际代码的指针。</strong></p>
<p>In the simple case the .pth file will contain a relative or absolute path name to the name of the actual directory containing the code for the Python package. In the case of it being a relative path name, then it will be taken relative to the directory in which the .pth file is located.<br><strong>在简单的情况下，.pth文件将包含与包含Python包代码的实际目录的名称相关的或绝对的路径名。如果它是一个相对路径名，那么它将相对于.pth文件所在的目录。</strong></p>
<p>With such .pth files in place, when the Python interpreter is initialising itself and setting up the Python module search path, after it has added in all the default directories to be searched, it will look through the site-packages directory and parse each .pth file, adding to the final list of directories to be searched any directories specified within the .pth files.<br><strong>如果使用 .pth,当Python 解释器初始化时，它会创建Python模块的搜索路经，在添加所有默认搜索目录后，它将查找 site-packages内的所有目录，并解析每一个 .pth 文件，并将 .pth 内的目录添加到最后的搜索目录列表中。</strong></p>
<p>Now at one point in the history of Python this .pth mechanism was enhanced to allow for a special case. This special case was that if a line in the .pth file started with import, the line would be executed as Python code instead of simply adding it as a directory to the list of directories to be searched for modules.<br><strong>现在，在Python的历史中，这个.pth机制被增强了，以支持一个特殊的情况。这种特殊情况是，如果.pth文件中的一行从导入开始，那么该行将作为Python代码执行，而不是简单地将其作为目录添加到要搜索模块的目录列表中。</strong></p>
<p>I am told this originally was to allow special startup code to be executed for a module to allow registration of a non standard codec for Unicode. It has though since also been used in the implementation of easy_install and if you have ever run easy-install and looked at the easy-install.pth file in the site-packages directory you will find some code which looks like:<br><strong>我被告知，这最初是为了允许为模块执行特殊的启动代码，以允许为Unicode注册一个非标准的编解码器。不过，它后来也被用于easy_install的实现中，如果您曾经运行过easy-install并查看了site-packages目录中的easy-install.pth文件，您会发现以下代码:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">import sys; sys.__plen = len(sys.path)</div><div class="line">./antigravity-0.1-py2.7.egg</div><div class="line">import sys; new=sys.path[sys.__plen:]; del sys.path[sys.__plen:]; p=getattr(sys,&apos;__egginsert&apos;,0); sys.path[p:p]=new; sys.__egginsert = p+len(new)</div></pre></td></tr></table></figure></p>
<p>So as long as you can fit the code on one line, you can potentially do some quite nasty stuff inside of a .pth file every time that the Python interpreter is run.<br><strong>因此，只要能够将代码放在一行上，就可以在每次运行Python解释器时，在.pth文件中做一些非常古怪的事情。</strong></p>
<p>Personally I find the concept of executable code inside of a .pth file really dangerous and up until now have avoided relying on this feature of .pth files.<br><strong>我个人认为可执行代码在.pth文件中的概念是非常危险的，到目前为止，我一直避免依赖.pth文件的这个特性。</strong></p>
<p>My concerns over executable code in .pth files is the fact that it is always run. This means that even if you had installed a pre built RPM/DEB package or a Python wheel into a system wide Python installation, with the idea that this was somehow much safer because you were avoiding running the setup.py file for a package as the root user, the .pth file means that the package can still subsequently run code without you realising and without you even having imported the module into any application.<br><strong>我对.pth文件中的可执行代码的担心是它总是在运行。这意味着，即使您已经将预构建的RPM/DEB包或Python wheel 安装到系统中的Python安装环境中，并且认为这样做更安全，因为避免了作为根用户运行 setup.py。但是.pth文件意味着包仍然可以在您不知情的情况下运行代码，甚至不需要将模块导入任何应用程序。</strong></p>
<p>If one wanted to be paranoid about security, then Python should really have a whitelisting mechanism for what .pth files you wanted to trust and allow code to be executed from every time the Python interpreter is run, especially as the root user.<br><strong>考虑到安全性，Python真应该有一个白名单机制，用于确定信任哪些.pth文件，以允许其在每次运行Python解释器(特别是作为根用户)时执行代码。</strong></p>
<p>I will leave that discussion up to others if anyone else cares to be concerned and for now at least will show how this feature of .pth files can be used (abused) to implement a mechanism for automated monkey patching of any Python application being run.<br><strong>如果有人关心的话，我将把这个讨论留给其他人来讨论，至少现在我将展示如何使用.pth文件的这个特性(滥用)来实现对正在运行的任何Python应用程序进行自动的猴子补丁的机制。</strong></p>
<h3 id="Adding-Python-import-hooks"><a href="#Adding-Python-import-hooks" class="headerlink" title="Adding Python import hooks"></a>Adding Python import hooks</h3><p>In the previous post where I talked about the post import hook mechanism, the code I gave as needing to be able to be manually added at the start of any Python application script file was:<br><strong>在前一篇文章中，我讨论了导入后钩子机制，在任何Python应用程序脚本文件的开头，我都需要手动添加的代码是:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">import os</div><div class="line"></div><div class="line">from wrapt import discover_post_import_hooks</div><div class="line"></div><div class="line">patches = os.environ.get(&apos;WRAPT_PATCHES&apos;)</div><div class="line"></div><div class="line">if patches:</div><div class="line">    for name in patches.split(&apos;,&apos;):</div><div class="line">        name = name.strip()</div><div class="line">        if name:</div><div class="line">            print &apos;discover&apos;, name</div><div class="line">            discover_post_import_hooks(name)</div></pre></td></tr></table></figure></p>
<p>What this was doing was using an environment variable as the source of names for any packages registered using setuptools entry points that contained monkey patches we wanted to have applied.<br><strong>它所做的是使用环境变量作为任何使用setuptools入口点注册的包的名称来源，这些入口点包含我们想要应用的猴子补丁。</strong></p>
<p>Knowing about the ability to have executable code in .pth files, lets now work out how we can use that to instead have this code executed automatically every time the Python interpreter is run, thereby avoiding the need to manually modify every Python application we want to have monkey patches applied to.<br><strong>了解了可以在.pth文件执行代码的能力,现在可以使用它，让这段代码在Python解释器启动时自动执行,从而避免了每次都需要手动修改每个Python应用程序，来应用我们的猴子补丁。</strong></p>
<p>In practice however, the code we will need is actually going to have to be slightly more complicated than this and as a result not something that can be readily added directly to a .pth file due to the limitation of code needing to all be on one line. What we will therefore do is put all our code in a separate module and execute it from there. We don’t want to be too nasty and import that module every time though, perhaps scaring users when they see it imported even if not used, so we will gate even that by the presence of the environment variable.<br><strong>但是在实践中，我们需要的代码实际上要比这个稍微复杂一些，并且不能很容易地直接添加到.pth文件中，这是由于需要将所有代码写在一行上。因此，我们要做的是将所有代码放在一个单独的模块中，然后执行该模块。我们不希望每次都导入那个模块，也许用户看到它被导入时会感到害怕，即使它没有被使用，所以我们将通过环境变量的判断使用它。</strong></p>
<p>What we can therefore use in our ‘.pth’ is:<br><strong>因此，我们可以在我们的“.pth”中使用的是:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import os, sys; os.environ.get(&apos;AUTOWRAPT_BOOTSTRAP&apos;) and __import__(&apos;autowrapt.bootstrap&apos;) and sys.modules[&apos;autowrapt.bootstrap&apos;].bootstrap()</div></pre></td></tr></table></figure></p>
<p>That is, if the environment variable is set to a non empty value only then do we import our module containing our bootstrap code and execute it.<br><strong>也就是说，如果环境变量被设置为非空值，那么我们需要导入包含引导代码的模块并执行它。</strong></p>
<p>As to the bootstrap code, this is where things get a bit messy. We can’t just use the code we had used before when manually modifying the Python application script file. This is because of where in the Python interpreter initialisation the parsing of .pth files is done.<br><strong>至于引导代码，这就有点麻烦了。我们不能只使用以前手动修改Python应用程序脚本文件时使用的代码。这是因为在Python解释器初始化中完成了.pth文件的解析。</strong></p>
<p>The problems are twofold. The first issue with executing the discovery of the import hooks directly when the .pth file is processed is that the order in which they are processed is unknown and so at the point our code is run the final Python module search path may not have been setup. The second issue is that .pth file processing is done before any sitecustomize.py or usercustomize.py processing has been done. The Python interpreter therefore may not be in its final configured state. We therefore have to be a little bit careful of what we do.<br><strong>问题是双重的。第一个问题发生在执行导入钩子的发现，当.pth文件被执行时，它被处理的顺序是未知的，所以在我们的代码运行的时候，最终的Python模块搜索路径可能没有设置。第二个问题是.pth文件的处理发生在任何sitecustomize.py或usercustomize.py被处理完之前。因此，Python解释器可能不在其最终配置状态。因此，我们必须对我们所做的事情小心一点。</strong></p>
<p>What we really want is to defer any actions until the Python interpreter initialisation has been completed. The problem is how we achieve that.<br><strong>我们真正需要的是将任何操作延迟到Python解释器的初始化完成之后。问题是我们如何做到这一点。</strong></p>
<h3 id="Python-interpreter-‘site’-module"><a href="#Python-interpreter-‘site’-module" class="headerlink" title="Python interpreter ‘site’ module"></a>Python interpreter ‘site’ module</h3><p>The actual final parts of Python interpreter initialisation is performed from the main() function of the site module:<br><strong>Python解释器初始化的实际最后部分由 site ll模块的main()函数执行:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">def main():</div><div class="line">    global ENABLE_USER_SITE</div><div class="line">    abs__file__()</div><div class="line">    known_paths = removeduppaths()</div><div class="line">    if ENABLE_USER_SITE is None:</div><div class="line">        ENABLE_USER_SITE = check_enableusersite()</div><div class="line">    known_paths = addusersitepackages(known_paths)</div><div class="line">    known_paths = addsitepackages(known_paths)</div><div class="line">    if sys.platform == &apos;os2emx&apos;:</div><div class="line">        setBEGINLIBPATH()</div><div class="line">    setquit()</div><div class="line">    setcopyright()</div><div class="line">    sethelper()</div><div class="line">    aliasmbcs()</div><div class="line">    setencoding()</div><div class="line">    execsitecustomize()</div><div class="line">    if ENABLE_USER_SITE:</div><div class="line">        execusercustomize()</div><div class="line">    # Remove sys.setdefaultencoding() so that users cannot change the</div><div class="line">    # encoding after initialization. The test for presence is needed when</div><div class="line">    # this module is run as a script, because this code is executed twice.</div><div class="line">    if hasattr(sys, &quot;setdefaultencoding&quot;):</div><div class="line">        del sys.setdefaultencoding</div></pre></td></tr></table></figure></p>
<p>The .pth parsing and code execution we want to rely upon is done within the addsitepackages() function.<br><strong>我们希望依赖的.pth解析和代码执行是在addsitepackages()函数中完成的。</strong></p>
<p>What we really want therefore is to defer any execution of our code until after the functions execsitecustomize() or execusercustomize() are run. The way to achieve that is to monkey patch those two functions and trigger our code when they have completed.<br><strong>因此，我们真正需要的是将代码的任何执行推迟到execsitecustomize()中或execusercustomize()函数运行之后。实现这一点的方法是对这两个函数进行修改，并在它们完成时触发我们的代码。</strong></p>
<p>We have to monkey patch both because the usercustomize.py processing is optional dependent on whether ENABLE_USER_SITE is true or not. Our ‘bootstrap() function therefore needs to look like:<br><strong>我们需要都打上补丁，因为usercustomize.py的执行是可选的，取决于ENABLE_USER_SITE环境变量是否为真。因此，我们的bootstrap()函数应该如下:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">def _execsitecustomize_wrapper(wrapped):</div><div class="line">    def _execsitecustomize(*args, **kwargs):</div><div class="line">        try:</div><div class="line">            return wrapped(*args, **kwargs)</div><div class="line">        finally:</div><div class="line">            if not site.ENABLE_USER_SITE:</div><div class="line">                _register_bootstrap_functions()</div><div class="line">    return _execsitecustomize</div><div class="line"></div><div class="line">def _execusercustomize_wrapper(wrapped):</div><div class="line">    def _execusercustomize(*args, **kwargs):</div><div class="line">        try:</div><div class="line">            return wrapped(*args, **kwargs)</div><div class="line">        finally:</div><div class="line">            _register_bootstrap_functions()</div><div class="line">    return _execusercustomize</div><div class="line"></div><div class="line">def bootstrap():</div><div class="line">    site.execsitecustomize = _execsitecustomize_wrapper(site.execsitecustomize)</div><div class="line">    site.execusercustomize = _execusercustomize_wrapper(site.execusercustomize)</div></pre></td></tr></table></figure>
<p>Despite everything I have ever said about how manually constructed monkey patches is bad and that the wrapt module should be used for doing monkey patching, we can’t actually use the wrapt module in this case. This is because technically, as a user installed package, the wrapt package may not be usable at this point. This could occur where wrapt was installed in such a way that the ability to import it was itself dependent on the processing of .pth files. As a result we drop down to using a simple wrapper using a function closure.<br><strong>尽管我曾经说过手工构建的猴子补丁有多糟糕，并且wrapt模块应该用于创建猴子补丁，但是在这种情况下，我们实际上不能使用wrapt模块。这是因为从技术上讲，作为用户安装的包，wrapt包此时可能不能使用。如果wrapt的安装方式是这样的，那么导入它的能力本身就依赖于.pth文件的处理。因此，我们使用一个函数闭包来使用简单的包装器。</strong></p>
<p>In the actual wrappers, you can see how which of the two wrappers actually ends up calling <code>_register_bootstrap_functions()</code> is dependent on whether ENABLE_USER_SITE is true or not, only calling it in execsitecustomize() if support for usersitecustomize was enabled.<br><strong>在实际的包装器中，您可以看到两个包装器中哪个最终调用’ _register_bootstrap_functions() ‘取决于ENABLE_USER_SITE是否为真，如果启用了对usersitecustomize()的支持，那么只能在execsitecustomize()中调用它。</strong></p>
<p>Finally we now have our <code>_register_bootstrap_functions()</code> defined as:<br><strong>最后，我们现在将’ _register_bootstrap_functions() ‘定义为:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">_registered = False</div><div class="line"></div><div class="line">def _register_bootstrap_functions():</div><div class="line">    global _registered</div><div class="line">    if _registered:</div><div class="line">        return</div><div class="line">    _registered = True</div><div class="line"></div><div class="line">    from wrapt import discover_post_import_hooks</div><div class="line">    for name in os.environ.get(&apos;AUTOWRAPT_BOOTSTRAP&apos;, &apos;&apos;).split(&apos;,&apos;):</div><div class="line">        discover_post_import_hooks(name)</div></pre></td></tr></table></figure></p>
<h3 id="Bundling-it-up-as-a-package"><a href="#Bundling-it-up-as-a-package" class="headerlink" title="Bundling it up as a package"></a>Bundling it up as a package</h3><p>We have worked out the various bits we require, but how do we get this installed, in particular how do we get the custom .pth file installed. For that we use a setup.py file of:<br><strong>我们已经解决了所需的各种位元，但是如何安装它，特别是如何安装自定义的.pth文件。为此我们使用一个设置.py文件:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">import sys</div><div class="line">import os</div><div class="line"></div><div class="line">from setuptools import setup</div><div class="line">from distutils.sysconfig import get_python_lib</div><div class="line"></div><div class="line">setup_kwargs = dict(</div><div class="line">    name = &apos;autowrapt&apos;,</div><div class="line">    packages = [&apos;autowrapt&apos;],</div><div class="line">    package_dir = &#123;&apos;autowrapt&apos;: &apos;src&apos;&#125;,</div><div class="line">    data_files = [(get_python_lib(prefix=&apos;&apos;), [&apos;autowrapt-init.pth&apos;])],</div><div class="line">    entry_points = &#123;&apos;autowrapt.examples’: [&apos;this = autowrapt.examples:autowrapt_this&apos;]&#125;,</div><div class="line">    install_requires = [&apos;wrapt&gt;=1.10.4&apos;],</div><div class="line">)</div><div class="line"></div><div class="line">setup(**setup_kwargs)</div></pre></td></tr></table></figure></p>
<p>To get that .pth installed we have used the data_files argument to the setup() call. The actual location for installing the file is determined using the get_python_lib() function from the distutils.sysconfig module. The prefix’ argument of an empty string ensures that a relative path for the site-packages directory where Python packages should be installed is used rather than an absolute path.<br><strong>为了安装.pth，我们使用了setup()调用的data_files参数。使用distutils.sysconfig模块中的get_python_lib()函数确定安装文件的实际位置。前缀“空字符串”的参数确保了Python包安装的路经为 site-packages 的相对路径，而不是绝对路径。</strong></p>
<p>Very important when installing this package though is that you cannot use easy_install or python setup.py install. One can only install this package using pip.<br><strong>安装这个包时非常重要的一点是，您不能使用easy_install或python setup.py安装。只能使用pip安装这个包。</strong></p>
<p>The reason for this is that if not using pip, then the package installation tool can install the package as an egg. In this situation the custom .pth file will actually be installed within the egg directory and not actually within the site-packages directory.<br><strong>这样做的原因是，如果不使用pip，那么包安装工具可以将包安装为egg。在这种情况下，自定义.pth文件实际上将安装在egg目录中，而不是实际安装在site-packages目录中。</strong></p>
<p>The only .pth file added to the site-packages directory will be that used to map that the autowrapt package exists in the sub directory. The addsitepackages() function called from the site module doesn’t in turn process .pth files contained in a directory added by a .pth file, so our custom .pth file would be skipped.<br><strong>.pth文件只有被添加到 site-packages 目录中，才能用于映射autowrapt包存在的子目录。从site模块调用的addsitepackages()函数并不会处理包含在.pth文件添加的目录中的.pth文件，因此我们的自定义.pth文件将被跳过。</strong></p>
<p>When using ‘pip’ it doesn’t use eggs by default and so we are okay.<br><strong>在使用“pip”时，默认情况下不使用eggs，所以我们可以。</strong></p>
<p>Also do be aware that this package will not work with buildout as it will always install packages as eggs and explicitly sets up the Python module search path itself in any Python scripts installed into the Python installation.<br><strong>还要注意的是，这个包不会与buildout一起工作，因为它总是将包作为eggs安装，并且在Python 安装环境中安装任何脚本时，都会显式地设置Python模块搜索路径本身。</strong></p>
<h3 id="Trying-out-an-example"><a href="#Trying-out-an-example" class="headerlink" title="Trying out an example"></a>Trying out an example</h3><p>The actual complete source code for this package can be found at:<br><strong>此软件包的实际完整源代码可在:</strong></p>
<p><a href="https://github.com/GrahamDumpleton/autowrapt" target="_blank" rel="external">https://github.com/GrahamDumpleton/autowrapt</a></p>
<p>The package has also been released on PyPi as autowrapt so you can actually try it, and use it if you really want to.<br><strong>这个包也在PyPi上作为autowrapt发布，因此您可以尝试它，如果您真的想使用它的话。</strong></p>
<p>To allow for a easy quick test to see that it works, the autowrapt package bundles an example monkey patch. In the above setup.py this was set up by:<br><strong>为了方便快速地测试它是否有效，autowrapt包打包了一个示例monkey patch。在上面的setyp.py被设置如下:</strong></p>
<p>entry_points = {‘autowrapt.examples’: [‘this = autowrapt.examples:autowrapt_this’]},</p>
<p>This entry point definition names a monkey patch with the name autowrapt.examples. The definition says that when the this module is installed, the monkey patch function autowrapt_this() in the module autowrapt.examples will be called.<br><strong>这个entry point 定义了一个名为autowrapt.examples的猴子补丁。定义了当导入 this 模块时，模块autowrapt.examples中的猴子补丁函数autowrapt_this()将被执行。</strong></p>
<p>So to run the test do:<br><strong>所以要运行这个测试需要:</strong></p>
<p><code>pip install autowrapt</code></p>
<p>This should also install the wrapt module if you don’t have the required minimum version.<br><strong>如果没有所需的最小版本，也应该安装wrapt模块。</strong></p>
<p>Now run the command line interpreter as normal and at the prompt do:<br><strong>现在正常运行命令行解释器，并在提示符处执行:</strong></p>
<p><code>import this</code></p>
<p>This should result in the Zen of Python being displayed.<br><strong>这应该会显示Python的Zen。</strong></p>
<p>Exit the Python interpreter and now instead run:<br><strong>退出Python解释器，现在运行:</strong></p>
<p><code>AUTOWRAPT_BOOTSTRAP=autowrapt.examples python</code></p>
<p>This runs the Python interpreter again, but also sets the environment variable AUTOWRAPT_BOOTSTRAP with the value autowrapt.examples matching the name of the entry point defined in the setup.py file for autowrapt’.<br><strong>这将再次运行Python解释器，并将环境变量AUTOWRAPT_BOOTSTRAP设置为autowrapt.examples,以匹配在setup.py中为autowrapt定义的entry point。</strong></p>
<p>The actual code for the ‘autowrapt_this()’ function was:<br><strong>“autowrapt_this()”函数的实际代码是:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">from __future__ import print_function</div><div class="line"></div><div class="line">def autowrapt_this(module):</div><div class="line">    print(&apos;The wrapt package is absolutely amazing and you should use it.&apos;)</div></pre></td></tr></table></figure>
<p>so if we now again run:<br><strong>所以如果我们再一次运行</strong></p>
<p><code>import this</code></p>
<p>we should now see an extended version of the Zen of Python.<br><strong>我们现在应该看到Python Zen的扩展版本。</strong></p>
<p>We didn’t actually monkey patch any code in the target module in this case, but it shows that the monkey patch function was actually triggered when expected.<br><strong>在本例中，我们实际上并没有对目标模块中的任何代码打补丁，但它显示了补丁函数实际上是按预期被触发。</strong></p>
<h3 id="Other-bootstrapping-mechanisms"><a href="#Other-bootstrapping-mechanisms" class="headerlink" title="Other bootstrapping mechanisms"></a>Other bootstrapping mechanisms</h3><p>Although this mechanism is reasonably clean and only requires the setting of an environment variable, it cannot be used with buildout as mentioned. For buildout we need to investigate other approaches we could use to achieve the same affect. I will cover such other options in the next blog post on this topic.<br><strong>虽然这种机制相当干净，并且只需要设置环境变量，但是不能像前面提到的那样与buildout一起使用。对于buildout，我们需要研究其他可以实现同样效果的方法。我将在下一篇关于这一主题的博文中讨论这些其他选择。</strong></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/python-标准库/" rel="tag"># python 标准库</a>
          
            <a href="/tags/译文/" rel="tag"># 译文</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/06/04/wrapt/13-ordering-issues-when-monkey-patching-in-python/" rel="next" title="13 Ordering issues when monkey patching in Python">
                <i class="fa fa-chevron-left"></i> 13 Ordering issues when monkey patching in Python
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/06/13/python_frame/supervisor_03/" rel="prev" title="supervisor eventer">
                supervisor eventer <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.jpg"
               alt="song tao" />
          <p class="site-author-name" itemprop="name">song tao</p>
           
              <p class="site-description motion-element" itemprop="description">有些东西写下来是想告诉自己，别太着急</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">22</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/hotttao" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://weibo.com/2622065365/profile" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                    
                      微博
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Automatic-patching-of-Python-applications"><span class="nav-number">1.</span> <span class="nav-text">Automatic patching of Python applications</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Executable-code-in-pth-files"><span class="nav-number">2.</span> <span class="nav-text">Executable code in .pth files</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Adding-Python-import-hooks"><span class="nav-number">3.</span> <span class="nav-text">Adding Python import hooks</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Python-interpreter-‘site’-module"><span class="nav-number">4.</span> <span class="nav-text">Python interpreter ‘site’ module</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bundling-it-up-as-a-package"><span class="nav-number">5.</span> <span class="nav-text">Bundling it up as a package</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Trying-out-an-example"><span class="nav-number">6.</span> <span class="nav-text">Trying out an example</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Other-bootstrapping-mechanisms"><span class="nav-number">7.</span> <span class="nav-text">Other bootstrapping mechanisms</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">song tao</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
