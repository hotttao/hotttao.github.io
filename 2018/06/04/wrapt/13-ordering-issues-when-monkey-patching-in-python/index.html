<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="python 标准库,译文," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="本系列 blog 与 python wrat 模块相关，深入介绍了 Python 装饰器，猴子补订等相关内容，翻译于 https://github.com/GrahamDumpleton/wrapt/tree/master/blog  本篇内容: 通过导入后钩子，延迟导入和 setuptools 解决猴子补丁与被打补丁模块之间由于相对导入次序引发的猴子补丁未生效问题">
<meta name="keywords" content="python 标准库,译文">
<meta property="og:type" content="article">
<meta property="og:title" content="13 Ordering issues when monkey patching in Python">
<meta property="og:url" content="http://yoursite.com/2018/06/04/wrapt/13-ordering-issues-when-monkey-patching-in-python/index.html">
<meta property="og:site_name" content="song tao blogs">
<meta property="og:description" content="本系列 blog 与 python wrat 模块相关，深入介绍了 Python 装饰器，猴子补订等相关内容，翻译于 https://github.com/GrahamDumpleton/wrapt/tree/master/blog  本篇内容: 通过导入后钩子，延迟导入和 setuptools 解决猴子补丁与被打补丁模块之间由于相对导入次序引发的猴子补丁未生效问题">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-06-08T07:47:07.437Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="13 Ordering issues when monkey patching in Python">
<meta name="twitter:description" content="本系列 blog 与 python wrat 模块相关，深入介绍了 Python 装饰器，猴子补订等相关内容，翻译于 https://github.com/GrahamDumpleton/wrapt/tree/master/blog  本篇内容: 通过导入后钩子，延迟导入和 setuptools 解决猴子补丁与被打补丁模块之间由于相对导入次序引发的猴子补丁未生效问题">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/06/04/wrapt/13-ordering-issues-when-monkey-patching-in-python/"/>





  <title>13 Ordering issues when monkey patching in Python | song tao blogs</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">song tao blogs</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">漫步在大陆上的海龟</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/04/wrapt/13-ordering-issues-when-monkey-patching-in-python/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="song tao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="song tao blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">13 Ordering issues when monkey patching in Python</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-04T10:54:03+08:00">
                2018-06-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/函数装饰器/" itemprop="url" rel="index">
                    <span itemprop="name">函数装饰器</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/函数装饰器/猴子补订/" itemprop="url" rel="index">
                    <span itemprop="name">猴子补订</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/函数装饰器/猴子补订/wrapt/" itemprop="url" rel="index">
                    <span itemprop="name">wrapt</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>本系列 blog 与 python wrat 模块相关，深入介绍了 Python 装饰器，猴子补订等相关内容，<br>翻译于 <a href="https://github.com/GrahamDumpleton/wrapt/tree/master/blog" target="_blank" rel="external">https://github.com/GrahamDumpleton/wrapt/tree/master/blog</a></p>
</blockquote>
<p>本篇内容: 通过导入后钩子，延迟导入和 setuptools 解决猴子补丁与被打补丁模块之间由于相对导入次序引发的猴子补丁未生效问题<br><a id="more"></a></p>
<h3 id="Ordering-issues-when-monkey-patching-in-Python"><a href="#Ordering-issues-when-monkey-patching-in-Python" class="headerlink" title="Ordering issues when monkey patching in Python"></a>Ordering issues when monkey patching in Python</h3><p>In my recent post about safely applying monkey patches in Python, I mentioned how one of the issues that arises is when a monkey patch is applied. Specifically, if the module you need to monkey patch has already been imported and was being used by other code, that it could have created a local reference to a target function you wish to wrap, in its own namespace. So although your monkey patch would work fine where the original function was used direct from the module, you would not cover where it was used via a local reference.<br><strong>在我最近关于在Python中安全地应用猴子补丁的文章中，我提到了应用猴子补丁时可能存在的问题。具体地说，如果需要被打补丁的模块已经被导入并被其他代码使用，那么它可能已经在自己的名称空间中创建了一个被打补丁的目标函数的本地引用。因此，尽管您的猴子补丁可以正常工作，但是仍然无法覆盖这种原始函数已经直接从，并过通过本地引用直接访问原函数的情况。</strong></p>
<p>Coincidentally, Ned Batchelder recently posted about using monkey patching to debug an issue where temporary directories were not being cleaned up properly. Ned described this exact issue in relation to wanting to monkey patch the ‘mkdtemp()’ function from the ‘tempfile’ module. In that case he was able to find an alternate place within the private implementation for the module to patch so as to avoid the problem. Using some internal function like this may not always be possible however.<br><strong>碰巧的是，Ned Batchelder最近发布了关于使用猴子补丁来调试临时目录没有被正确清理的问题。Ned描述的正是对“tempfile”模块中的“mkdtemp()”函数进行修补出现的问题。在这种情况下，他能够在模块的私有实现中找到一个替代的位置，以避免出现问题。然而，使用这样的内部函数可能并不总是可行的。</strong></p>
<p>What I want to start discussing with this post is mechanisms one can use from wrapt to deal with this issue of ordering. A major part of the solution is what are called post import hooks. This is a mechanism which was described in PEP 369 and although it never made it into the Python core, it is still possible to graft this ability into Python using existing APIs. From this we can then add additional capabilities for discovering monkey patching code and automatically apply it when modules are imported, before other modules get the module and so before they can create a reference to a function in their own namespace.<br><strong>我想从这篇文章开始讨论wrapt用来处理导入次序问题的机制。解决方案的一个主要部分是所谓的后导入钩子。这是在PEP 369中描述的一种机制，虽然它从未进入Python核心，但是仍然可以使用现有的api将这种能力移植到Python中。然后，在其他模块获得模块之前，以及在它们可以在自己的名称空间中创建对函数的引用之前，我们可以添加其他功能来发现猴子补丁代码，并在导入模块时自动应用它。</strong></p>
<h3 id="Post-import-hook-mechanism"><a href="#Post-import-hook-mechanism" class="headerlink" title="Post import hook mechanism"></a>Post import hook mechanism</h3><p>In PEP 369, a primary use case presented was illustrated by the example:<br><strong>PEP 369中一个主要的示例展示如下:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">import imp</div><div class="line"></div><div class="line">@imp.when_imported(&apos;decimal&apos;)</div><div class="line">def register(decimal):</div><div class="line">    Inexact.register(decimal.Decimal)</div></pre></td></tr></table></figure></p>
<p>The basic idea is that when this code was seen it would cause a callback to be registered within the Python import system such that when the ‘decimal’ module was imported, that the ‘register()’ function which the decorator had been applied to, would be called. The argument to the ‘register()’ function would be the reference to the module the registration had been against. The function could then perform some action against the module before it was returned to whatever code originally requested the import.<br><strong>其基本思想是，当看到这段代码时，它将导致在Python导入系统中注册一个回调，以便在导入‘decimal’模块时，调用装饰器应用的‘register()’函数。“register()”函数的参数是对被注册的模块的引用。然后，该函数可以对模块执行一些操作，最后再将模块返回到最初请求导入的代码中。</strong></p>
<p>Instead of using the decorator ‘@imp.when_imported’ decorator, one could also explicitly use the ‘imp.register_post_import_hook()’ function to register a post import hook.<br><strong>除了使用作为装饰器的’@imp.where_imported’函数 ，还可以显式地使用’imp.register_post_import_hook()’函数来注册导入后钩子。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">import imp</div><div class="line"></div><div class="line">def register(decimal):</div><div class="line">    Inexact.register(decimal.Decimal)</div><div class="line"></div><div class="line">imp.register_post_import_hook(register, &apos;decimal&apos;)</div></pre></td></tr></table></figure></p>
<p>Although PEP 369 was never incorporated into Python, the wrapt module provides implementations for both the decorator and the function, but within the ‘wrapt’ module rather than ‘imp’.<br><strong>尽管PEP 369从未被合并到Python中，但是wrapt 提供了类似功能的装饰器和函数。</strong></p>
<p>Now what neither the decorator or the function really solved alone was the ordering issue. That is, you still had the problem that these could be triggered after the target module had already been imported. In this case the post import hook function would still be called, albeit for our case too late to get in before the reference to the function we want to monkey patch had been created in a different namespace.<br><strong>尽管装饰器和函数被用来解决导入次序问题。但如果目标模块在导入后钩子函数执行之前就已经被导入，我们仍会面临导入次序问题。</strong></p>
<p>The simplest solution to this problem is to modify the main Python script for your application and setup all the post import hook registrations you need as the absolute very first thing that is done. That is, before any other modules are imported from your application or even modules from the standard library used to parse any command line arguments.<br><strong>这个问题最简单的解决方案是修改应用程序的主Python脚本，并将您需要的所有post import hook注册设置为绝对的第一件事。也就是说，在从应用程序导入任何其他模块或甚至从用于解析任何命令行参数的标准库中导入模块之前。</strong></p>
<p>Even if you are able to do this, because though the registration functions require an actual callable, it does mean you are preloading the code to perform all the monkey patches. This could be a problem if they in turn had to import further modules as the state of your application may not yet have been setup such that those imports would succeed.<br><strong>尽管你确实可以做到这一点，但是由于注册函数会发生事实上的调用，这意味着你将预加载所有猴子补丁。由于猴子补丁可能转而导入那些未被导入的应用程序模块，所以可能会导入错误。</strong></p>
<p>They say though that one level of indirection can solve all problems and this is an example of where that principle can be applied. That is, rather than import the monkey patching code, you can setup a registration which would only lazily load the monkey patching code itself if the module to be patched was imported, and then execute it.<br><strong>有一种间接的方式可以解决所有的问题，下面是应用这个原则的例子。即相对于导入猴子补丁代码，不如设置一个注册，如果要进行补丁的模块被导入，那么这个注册只会延迟加载猴子补丁代码本身，然后执行它。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">import sys</div><div class="line"></div><div class="line">from wrapt import register_post_import_hook</div><div class="line"></div><div class="line">def load_and_execute(name):</div><div class="line">    def _load_and_execute(target_module):</div><div class="line">        __import__(name)</div><div class="line">        patch_module = sys.modules[name]</div><div class="line">        getattr(patch_module, &apos;apply_patch&apos;)(target_module)</div><div class="line">    return _load_and_execute</div><div class="line"></div><div class="line">register_post_import_hook(load_and_execute(&apos;patch_tempfile&apos;), &apos;tempfile&apos;)</div></pre></td></tr></table></figure></p>
<p>In the module file ‘patch_tempfile.py’ we would now have:<br><strong>patch_tempfile.py代码如下:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">from wrapt import wrap_function_wrapper</div><div class="line"></div><div class="line">def _mkdtemp_wrapper(wrapped, instance, args, kwargs):</div><div class="line">    print &apos;calling&apos;, wrapped.__name__</div><div class="line">    return wrapped(*args, **kwargs)</div><div class="line"></div><div class="line">def apply_patch(module):</div><div class="line">    print &apos;patching&apos;, module.__name__</div><div class="line">    wrap_function_wrapper(module, &apos;mkdtemp&apos;, _mkdtemp_wrapper)</div></pre></td></tr></table></figure>
<p>Running the first script with the interactive interpreter so as to leave us in the interpreter, we can then show what happens when we import the ‘tempfile’ module and execute the ‘mkdtemp()’ function.<br><strong>使用交互式解释器运行第一个脚本，以便将我们留在解释器中，然后，我们可以显示导入“tempfile”模块并执行“mkdtemp()”函数，看看会发生什么。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ python -i lazyloader.py</div><div class="line">&gt;&gt;&gt; import tempfile</div><div class="line">patching tempfile</div><div class="line">&gt;&gt;&gt; tempfile.mkdtemp()</div><div class="line">calling mkdtemp</div><div class="line">&apos;/var/folders/0p/4vcv19pj5d72m_bx0h40sw340000gp/T/tmpfB8r20&apos;</div></pre></td></tr></table></figure></p>
<p>In other words, unlike how most monkey patching is done, we aren’t forcibly importing a module in order to apply the monkey patches on the basis it might be used. Instead the monkey patching code stays dormant and unused until the target module is later imported. If the target module is never imported, the monkey patch code for that module is itself not even imported.<br><strong>换句话说，与大多数猴子补丁不同，我们并不是强行导入一个模块，以便在可能使用的基础上应用猴子补丁。相反，猴子补丁代码保持休眠和未使用，直到目标模块稍后被导入。如果没有导入目标模块，则该模块的猴子补丁代码本身甚至没有导入。</strong></p>
<h3 id="Discovery-of-post-import-hooks"><a href="#Discovery-of-post-import-hooks" class="headerlink" title="Discovery of post import hooks"></a>Discovery of post import hooks</h3><p>Post import hooks as described provide a slightly better way of setting up monkey patches so they are applied. This is because they are only activated if the target module containing the function to be patched is even imported. This avoids unnecessarily importing modules you may not even use, and which otherwise would increase memory usage of your application.<br><strong>如所述，后导入钩子提供了一种稍微更好的方法来设置猴子补丁，以便应用它们。这是因为只有当包含要修补的函数的目标模块被导入时，它们才会被激活。这避免了不必要地导入可能不使用的模块，否则会增加应用程序的内存使用。</strong></p>
<p>Ordering is still important and as a result it is important to ensure that any post import hook registrations are setup before any other modules are imported. You also need to modify your application code every time you want to change what monkey patches are applied. This latter point could be inconvenient if only wanting to add monkey patches infrequently for the purposes of debugging issues.<br><strong>导入次序仍然很重要，因此，要确保在导入任何其他模块之前设置所有导入后钩子。并且在每次更改应用的猴子补丁后，需要修改应用程序代码。如果只是为了调试问题而频繁地添加猴子补丁，则可能不太方便。</strong></p>
<p>A solution to the latter issue is to separate out monkey patches into separately installed modules and use a registration mechanism to announce their availability. Python applications could then have common boiler plate code executed at the very start which discovers based on supplied configuration what monkey patches should be applied. The registration mechanism would then allow the monkey patch modules to be discovered at runtime.<br><strong>后一个问题的解决方案是将猴子补丁分离到单独的模块中，并使用一个注册机制来宣布它们的可用性。然后，Python应用程序可以在一开始就执行通用的模板代码，该代码根据提供的配置发现应该应用哪些猴子补丁。注册机制将允许在运行时发现猴子补丁模块。</strong></p>
<p>One particular registration mechanism which can be used here is ‘setuptools’ entry points. Using this we can package up monkey patches so they could be separately installed ready for use. The structure of such a package would be:<br><strong>这里可以使用的一种特殊的注册机制是“setuptools”入口点。使用这个我们可以打包猴子补丁，这样它们就可以被单独安装以备使用。这样一套方案的结构是:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">setup.py</div><div class="line">src/__init__.py</div><div class="line">src/tempfile_debugging.py</div></pre></td></tr></table></figure></p>
<p>The ‘setup.py’ file for this package will be:<br><strong>这个包的 setup.py 代码将会是:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">from setuptools import setup</div><div class="line"></div><div class="line">NAME = &apos;wrapt_patches.tempfile_debugging&apos;</div><div class="line"></div><div class="line">def patch_module(module, function=None):</div><div class="line">    function = function or &apos;patch_%s&apos; % module.replace(&apos;.&apos;, &apos;_&apos;)</div><div class="line">    return &apos;%s = %s:%s&apos; % (module, NAME, function)</div><div class="line"></div><div class="line">ENTRY_POINTS = [</div><div class="line">    patch_module(&apos;tempfile&apos;),</div><div class="line">]</div><div class="line"></div><div class="line">setup_kwargs = dict(</div><div class="line">    name = NAME,</div><div class="line">    version = &apos;0.1&apos;,</div><div class="line">    packages = [&apos;wrapt_patches&apos;],</div><div class="line">    package_dir = &#123;&apos;wrapt_patches&apos;: &apos;src&apos;&#125;,</div><div class="line">    entry_points = &#123; NAME: ENTRY_POINTS &#125;,</div><div class="line">)</div><div class="line"></div><div class="line">setup(**setup_kwargs)</div></pre></td></tr></table></figure></p>
<p>As a convention so that our monkey patch modules are easily identifiable we use a namespace package. The parent package in this case will be ‘wrapt_patches’ since we are working with wrapt specifically.<br><strong>作为一种约定，我们使用命名空间包，以便我们的猴子补丁模块易于识别。在本例中，父包将是“wrapt_patch”，因为我们专门使用wrapt。</strong></p>
<p>The name for this specific package will be ‘wrapt_patches.tempfile_debugging’ as the theoretical intent is that we are going to create some monkey patches to help us debug use of the ‘tempfile’ module, along the lines of what Ned described in his blog post.<br><strong>这个特定包的名称将是“wrapt_patch.tempfile_debug“,表示我们将创建一些猴子补丁，以帮助我们调试使用“tempfile”模块，正如Ned的博客文章中所描述的。</strong></p>
<p>The key part of the ‘setup.py’ file is the definition of the ‘entry_points’. This will be set to a dictionary mapping the package name to a list of definitions listing what Python modules this package contains monkey patches for.<br><strong>‘setup.py’的关键部分是定义’entry_points’。它将被设置程包名到一个列表的映射，这个列表包含了这个补丁模块要作用的所有目标Python模块。</strong></p>
<p>The ‘src/init.py’ file will then contain:<br><strong>‘src/init.py’ 将包含:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import pkgutil</div><div class="line">__path__ = pkgutil.extend_path(__path__, __name__)</div></pre></td></tr></table></figure></p>
<p>as is required when creating a namespace package.<br><strong>这是创建命名空间包的要求</strong></p>
<p>Finally, the monkey patches will actually be contained in ‘src/tempfile_debugging.py’ and for now is much like what we had before.<br><strong>最后，猴子补丁实际上包含在“src/tempfile_debug”中。代码跟以前很像。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">from wrapt import wrap_function_wrapper</div><div class="line"></div><div class="line">def _mkdtemp_wrapper(wrapped, instance, args, kwargs):</div><div class="line">    print &apos;calling&apos;, wrapped.__name__</div><div class="line">    return wrapped(*args, **kwargs)</div><div class="line"></div><div class="line">def patch_tempfile(module):</div><div class="line">    print &apos;patching&apos;, module.__name__</div><div class="line">    wrap_function_wrapper(module, &apos;mkdtemp&apos;, _mkdtemp_wrapper)</div></pre></td></tr></table></figure></p>
<p>With the package defined we would install it into the Python installation or virtual environment being used.<br><strong>定义了包后，我们将它安装到正在使用的Python安装或虚拟环境中。</strong></p>
<p>In place now of the explicit registrations which we previously added at the very start of the Python application main script file, we would instead add:<br><strong>现在，我们可以在Python应用程序主脚本文件的开头添加显式的注册，我们将添加:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">import os</div><div class="line"></div><div class="line">from wrapt import discover_post_import_hooks</div><div class="line"></div><div class="line">patches = os.environ.get(&apos;WRAPT_PATCHES&apos;)</div><div class="line"></div><div class="line">if patches:</div><div class="line">    for name in patches.split(&apos;,&apos;):</div><div class="line">        name = name.strip()</div><div class="line">        if name:</div><div class="line">            print &apos;discover&apos;, name</div><div class="line">            discover_post_import_hooks(name)</div></pre></td></tr></table></figure></p>
<p>If we were to run the application with no specific configuration to enable the monkey patches then nothing would happen. If however they were enabled, then they would be automatically discovered and applied as necessary.<br><strong>如果我们在没有为猴子补丁特定配置的情况下运行应用程序，那么什么也不会发生。如果它们是启用的，那么它们将被自动发现并根据需要应用。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ WRAPT_PATCHES=wrapt_patches.tempfile_debugging python -i entrypoints.py</div><div class="line">discover wrapt_patches.tempfile_debugging</div><div class="line">&gt;&gt;&gt; import tempfile</div><div class="line">patching tempfile</div></pre></td></tr></table></figure></p>
<p>What would be ideal is if PEP 369 ever did make it into the core of Python that a similar bootstrapping mechanism be incorporated into Python itself so that it was possible to force registration of monkey patches very early during interpreter initialisation. Having this in place we would have a guaranteed way of addressing the ordering issue when doing monkey patching.<br><strong>理想的情况是，如果PEP 369真的进入了Python的核心，那么将类似的引导机制合并到Python本身中，以便在解释器初始化过程中尽早强制对猴子补丁进行注册。有了这一点，我们就有了一种有保证的方法来解决在做猴子补丁时的导入次序问题。</strong></p>
<p>As that doesn’t exist right now, what we did in this case was modify our Python application to add the bootstrap code ourselves. This is fine where you control the Python application you want to be able to potentially apply monkey patches to, but what if you wanted to monkey patch a third party application and you didn’t want to have to modify its code. What are the options in that case?<br><strong>由于现在还不存在这种情况，所以我们在本例中所做的是修改Python应用程序以自己添加引导代码。在控制您希望能够应用猴子补丁的Python应用程序时，这是可以的，但是如果您想要对第三方应用程序进行打补丁，并且不希望修改其代码，那该怎么办呢?在这种情况下有什么选择?</strong></p>
<p>As it turns out there are some tricks that can be used in that case. I will discuss such options for monkey patching a Python application you can’t actually modify in my next blog post on this topic of monkey patching.<br><strong>事实证明，在这种情况下可以使用一些技巧。我将在我的下一篇关于猴子补丁主题的博文中讨论为应用程序打补丁的可用选项。</strong></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/python-标准库/" rel="tag"># python 标准库</a>
          
            <a href="/tags/译文/" rel="tag"># 译文</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/06/03/wrapt/12-using-wrapt-to-support-testing-of-software/" rel="next" title="12 Using wrapt to support testing of software">
                <i class="fa fa-chevron-left"></i> 12 Using wrapt to support testing of software
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/06/07/wrapt/14-automatic-patching-of-python-applications/" rel="prev" title="14 Automatic patching of Python applications">
                14 Automatic patching of Python applications <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.jpg"
               alt="song tao" />
          <p class="site-author-name" itemprop="name">song tao</p>
           
              <p class="site-description motion-element" itemprop="description">有些东西写下来是想告诉自己，别太着急</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">22</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/hotttao" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://weibo.com/2622065365/profile" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                    
                      微博
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Ordering-issues-when-monkey-patching-in-Python"><span class="nav-number">1.</span> <span class="nav-text">Ordering issues when monkey patching in Python</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Post-import-hook-mechanism"><span class="nav-number">2.</span> <span class="nav-text">Post import hook mechanism</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Discovery-of-post-import-hooks"><span class="nav-number">3.</span> <span class="nav-text">Discovery of post import hooks</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">song tao</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
