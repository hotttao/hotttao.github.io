<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[supervisor eventer]]></title>
    <url>%2F2018%2F06%2F13%2Fpython_frame%2Fsupervisor_03%2F</url>
    <content type="text"><![CDATA[本篇内容: 通过 supervisor 创建监听套接字的文件描述符，为多个 tornado 进程共享 1. tornado 启动12345678910111213from tornado.netutil import set_close_execdef main(): app = AnalyticApiApplication() http_serve = httpserver.HTTPServer(app) # http_serve.listen(options.port) # supervisor 创建的监听套接字文件描述符，通过 0 号传递给 tornado的所有进程 sock = socket.fromfd(0, family=socket.AF_INET, type=socket.SOCK_STREAM) set_close_exec(sock.fileno()) sock.setblocking(0) # 设置套接字为非阻塞调用 http_serve.add_socket(sock) ioloop.IOLoop.instance().start() 2. supervisor 配置12345678command=/home/tao/.local/bin/pipenv run python app.py --connect=local-dev --debug=1socket=tcp://localhost:8888directory=/home/tao/projects/analytics_apiuser=taonumprocs=4process_name=%(program_name)s_%(process_num)02dstdout_logfile =/var/log/tornado_pyapi_stdout_%(process_num)02d.log stderr_logfile =/var/log/tornado_pyapi_stderr_%(process_num)02d.log 3. tornado.bind_socket12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788def bind_sockets(port, address=None, family=socket.AF_UNSPEC, backlog=_DEFAULT_BACKLOG, flags=None, reuse_port=False): &quot;&quot;&quot;Creates listening sockets bound to the given port and address. Returns a list of socket objects (multiple sockets are returned if the given address maps to multiple IP addresses, which is most common for mixed IPv4 and IPv6 use). Address may be either an IP address or hostname. If it&apos;s a hostname, the server will listen on all IP addresses associated with the name. Address may be an empty string or None to listen on all available interfaces. Family may be set to either `socket.AF_INET` or `socket.AF_INET6` to restrict to IPv4 or IPv6 addresses, otherwise both will be used if available. The ``backlog`` argument has the same meaning as for `socket.listen() &lt;socket.socket.listen&gt;`. ``flags`` is a bitmask of AI_* flags to `~socket.getaddrinfo`, like ``socket.AI_PASSIVE | socket.AI_NUMERICHOST``. ``reuse_port`` option sets ``SO_REUSEPORT`` option for every socket in the list. If your platform doesn&apos;t support this option ValueError will be raised. &quot;&quot;&quot; if reuse_port and not hasattr(socket, &quot;SO_REUSEPORT&quot;): raise ValueError(&quot;the platform doesn&apos;t support SO_REUSEPORT&quot;) sockets = [] if address == &quot;&quot;: address = None if not socket.has_ipv6 and family == socket.AF_UNSPEC: # Python can be compiled with --disable-ipv6, which causes # operations on AF_INET6 sockets to fail, but does not # automatically exclude those results from getaddrinfo # results. # http://bugs.python.org/issue16208 family = socket.AF_INET if flags is None: flags = socket.AI_PASSIVE bound_port = None for res in set(socket.getaddrinfo(address, port, family, socket.SOCK_STREAM, 0, flags)): af, socktype, proto, canonname, sockaddr = res if (sys.platform == &apos;darwin&apos; and address == &apos;localhost&apos; and af == socket.AF_INET6 and sockaddr[3] != 0): # Mac OS X includes a link-local address fe80::1%lo0 in the # getaddrinfo results for &apos;localhost&apos;. However, the firewall # doesn&apos;t understand that this is a local address and will # prompt for access (often repeatedly, due to an apparent # bug in its ability to remember granting access to an # application). Skip these addresses. continue try: sock = socket.socket(af, socktype, proto) except socket.error as e: if errno_from_exception(e) == errno.EAFNOSUPPORT: continue raise set_close_exec(sock.fileno()) if os.name != &apos;nt&apos;: sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) if reuse_port: sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, 1) if af == socket.AF_INET6: # On linux, ipv6 sockets accept ipv4 too by default, # but this makes it impossible to bind to both # 0.0.0.0 in ipv4 and :: in ipv6. On other systems, # separate sockets *must* be used to listen for both ipv4 # and ipv6. For consistency, always disable ipv4 on our # ipv6 sockets and use a separate ipv4 socket when needed. # # Python 2.x on windows doesn&apos;t have IPPROTO_IPV6. if hasattr(socket, &quot;IPPROTO_IPV6&quot;): sock.setsockopt(socket.IPPROTO_IPV6, socket.IPV6_V6ONLY, 1) # automatic port allocation with port=None # should bind on the same port on IPv4 and IPv6 host, requested_port = sockaddr[:2] if requested_port == 0 and bound_port is not None: sockaddr = tuple([host, bound_port] + list(sockaddr[2:])) sock.setblocking(0) sock.bind(sockaddr) bound_port = sock.getsockname()[1] sock.listen(backlog) sockets.append(sock) return sockets]]></content>
      <categories>
        <category>部署工具</category>
      </categories>
      <tags>
        <tag>supervisor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[14 Automatic patching of Python applications]]></title>
    <url>%2F2018%2F06%2F07%2Fwrapt%2F14-automatic-patching-of-python-applications%2F</url>
    <content type="text"><![CDATA[本系列 blog 与 python wrat 模块相关，深入介绍了 Python 装饰器，猴子补订等相关内容，翻译于 https://github.com/GrahamDumpleton/wrapt/tree/master/blog 本篇内容: 通过 Python 包模块导入的 .pth 机制实现猴子补丁通过环境变量自动优先导入 Automatic patching of Python applicationsIn my previous posts on monkey patching I discussed the ordering problem. That is, that the ability to properly monkey patch is dependent on whether we can get in before any other code has already imported the module we want to patch. The specific issue in this case is where other code has imported a reference to a function within a module by name and stored that in it is own namespace. In other words, where it has used:在我之前关于猴子修补的文章中，我讨论了导入次序问题。也就是说，正确使用猴子补丁取决于我们能在任何其他代码导入我们想要修补的模块之前打补丁。在这种情况下的具体问题是，其他代码是否已经按名称导入了对模块内函数的引用，并将其存储在它自己的名称空间中。换句话说，是否已经使用: from module import function If we can’t get in early enough, then it becomes necessary to monkey patch all such uses of a target function as well, which in the general case is impossible as we will not know where the function has been imported.如果我们不能尽早进入，那么就需要对目标函数的所有使用进行monkey patch，这在一般情况下是不可能的，因为我们不知道函数在哪里被导入。 Part of the solution I described for this was to use a post import hook mechanism to allow us to get access to a module for monkey patching before the module is even returned back to any code where it is being imported. This technique is still though dependent on the post import hook mechanism itself being installed before any other code is effectively run. This means having to manually modify the main Python script file for an application, something which isn’t always practical.我所描述的一种解决方案是使用导入后钩子机制，使我们能够在模块被任何代码导入之前访问模块并打补丁。这种技术仍然依赖于在有效运行其他代码之前安装导入后钩子机制本身。这意味着必须手动修改应用程序的主Python脚本文件，这并不总是实用的。 The point of this post is to look at how we can avoid the need to even modify that main Python script file. For this there are a few techniques that could be used. I am going to look at the most evil of those techniques first and then talk about others in a subsequent post.本文的目的是研究如何避免修改主Python脚本文件。为此，可以使用一些技术。我将先看看这些技术中最邪恶的部分，然后在后面的文章中讨论其他的。 Executable code in .pth filesAs part of the Python import system and how it determines what directories are searched for Python modules, there is a mechanism whereby for a package it is possible to install a file with a .pth extension into the Python ‘site-packages’ directory. The actual Python package code itself then might actually be installed in a different location not actually on the Python module search path, most often actually in a versioned subdirectory of the ‘site-packages’ directory. The purpose of the .pth file is to act as a pointer to where the actual code for the Python package lives.作为Python导入系统的一部分，以及在那些目录中搜索Python模块，有一种扩展机制，即可以将一个.pth扩展名文件安装到Python的“site-packages”目录中。用于指明Python包代码并不在默认的Python模块搜索路径上，而是存在于其他位置，通常是在“site-packages”的子目录中。.pth文件的目的是充当指向Python包的实际代码的指针。 In the simple case the .pth file will contain a relative or absolute path name to the name of the actual directory containing the code for the Python package. In the case of it being a relative path name, then it will be taken relative to the directory in which the .pth file is located.在简单的情况下，.pth文件将包含与包含Python包代码的实际目录的名称相关的或绝对的路径名。如果它是一个相对路径名，那么它将相对于.pth文件所在的目录。 With such .pth files in place, when the Python interpreter is initialising itself and setting up the Python module search path, after it has added in all the default directories to be searched, it will look through the site-packages directory and parse each .pth file, adding to the final list of directories to be searched any directories specified within the .pth files.如果使用 .pth,当Python 解释器初始化时，它会创建Python模块的搜索路经，在添加所有默认搜索目录后，它将查找 site-packages内的所有目录，并解析每一个 .pth 文件，并将 .pth 内的目录添加到最后的搜索目录列表中。 Now at one point in the history of Python this .pth mechanism was enhanced to allow for a special case. This special case was that if a line in the .pth file started with import, the line would be executed as Python code instead of simply adding it as a directory to the list of directories to be searched for modules.现在，在Python的历史中，这个.pth机制被增强了，以支持一个特殊的情况。这种特殊情况是，如果.pth文件中的一行从导入开始，那么该行将作为Python代码执行，而不是简单地将其作为目录添加到要搜索模块的目录列表中。 I am told this originally was to allow special startup code to be executed for a module to allow registration of a non standard codec for Unicode. It has though since also been used in the implementation of easy_install and if you have ever run easy-install and looked at the easy-install.pth file in the site-packages directory you will find some code which looks like:我被告知，这最初是为了允许为模块执行特殊的启动代码，以允许为Unicode注册一个非标准的编解码器。不过，它后来也被用于easy_install的实现中，如果您曾经运行过easy-install并查看了site-packages目录中的easy-install.pth文件，您会发现以下代码:123import sys; sys.__plen = len(sys.path)./antigravity-0.1-py2.7.eggimport sys; new=sys.path[sys.__plen:]; del sys.path[sys.__plen:]; p=getattr(sys,&apos;__egginsert&apos;,0); sys.path[p:p]=new; sys.__egginsert = p+len(new) So as long as you can fit the code on one line, you can potentially do some quite nasty stuff inside of a .pth file every time that the Python interpreter is run.因此，只要能够将代码放在一行上，就可以在每次运行Python解释器时，在.pth文件中做一些非常古怪的事情。 Personally I find the concept of executable code inside of a .pth file really dangerous and up until now have avoided relying on this feature of .pth files.我个人认为可执行代码在.pth文件中的概念是非常危险的，到目前为止，我一直避免依赖.pth文件的这个特性。 My concerns over executable code in .pth files is the fact that it is always run. This means that even if you had installed a pre built RPM/DEB package or a Python wheel into a system wide Python installation, with the idea that this was somehow much safer because you were avoiding running the setup.py file for a package as the root user, the .pth file means that the package can still subsequently run code without you realising and without you even having imported the module into any application.我对.pth文件中的可执行代码的担心是它总是在运行。这意味着，即使您已经将预构建的RPM/DEB包或Python wheel 安装到系统中的Python安装环境中，并且认为这样做更安全，因为避免了作为根用户运行 setup.py。但是.pth文件意味着包仍然可以在您不知情的情况下运行代码，甚至不需要将模块导入任何应用程序。 If one wanted to be paranoid about security, then Python should really have a whitelisting mechanism for what .pth files you wanted to trust and allow code to be executed from every time the Python interpreter is run, especially as the root user.考虑到安全性，Python真应该有一个白名单机制，用于确定信任哪些.pth文件，以允许其在每次运行Python解释器(特别是作为根用户)时执行代码。 I will leave that discussion up to others if anyone else cares to be concerned and for now at least will show how this feature of .pth files can be used (abused) to implement a mechanism for automated monkey patching of any Python application being run.如果有人关心的话，我将把这个讨论留给其他人来讨论，至少现在我将展示如何使用.pth文件的这个特性(滥用)来实现对正在运行的任何Python应用程序进行自动的猴子补丁的机制。 Adding Python import hooksIn the previous post where I talked about the post import hook mechanism, the code I gave as needing to be able to be manually added at the start of any Python application script file was:在前一篇文章中，我讨论了导入后钩子机制，在任何Python应用程序脚本文件的开头，我都需要手动添加的代码是:123456789101112import osfrom wrapt import discover_post_import_hookspatches = os.environ.get(&apos;WRAPT_PATCHES&apos;)if patches: for name in patches.split(&apos;,&apos;): name = name.strip() if name: print &apos;discover&apos;, name discover_post_import_hooks(name) What this was doing was using an environment variable as the source of names for any packages registered using setuptools entry points that contained monkey patches we wanted to have applied.它所做的是使用环境变量作为任何使用setuptools入口点注册的包的名称来源，这些入口点包含我们想要应用的猴子补丁。 Knowing about the ability to have executable code in .pth files, lets now work out how we can use that to instead have this code executed automatically every time the Python interpreter is run, thereby avoiding the need to manually modify every Python application we want to have monkey patches applied to.了解了可以在.pth文件执行代码的能力,现在可以使用它，让这段代码在Python解释器启动时自动执行,从而避免了每次都需要手动修改每个Python应用程序，来应用我们的猴子补丁。 In practice however, the code we will need is actually going to have to be slightly more complicated than this and as a result not something that can be readily added directly to a .pth file due to the limitation of code needing to all be on one line. What we will therefore do is put all our code in a separate module and execute it from there. We don’t want to be too nasty and import that module every time though, perhaps scaring users when they see it imported even if not used, so we will gate even that by the presence of the environment variable.但是在实践中，我们需要的代码实际上要比这个稍微复杂一些，并且不能很容易地直接添加到.pth文件中，这是由于需要将所有代码写在一行上。因此，我们要做的是将所有代码放在一个单独的模块中，然后执行该模块。我们不希望每次都导入那个模块，也许用户看到它被导入时会感到害怕，即使它没有被使用，所以我们将通过环境变量的判断使用它。 What we can therefore use in our ‘.pth’ is:因此，我们可以在我们的“.pth”中使用的是:1import os, sys; os.environ.get(&apos;AUTOWRAPT_BOOTSTRAP&apos;) and __import__(&apos;autowrapt.bootstrap&apos;) and sys.modules[&apos;autowrapt.bootstrap&apos;].bootstrap() That is, if the environment variable is set to a non empty value only then do we import our module containing our bootstrap code and execute it.也就是说，如果环境变量被设置为非空值，那么我们需要导入包含引导代码的模块并执行它。 As to the bootstrap code, this is where things get a bit messy. We can’t just use the code we had used before when manually modifying the Python application script file. This is because of where in the Python interpreter initialisation the parsing of .pth files is done.至于引导代码，这就有点麻烦了。我们不能只使用以前手动修改Python应用程序脚本文件时使用的代码。这是因为在Python解释器初始化中完成了.pth文件的解析。 The problems are twofold. The first issue with executing the discovery of the import hooks directly when the .pth file is processed is that the order in which they are processed is unknown and so at the point our code is run the final Python module search path may not have been setup. The second issue is that .pth file processing is done before any sitecustomize.py or usercustomize.py processing has been done. The Python interpreter therefore may not be in its final configured state. We therefore have to be a little bit careful of what we do.问题是双重的。第一个问题发生在执行导入钩子的发现，当.pth文件被执行时，它被处理的顺序是未知的，所以在我们的代码运行的时候，最终的Python模块搜索路径可能没有设置。第二个问题是.pth文件的处理发生在任何sitecustomize.py或usercustomize.py被处理完之前。因此，Python解释器可能不在其最终配置状态。因此，我们必须对我们所做的事情小心一点。 What we really want is to defer any actions until the Python interpreter initialisation has been completed. The problem is how we achieve that.我们真正需要的是将任何操作延迟到Python解释器的初始化完成之后。问题是我们如何做到这一点。 Python interpreter ‘site’ moduleThe actual final parts of Python interpreter initialisation is performed from the main() function of the site module:Python解释器初始化的实际最后部分由 site ll模块的main()函数执行:1234567891011121314151617181920212223def main(): global ENABLE_USER_SITE abs__file__() known_paths = removeduppaths() if ENABLE_USER_SITE is None: ENABLE_USER_SITE = check_enableusersite() known_paths = addusersitepackages(known_paths) known_paths = addsitepackages(known_paths) if sys.platform == &apos;os2emx&apos;: setBEGINLIBPATH() setquit() setcopyright() sethelper() aliasmbcs() setencoding() execsitecustomize() if ENABLE_USER_SITE: execusercustomize() # Remove sys.setdefaultencoding() so that users cannot change the # encoding after initialization. The test for presence is needed when # this module is run as a script, because this code is executed twice. if hasattr(sys, &quot;setdefaultencoding&quot;): del sys.setdefaultencoding The .pth parsing and code execution we want to rely upon is done within the addsitepackages() function.我们希望依赖的.pth解析和代码执行是在addsitepackages()函数中完成的。 What we really want therefore is to defer any execution of our code until after the functions execsitecustomize() or execusercustomize() are run. The way to achieve that is to monkey patch those two functions and trigger our code when they have completed.因此，我们真正需要的是将代码的任何执行推迟到execsitecustomize()中或execusercustomize()函数运行之后。实现这一点的方法是对这两个函数进行修改，并在它们完成时触发我们的代码。 We have to monkey patch both because the usercustomize.py processing is optional dependent on whether ENABLE_USER_SITE is true or not. Our ‘bootstrap() function therefore needs to look like:我们需要都打上补丁，因为usercustomize.py的执行是可选的，取决于ENABLE_USER_SITE环境变量是否为真。因此，我们的bootstrap()函数应该如下: 1234567891011121314151617181920def _execsitecustomize_wrapper(wrapped): def _execsitecustomize(*args, **kwargs): try: return wrapped(*args, **kwargs) finally: if not site.ENABLE_USER_SITE: _register_bootstrap_functions() return _execsitecustomizedef _execusercustomize_wrapper(wrapped): def _execusercustomize(*args, **kwargs): try: return wrapped(*args, **kwargs) finally: _register_bootstrap_functions() return _execusercustomizedef bootstrap(): site.execsitecustomize = _execsitecustomize_wrapper(site.execsitecustomize) site.execusercustomize = _execusercustomize_wrapper(site.execusercustomize) Despite everything I have ever said about how manually constructed monkey patches is bad and that the wrapt module should be used for doing monkey patching, we can’t actually use the wrapt module in this case. This is because technically, as a user installed package, the wrapt package may not be usable at this point. This could occur where wrapt was installed in such a way that the ability to import it was itself dependent on the processing of .pth files. As a result we drop down to using a simple wrapper using a function closure.尽管我曾经说过手工构建的猴子补丁有多糟糕，并且wrapt模块应该用于创建猴子补丁，但是在这种情况下，我们实际上不能使用wrapt模块。这是因为从技术上讲，作为用户安装的包，wrapt包此时可能不能使用。如果wrapt的安装方式是这样的，那么导入它的能力本身就依赖于.pth文件的处理。因此，我们使用一个函数闭包来使用简单的包装器。 In the actual wrappers, you can see how which of the two wrappers actually ends up calling _register_bootstrap_functions() is dependent on whether ENABLE_USER_SITE is true or not, only calling it in execsitecustomize() if support for usersitecustomize was enabled.在实际的包装器中，您可以看到两个包装器中哪个最终调用’ _register_bootstrap_functions() ‘取决于ENABLE_USER_SITE是否为真，如果启用了对usersitecustomize()的支持，那么只能在execsitecustomize()中调用它。 Finally we now have our _register_bootstrap_functions() defined as:最后，我们现在将’ _register_bootstrap_functions() ‘定义为:1234567891011_registered = Falsedef _register_bootstrap_functions(): global _registered if _registered: return _registered = True from wrapt import discover_post_import_hooks for name in os.environ.get(&apos;AUTOWRAPT_BOOTSTRAP&apos;, &apos;&apos;).split(&apos;,&apos;): discover_post_import_hooks(name) Bundling it up as a packageWe have worked out the various bits we require, but how do we get this installed, in particular how do we get the custom .pth file installed. For that we use a setup.py file of:我们已经解决了所需的各种位元，但是如何安装它，特别是如何安装自定义的.pth文件。为此我们使用一个设置.py文件:12345678910111213141516import sysimport osfrom setuptools import setupfrom distutils.sysconfig import get_python_libsetup_kwargs = dict( name = &apos;autowrapt&apos;, packages = [&apos;autowrapt&apos;], package_dir = &#123;&apos;autowrapt&apos;: &apos;src&apos;&#125;, data_files = [(get_python_lib(prefix=&apos;&apos;), [&apos;autowrapt-init.pth&apos;])], entry_points = &#123;&apos;autowrapt.examples’: [&apos;this = autowrapt.examples:autowrapt_this&apos;]&#125;, install_requires = [&apos;wrapt&gt;=1.10.4&apos;],)setup(**setup_kwargs) To get that .pth installed we have used the data_files argument to the setup() call. The actual location for installing the file is determined using the get_python_lib() function from the distutils.sysconfig module. The prefix’ argument of an empty string ensures that a relative path for the site-packages directory where Python packages should be installed is used rather than an absolute path.为了安装.pth，我们使用了setup()调用的data_files参数。使用distutils.sysconfig模块中的get_python_lib()函数确定安装文件的实际位置。前缀“空字符串”的参数确保了Python包安装的路经为 site-packages 的相对路径，而不是绝对路径。 Very important when installing this package though is that you cannot use easy_install or python setup.py install. One can only install this package using pip.安装这个包时非常重要的一点是，您不能使用easy_install或python setup.py安装。只能使用pip安装这个包。 The reason for this is that if not using pip, then the package installation tool can install the package as an egg. In this situation the custom .pth file will actually be installed within the egg directory and not actually within the site-packages directory.这样做的原因是，如果不使用pip，那么包安装工具可以将包安装为egg。在这种情况下，自定义.pth文件实际上将安装在egg目录中，而不是实际安装在site-packages目录中。 The only .pth file added to the site-packages directory will be that used to map that the autowrapt package exists in the sub directory. The addsitepackages() function called from the site module doesn’t in turn process .pth files contained in a directory added by a .pth file, so our custom .pth file would be skipped..pth文件只有被添加到 site-packages 目录中，才能用于映射autowrapt包存在的子目录。从site模块调用的addsitepackages()函数并不会处理包含在.pth文件添加的目录中的.pth文件，因此我们的自定义.pth文件将被跳过。 When using ‘pip’ it doesn’t use eggs by default and so we are okay.在使用“pip”时，默认情况下不使用eggs，所以我们可以。 Also do be aware that this package will not work with buildout as it will always install packages as eggs and explicitly sets up the Python module search path itself in any Python scripts installed into the Python installation.还要注意的是，这个包不会与buildout一起工作，因为它总是将包作为eggs安装，并且在Python 安装环境中安装任何脚本时，都会显式地设置Python模块搜索路径本身。 Trying out an exampleThe actual complete source code for this package can be found at:此软件包的实际完整源代码可在: https://github.com/GrahamDumpleton/autowrapt The package has also been released on PyPi as autowrapt so you can actually try it, and use it if you really want to.这个包也在PyPi上作为autowrapt发布，因此您可以尝试它，如果您真的想使用它的话。 To allow for a easy quick test to see that it works, the autowrapt package bundles an example monkey patch. In the above setup.py this was set up by:为了方便快速地测试它是否有效，autowrapt包打包了一个示例monkey patch。在上面的setyp.py被设置如下: entry_points = {‘autowrapt.examples’: [‘this = autowrapt.examples:autowrapt_this’]}, This entry point definition names a monkey patch with the name autowrapt.examples. The definition says that when the this module is installed, the monkey patch function autowrapt_this() in the module autowrapt.examples will be called.这个entry point 定义了一个名为autowrapt.examples的猴子补丁。定义了当导入 this 模块时，模块autowrapt.examples中的猴子补丁函数autowrapt_this()将被执行。 So to run the test do:所以要运行这个测试需要: pip install autowrapt This should also install the wrapt module if you don’t have the required minimum version.如果没有所需的最小版本，也应该安装wrapt模块。 Now run the command line interpreter as normal and at the prompt do:现在正常运行命令行解释器，并在提示符处执行: import this This should result in the Zen of Python being displayed.这应该会显示Python的Zen。 Exit the Python interpreter and now instead run:退出Python解释器，现在运行: AUTOWRAPT_BOOTSTRAP=autowrapt.examples python This runs the Python interpreter again, but also sets the environment variable AUTOWRAPT_BOOTSTRAP with the value autowrapt.examples matching the name of the entry point defined in the setup.py file for autowrapt’.这将再次运行Python解释器，并将环境变量AUTOWRAPT_BOOTSTRAP设置为autowrapt.examples,以匹配在setup.py中为autowrapt定义的entry point。 The actual code for the ‘autowrapt_this()’ function was:“autowrapt_this()”函数的实际代码是: 1234from __future__ import print_functiondef autowrapt_this(module): print(&apos;The wrapt package is absolutely amazing and you should use it.&apos;) so if we now again run:所以如果我们再一次运行 import this we should now see an extended version of the Zen of Python.我们现在应该看到Python Zen的扩展版本。 We didn’t actually monkey patch any code in the target module in this case, but it shows that the monkey patch function was actually triggered when expected.在本例中，我们实际上并没有对目标模块中的任何代码打补丁，但它显示了补丁函数实际上是按预期被触发。 Other bootstrapping mechanismsAlthough this mechanism is reasonably clean and only requires the setting of an environment variable, it cannot be used with buildout as mentioned. For buildout we need to investigate other approaches we could use to achieve the same affect. I will cover such other options in the next blog post on this topic.虽然这种机制相当干净，并且只需要设置环境变量，但是不能像前面提到的那样与buildout一起使用。对于buildout，我们需要研究其他可以实现同样效果的方法。我将在下一篇关于这一主题的博文中讨论这些其他选择。]]></content>
      <categories>
        <category>函数装饰器</category>
        <category>猴子补订</category>
        <category>wrapt</category>
      </categories>
      <tags>
        <tag>python 标准库</tag>
        <tag>译文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[13 Ordering issues when monkey patching in Python]]></title>
    <url>%2F2018%2F06%2F04%2Fwrapt%2F13-ordering-issues-when-monkey-patching-in-python%2F</url>
    <content type="text"><![CDATA[本系列 blog 与 python wrat 模块相关，深入介绍了 Python 装饰器，猴子补订等相关内容，翻译于 https://github.com/GrahamDumpleton/wrapt/tree/master/blog 本篇内容: 通过导入后钩子，延迟导入和 setuptools 解决猴子补丁与被打补丁模块之间由于相对导入次序引发的猴子补丁未生效问题 Ordering issues when monkey patching in PythonIn my recent post about safely applying monkey patches in Python, I mentioned how one of the issues that arises is when a monkey patch is applied. Specifically, if the module you need to monkey patch has already been imported and was being used by other code, that it could have created a local reference to a target function you wish to wrap, in its own namespace. So although your monkey patch would work fine where the original function was used direct from the module, you would not cover where it was used via a local reference.在我最近关于在Python中安全地应用猴子补丁的文章中，我提到了应用猴子补丁时可能存在的问题。具体地说，如果需要被打补丁的模块已经被导入并被其他代码使用，那么它可能已经在自己的名称空间中创建了一个被打补丁的目标函数的本地引用。因此，尽管您的猴子补丁可以正常工作，但是仍然无法覆盖这种原始函数已经直接从，并过通过本地引用直接访问原函数的情况。 Coincidentally, Ned Batchelder recently posted about using monkey patching to debug an issue where temporary directories were not being cleaned up properly. Ned described this exact issue in relation to wanting to monkey patch the ‘mkdtemp()’ function from the ‘tempfile’ module. In that case he was able to find an alternate place within the private implementation for the module to patch so as to avoid the problem. Using some internal function like this may not always be possible however.碰巧的是，Ned Batchelder最近发布了关于使用猴子补丁来调试临时目录没有被正确清理的问题。Ned描述的正是对“tempfile”模块中的“mkdtemp()”函数进行修补出现的问题。在这种情况下，他能够在模块的私有实现中找到一个替代的位置，以避免出现问题。然而，使用这样的内部函数可能并不总是可行的。 What I want to start discussing with this post is mechanisms one can use from wrapt to deal with this issue of ordering. A major part of the solution is what are called post import hooks. This is a mechanism which was described in PEP 369 and although it never made it into the Python core, it is still possible to graft this ability into Python using existing APIs. From this we can then add additional capabilities for discovering monkey patching code and automatically apply it when modules are imported, before other modules get the module and so before they can create a reference to a function in their own namespace.我想从这篇文章开始讨论wrapt用来处理导入次序问题的机制。解决方案的一个主要部分是所谓的后导入钩子。这是在PEP 369中描述的一种机制，虽然它从未进入Python核心，但是仍然可以使用现有的api将这种能力移植到Python中。然后，在其他模块获得模块之前，以及在它们可以在自己的名称空间中创建对函数的引用之前，我们可以添加其他功能来发现猴子补丁代码，并在导入模块时自动应用它。 Post import hook mechanismIn PEP 369, a primary use case presented was illustrated by the example:PEP 369中一个主要的示例展示如下:12345import imp@imp.when_imported(&apos;decimal&apos;)def register(decimal): Inexact.register(decimal.Decimal) The basic idea is that when this code was seen it would cause a callback to be registered within the Python import system such that when the ‘decimal’ module was imported, that the ‘register()’ function which the decorator had been applied to, would be called. The argument to the ‘register()’ function would be the reference to the module the registration had been against. The function could then perform some action against the module before it was returned to whatever code originally requested the import.其基本思想是，当看到这段代码时，它将导致在Python导入系统中注册一个回调，以便在导入‘decimal’模块时，调用装饰器应用的‘register()’函数。“register()”函数的参数是对被注册的模块的引用。然后，该函数可以对模块执行一些操作，最后再将模块返回到最初请求导入的代码中。 Instead of using the decorator ‘@imp.when_imported’ decorator, one could also explicitly use the ‘imp.register_post_import_hook()’ function to register a post import hook.除了使用作为装饰器的’@imp.where_imported’函数 ，还可以显式地使用’imp.register_post_import_hook()’函数来注册导入后钩子。123456import impdef register(decimal): Inexact.register(decimal.Decimal)imp.register_post_import_hook(register, &apos;decimal&apos;) Although PEP 369 was never incorporated into Python, the wrapt module provides implementations for both the decorator and the function, but within the ‘wrapt’ module rather than ‘imp’.尽管PEP 369从未被合并到Python中，但是wrapt 提供了类似功能的装饰器和函数。 Now what neither the decorator or the function really solved alone was the ordering issue. That is, you still had the problem that these could be triggered after the target module had already been imported. In this case the post import hook function would still be called, albeit for our case too late to get in before the reference to the function we want to monkey patch had been created in a different namespace.尽管装饰器和函数被用来解决导入次序问题。但如果目标模块在导入后钩子函数执行之前就已经被导入，我们仍会面临导入次序问题。 The simplest solution to this problem is to modify the main Python script for your application and setup all the post import hook registrations you need as the absolute very first thing that is done. That is, before any other modules are imported from your application or even modules from the standard library used to parse any command line arguments.这个问题最简单的解决方案是修改应用程序的主Python脚本，并将您需要的所有post import hook注册设置为绝对的第一件事。也就是说，在从应用程序导入任何其他模块或甚至从用于解析任何命令行参数的标准库中导入模块之前。 Even if you are able to do this, because though the registration functions require an actual callable, it does mean you are preloading the code to perform all the monkey patches. This could be a problem if they in turn had to import further modules as the state of your application may not yet have been setup such that those imports would succeed.尽管你确实可以做到这一点，但是由于注册函数会发生事实上的调用，这意味着你将预加载所有猴子补丁。由于猴子补丁可能转而导入那些未被导入的应用程序模块，所以可能会导入错误。 They say though that one level of indirection can solve all problems and this is an example of where that principle can be applied. That is, rather than import the monkey patching code, you can setup a registration which would only lazily load the monkey patching code itself if the module to be patched was imported, and then execute it.有一种间接的方式可以解决所有的问题，下面是应用这个原则的例子。即相对于导入猴子补丁代码，不如设置一个注册，如果要进行补丁的模块被导入，那么这个注册只会延迟加载猴子补丁代码本身，然后执行它。123456789101112import sysfrom wrapt import register_post_import_hookdef load_and_execute(name): def _load_and_execute(target_module): __import__(name) patch_module = sys.modules[name] getattr(patch_module, &apos;apply_patch&apos;)(target_module) return _load_and_executeregister_post_import_hook(load_and_execute(&apos;patch_tempfile&apos;), &apos;tempfile&apos;) In the module file ‘patch_tempfile.py’ we would now have:patch_tempfile.py代码如下: 123456789from wrapt import wrap_function_wrapperdef _mkdtemp_wrapper(wrapped, instance, args, kwargs): print &apos;calling&apos;, wrapped.__name__ return wrapped(*args, **kwargs)def apply_patch(module): print &apos;patching&apos;, module.__name__ wrap_function_wrapper(module, &apos;mkdtemp&apos;, _mkdtemp_wrapper) Running the first script with the interactive interpreter so as to leave us in the interpreter, we can then show what happens when we import the ‘tempfile’ module and execute the ‘mkdtemp()’ function.使用交互式解释器运行第一个脚本，以便将我们留在解释器中，然后，我们可以显示导入“tempfile”模块并执行“mkdtemp()”函数，看看会发生什么。123456$ python -i lazyloader.py&gt;&gt;&gt; import tempfilepatching tempfile&gt;&gt;&gt; tempfile.mkdtemp()calling mkdtemp&apos;/var/folders/0p/4vcv19pj5d72m_bx0h40sw340000gp/T/tmpfB8r20&apos; In other words, unlike how most monkey patching is done, we aren’t forcibly importing a module in order to apply the monkey patches on the basis it might be used. Instead the monkey patching code stays dormant and unused until the target module is later imported. If the target module is never imported, the monkey patch code for that module is itself not even imported.换句话说，与大多数猴子补丁不同，我们并不是强行导入一个模块，以便在可能使用的基础上应用猴子补丁。相反，猴子补丁代码保持休眠和未使用，直到目标模块稍后被导入。如果没有导入目标模块，则该模块的猴子补丁代码本身甚至没有导入。 Discovery of post import hooksPost import hooks as described provide a slightly better way of setting up monkey patches so they are applied. This is because they are only activated if the target module containing the function to be patched is even imported. This avoids unnecessarily importing modules you may not even use, and which otherwise would increase memory usage of your application.如所述，后导入钩子提供了一种稍微更好的方法来设置猴子补丁，以便应用它们。这是因为只有当包含要修补的函数的目标模块被导入时，它们才会被激活。这避免了不必要地导入可能不使用的模块，否则会增加应用程序的内存使用。 Ordering is still important and as a result it is important to ensure that any post import hook registrations are setup before any other modules are imported. You also need to modify your application code every time you want to change what monkey patches are applied. This latter point could be inconvenient if only wanting to add monkey patches infrequently for the purposes of debugging issues.导入次序仍然很重要，因此，要确保在导入任何其他模块之前设置所有导入后钩子。并且在每次更改应用的猴子补丁后，需要修改应用程序代码。如果只是为了调试问题而频繁地添加猴子补丁，则可能不太方便。 A solution to the latter issue is to separate out monkey patches into separately installed modules and use a registration mechanism to announce their availability. Python applications could then have common boiler plate code executed at the very start which discovers based on supplied configuration what monkey patches should be applied. The registration mechanism would then allow the monkey patch modules to be discovered at runtime.后一个问题的解决方案是将猴子补丁分离到单独的模块中，并使用一个注册机制来宣布它们的可用性。然后，Python应用程序可以在一开始就执行通用的模板代码，该代码根据提供的配置发现应该应用哪些猴子补丁。注册机制将允许在运行时发现猴子补丁模块。 One particular registration mechanism which can be used here is ‘setuptools’ entry points. Using this we can package up monkey patches so they could be separately installed ready for use. The structure of such a package would be:这里可以使用的一种特殊的注册机制是“setuptools”入口点。使用这个我们可以打包猴子补丁，这样它们就可以被单独安装以备使用。这样一套方案的结构是:123setup.pysrc/__init__.pysrc/tempfile_debugging.py The ‘setup.py’ file for this package will be:这个包的 setup.py 代码将会是:123456789101112131415161718192021from setuptools import setupNAME = &apos;wrapt_patches.tempfile_debugging&apos;def patch_module(module, function=None): function = function or &apos;patch_%s&apos; % module.replace(&apos;.&apos;, &apos;_&apos;) return &apos;%s = %s:%s&apos; % (module, NAME, function)ENTRY_POINTS = [ patch_module(&apos;tempfile&apos;),]setup_kwargs = dict( name = NAME, version = &apos;0.1&apos;, packages = [&apos;wrapt_patches&apos;], package_dir = &#123;&apos;wrapt_patches&apos;: &apos;src&apos;&#125;, entry_points = &#123; NAME: ENTRY_POINTS &#125;,)setup(**setup_kwargs) As a convention so that our monkey patch modules are easily identifiable we use a namespace package. The parent package in this case will be ‘wrapt_patches’ since we are working with wrapt specifically.作为一种约定，我们使用命名空间包，以便我们的猴子补丁模块易于识别。在本例中，父包将是“wrapt_patch”，因为我们专门使用wrapt。 The name for this specific package will be ‘wrapt_patches.tempfile_debugging’ as the theoretical intent is that we are going to create some monkey patches to help us debug use of the ‘tempfile’ module, along the lines of what Ned described in his blog post.这个特定包的名称将是“wrapt_patch.tempfile_debug“,表示我们将创建一些猴子补丁，以帮助我们调试使用“tempfile”模块，正如Ned的博客文章中所描述的。 The key part of the ‘setup.py’ file is the definition of the ‘entry_points’. This will be set to a dictionary mapping the package name to a list of definitions listing what Python modules this package contains monkey patches for.‘setup.py’的关键部分是定义’entry_points’。它将被设置程包名到一个列表的映射，这个列表包含了这个补丁模块要作用的所有目标Python模块。 The ‘src/init.py’ file will then contain:‘src/init.py’ 将包含:12import pkgutil__path__ = pkgutil.extend_path(__path__, __name__) as is required when creating a namespace package.这是创建命名空间包的要求 Finally, the monkey patches will actually be contained in ‘src/tempfile_debugging.py’ and for now is much like what we had before.最后，猴子补丁实际上包含在“src/tempfile_debug”中。代码跟以前很像。123456789from wrapt import wrap_function_wrapperdef _mkdtemp_wrapper(wrapped, instance, args, kwargs): print &apos;calling&apos;, wrapped.__name__ return wrapped(*args, **kwargs)def patch_tempfile(module): print &apos;patching&apos;, module.__name__ wrap_function_wrapper(module, &apos;mkdtemp&apos;, _mkdtemp_wrapper) With the package defined we would install it into the Python installation or virtual environment being used.定义了包后，我们将它安装到正在使用的Python安装或虚拟环境中。 In place now of the explicit registrations which we previously added at the very start of the Python application main script file, we would instead add:现在，我们可以在Python应用程序主脚本文件的开头添加显式的注册，我们将添加:123456789101112import osfrom wrapt import discover_post_import_hookspatches = os.environ.get(&apos;WRAPT_PATCHES&apos;)if patches: for name in patches.split(&apos;,&apos;): name = name.strip() if name: print &apos;discover&apos;, name discover_post_import_hooks(name) If we were to run the application with no specific configuration to enable the monkey patches then nothing would happen. If however they were enabled, then they would be automatically discovered and applied as necessary.如果我们在没有为猴子补丁特定配置的情况下运行应用程序，那么什么也不会发生。如果它们是启用的，那么它们将被自动发现并根据需要应用。1234$ WRAPT_PATCHES=wrapt_patches.tempfile_debugging python -i entrypoints.pydiscover wrapt_patches.tempfile_debugging&gt;&gt;&gt; import tempfilepatching tempfile What would be ideal is if PEP 369 ever did make it into the core of Python that a similar bootstrapping mechanism be incorporated into Python itself so that it was possible to force registration of monkey patches very early during interpreter initialisation. Having this in place we would have a guaranteed way of addressing the ordering issue when doing monkey patching.理想的情况是，如果PEP 369真的进入了Python的核心，那么将类似的引导机制合并到Python本身中，以便在解释器初始化过程中尽早强制对猴子补丁进行注册。有了这一点，我们就有了一种有保证的方法来解决在做猴子补丁时的导入次序问题。 As that doesn’t exist right now, what we did in this case was modify our Python application to add the bootstrap code ourselves. This is fine where you control the Python application you want to be able to potentially apply monkey patches to, but what if you wanted to monkey patch a third party application and you didn’t want to have to modify its code. What are the options in that case?由于现在还不存在这种情况，所以我们在本例中所做的是修改Python应用程序以自己添加引导代码。在控制您希望能够应用猴子补丁的Python应用程序时，这是可以的，但是如果您想要对第三方应用程序进行打补丁，并且不希望修改其代码，那该怎么办呢?在这种情况下有什么选择? As it turns out there are some tricks that can be used in that case. I will discuss such options for monkey patching a Python application you can’t actually modify in my next blog post on this topic of monkey patching.事实证明，在这种情况下可以使用一些技巧。我将在我的下一篇关于猴子补丁主题的博文中讨论为应用程序打补丁的可用选项。]]></content>
      <categories>
        <category>函数装饰器</category>
        <category>猴子补订</category>
        <category>wrapt</category>
      </categories>
      <tags>
        <tag>python 标准库</tag>
        <tag>译文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[12 Using wrapt to support testing of software]]></title>
    <url>%2F2018%2F06%2F03%2Fwrapt%2F12-using-wrapt-to-support-testing-of-software%2F</url>
    <content type="text"><![CDATA[本系列 blog 与 python wrat 模块相关，深入介绍了 Python 装饰器，猴子补订等相关内容，翻译于 https://github.com/GrahamDumpleton/wrapt/tree/master/blog 本篇内容: 如何将 wrapt 用于测试，和 wrapt 与 mock 实现的对比 Using wrapt to support testing of softwareWhen talking about unit testing in Python, one of the more popular packages used to assist in that task is the Mock package. I will no doubt be labelled as a heretic but when I have tried to use it for things it just doesn’t seem to sit right with my way of thinking.在Python中讨论单元测试时，用于辅助该任务的比较流行的包之一是 mock 包。毫无疑问，我会被贴上异教徒的标签，但当我试图用它来做一些事情时，它似乎并不符合我的思维方式。 It may also just be that what I am trying to apply it to isn’t a good fit. In what I want to test it usually isn’t so much that I want to mock out lower layers, but more that I simply want to validate data being passed through to the next layer or otherwise modify results. In other words I usually still need the system as a whole to function end to end and possibly over an extended time.也可能只是我试图应用它的东西不太适合。在我想要测试的内容中，通常我不仅想要模拟更低的层，而且我想要验证传递到下一层的数据，或者修改结果。换句话说，我通常仍然需要系统作为一个整体来结束，并可能在很长一段时间内。 So for the more complex testing I need to do I actually keep falling back on the monkey patching capabilities of wrapt. It may well just be that since I wrote wrapt that I am more familiar with its paradigm, or that I prefer the more explicit way that wrapt requires you to do things. Either way, for me at least wrapt helps me to get the job done quicker.因此，对于我需要做的更复杂的测试，我实际上一直在依靠wrapt的猴子补丁功能。很有可能，因为我写了wrapt，我更熟悉它的范例，或者我更倾向于更明确的方式，而wrapt要求你做一些事情。不管怎样，至少对我来说，wrapt能帮助我更快地完成工作。 To explain a bit more about the monkey patching capabilities of wrapt, I am in this blog post going to show how some of the things you can do in Mock you can do with wrapt. Just keep in mind that I am an absolute novice when it comes to Mock and so I could also just be too dumb to understand how to use it properly for what I want to do easily.为了进一步解释wrapt的猴子补丁功能，我在这篇博客文章中向大家展示了用wrapt模块实现部分 Mock 包的功能。只要记住，对于Mock模块我是一个绝对的新手，也可能也我太笨了，不能理解如何正确简单地使用它来做我想做的事情。 Return values and side effectsIf one is using Mock and you want to temporarily override the value returned by a method of a class when called, one way is to use:如果你正在使用Mock，并且希望在调用时临时覆盖类的方法返回的值，一种方法是:123456789101112from mock import Mock, patchclass ProductionClass(object): def method(self, a, b, c, key): print a, b, c, key@patch(__name__+&apos;.ProductionClass.method&apos;, return_value=3)def test_method(mock_method): real = ProductionClass() result = real.method(3, 4, 5, key=&apos;value&apos;) mock_method.assert_called_with(3, 4, 5, key=&apos;value&apos;) assert result == 3 With what I have presented so far of the wrapt package, an equivalent way of doing this would be:就我迄今为止提出的wrapt包而言，一种类似的做法是: 123456789101112131415from wrapt import patch_function_wrapperclass ProductionClass(object): def method(self, a, b, c, key): print a, b, c, key@patch_function_wrapper(__name__, &apos;ProductionClass.method&apos;)def wrapper(wrapped, instance, args, kwargs): assert args == (3, 4, 5) and kwargs.get(&apos;key&apos;) == &apos;value&apos; return 3def test_method(): real = ProductionClass() result = real.method(3, 4, 5, key=&apos;value&apos;) assert result == 3 An issue with this though is that the ‘wrapt.patch_function_wrapper()’ function I previously described applies a permanent patch. This is okay where it does need to survive for the life of the process, but in the case of testing we usually want to only have a patch apply to the single unit test function being run at that time. So the patch should be removed at the end of that test and before the next function is called.不过，这里的一个问题是，我前面描述的“wrapt.patch_function_wrapper()”函数应用了一个永久补丁。在这个过程的生命周期中，这是可以的，但是在测试的情况下，我们通常希望一个补丁只应用于当时正在运行的单个单元测试函数。因此，补丁应该在测试结束时和调用下一个函数之前应该被删除。 For that scenario, the wrapt package provides an alternate decorator ‘@wrapt.transient_function_wrapper’. This can be used to create a wrapper function that will only be applied for the scope of a specific call that the decorated function is applied to. We can therefore write the above as:对于该场景，wrapt包提供了另一个装饰器“@wrapt.transient_function_wrapper”。用来创建一个包装函数，该函数只应用于修饰函数所应用的特定调用的范围。因此，我们可以把上面写为:12345678910111213141516from wrapt import transient_function_wrapperclass ProductionClass(object): def method(self, a, b, c, key): print a, b, c, key@transient_function_wrapper(__name__, &apos;ProductionClass.method&apos;)def apply_ProductionClass_method_wrapper(wrapped, instance, args, kwargs): assert args == (3, 4, 5) and kwargs.get(&apos;key&apos;) == &apos;value&apos; return 3@apply_ProductionClass_method_wrapperdef test_method(): real = ProductionClass() result = real.method(3, 4, 5, key=&apos;value&apos;) assert result == 3 Although this example shows how to return a substitute for the method being called, the more typical case is that I still want to call the original wrapped function. Thus, perhaps validating the arguments being passed in or the return value being passed back from the lower layers.尽管这个示例展示了如何返回要调用的方法的替代品，但更典型的情况是，我仍然希望调用原始的包装函数。因此，可能验证传入的参数或从底层返回的返回值。 For this blog post when I tried to work out how to do that with Mock the general approach I came up with was the following.当我尝试用Mock解决这个问题时，我想到的一般方法如下。 1234567891011121314151617from mock import Mock, patchclass ProductionClass(object): def method(self, a, b, c, key): print a, b, c, keydef wrapper(wrapped): def _wrapper(self, *args, **kwargs): assert args == (3, 4, 5) and kwargs.get(&apos;key&apos;) == &apos;value&apos; return wrapped(self, *args, **kwargs) return _wrapper@patch(__name__+&apos;.ProductionClass.method&apos;, autospec=True, side_effect=wrapper(ProductionClass.method))def test_method(mock_method): real = ProductionClass() result = real.method(3, 4, 5, key=&apos;value&apos;) There were two tricks here. The first is the ‘autospec=True’ argument to ‘@Mock.patch’ to have it perform method binding, and the second being the need to capture the original method from the ‘ProductionClass’ before any mock had been applied to it, so I could then in turn call it when the side effect function for the mock was called.这里有两个技巧。第一个是@Mock.path 的 ‘autospec=True’参数’，执行方法绑定，第二个是需要在对它应用任何mock之前从’ProductionClass’捕获原始方法，这样当调用mock的副作用函数时，我就可以反过来调用它。 No doubt someone will tell me that I am doing this all wrong and there is a simpler way, but that is the best I could come up with after 10 minutes of reading the Mock documentation.毫无疑问，有人会告诉我，我做错了，有一种更简单的方法，但这是我在阅读模拟文档10分钟后所能想到的最好的方法。 When using wrapt to do the same thing, what is used is little different to what was used when mocking the return value. This is because the wrapt function wrappers will work with both normal functions or methods and so nothing special has to be done when wrapping methods. Further, when the wrapt wrapper function is called, it is always passed the original function which was wrapped, so no magic is needed to stash that away.当使用wrapt执行相同的操作时，使用的方式与模拟返回值没有什么不同。这是因为wrapt函数包装器能同时适用普通函数或方法，所以在包装方法时不需要额外处理。此外，当调用wrapt包装函数时，它总是传递被包装的原始函数，因此不需要使用任何魔法来隐藏它。 123456789101112131415from wrapt import transient_function_wrapperclass ProductionClass(object): def method(self, a, b, c, key): print a, b, c, key@transient_function_wrapper(__name__, &apos;ProductionClass.method&apos;)def apply_ProductionClass_method_wrapper(wrapped, instance, args, kwargs): assert args == (3, 4, 5) and kwargs.get(&apos;key&apos;) == &apos;value&apos; return wrapped(*args, **kwargs)@apply_ProductionClass_method_wrapperdef test_method(): real = ProductionClass() result = real.method(3, 4, 5, key=&apos;value&apos;) Using this ability to easily intercept a call to perform validation of data being passed, but still call the original, I can relatively easily create a whole bunch of decorators for performing validation on data as is it is passed through different parts of the system. I can then stack up these decorators on any test function that I need to add them to.使用此功能可以轻松地拦截调用来执行传递的数据的验证，但仍然调用原始数据，我可以相对轻松地创建一大堆装饰器，以便对数据执行验证，因为数据可能是通过系统的不同部分传递的。然后，我可以将这些装饰器堆叠在任何需要添加它们的测试函数上。 Wrapping of return valuesThe above recipes cover being able to return a fake return value, returning the original, or some slight modification of the original where it is some primitive data type or collection. In some cases though I actually want to put a wrapper around the return value to modify how subsequent code interacts with it.上面的示例包括能够返回一个假的返回值，返回原始值，或者在部分原始数据类型或集合上进行一些轻微的修改。但在某些情况下，我实际上希望在返回值周围放置一个包装器，以修改后续代码与返回值的交互方式。 The first example of this is where the wrapped function returns another function which would then be called by something higher up the call chain. Here I may want to put a wrapper around the returned function to allow me to then intercept when it is called.第一个例子是包装函数返回另一个函数，这个函数将被调用链中更高的函数调用。在这里，我可能想在返回的函数周围放置一个包装器，以便在调用它时拦截它。 In the case of using Mock I would do something like:Mock 包的使用方式:1234567891011121314151617181920212223242526from mock import Mock, patchdef function(): passclass ProductionClass(object): def method(self, a, b, c, key): return functiondef wrapper2(wrapped): def _wrapper2(*args, **kwargs): return wrapped(*args, **kwargs) return _wrapper2def wrapper1(wrapped): def _wrapper1(self, *args, **kwargs): func = wrapped(self, *args, **kwargs) return Mock(side_effect=wrapper2(func)) return _wrapper1@patch(__name__+&apos;.ProductionClass.method&apos;, autospec=True, side_effect=wrapper1(ProductionClass.method))def test_method(mock_method): real = ProductionClass() func = real.method(3, 4, 5, key=&apos;value&apos;) result = func() And with wrapt I would instead do:wrapt 包的使用方式: 12345678910111213141516171819202122from wrapt import transient_function_wrapper, function_wrapperdef function(): passclass ProductionClass(object): def method(self, a, b, c, key): return function@function_wrapperdef result_function_wrapper(wrapped, instance, args, kwargs): return wrapped(*args, **kwargs)@transient_function_wrapper(__name__, &apos;ProductionClass.method&apos;)def apply_ProductionClass_method_wrapper(wrapped, instance, args, kwargs): return result_function_wrapper(wrapped(*args, **kwargs))@apply_ProductionClass_method_wrapperdef test_method(): real = ProductionClass() func = real.method(3, 4, 5, key=&apos;value&apos;) result = func() In this example I have used a new decorator called ‘@wrapt.function_wrapper’. I could also have used ‘@wrapt.decorator’ in this example. The ‘@wrapt.function_wrapper’ decorator is actually just a cut down version of ‘@wrapt.decorator’, lacking some of the bells and whistles that one doesn’t generally need when doing explicit monkey patching, but otherwise it can be used in the same way.在本例中，我使用了一个名为“@wrapt.function_wrapper”的新装饰器。在本例中，我还可以使用“@wrapt.decorator”。“@wrapt.function_wrapper’ decorator实际上只是’@wrapt.decorator’的一个简化版本，它缺少一些在做显式的猴子补丁时通常不需要的铃铛和口子，但除此之外，它也可以用同样的方式使用。 I can therefore apply a wrapper around a function returned as a result. I could could even apply the same principal where a function is being passed in as an argument to some other function.因此，我可以对结果返回的函数应用一个包装器。我甚至可以应用相同的原理应用在当函数作为参数传递给另一个函数时。 A different scenario to a function being returned is where an instance of a class is returned. In this case I may want to apply a wrapper around a specific method of just that instance of the class.返回函数的另一个场景是返回类的实例。在这种情况下，我可能想要对类的实例的特定方法应用一个包装器。 With the Mock library it again comes down to using its ‘Mock’ class and having to apply it in different ways to achieve the result you want. I am going to step back from Mock now though and just focus on how one can do things using wrapt.在mock 包中，需要再次使用“Mock”类，并且必须以不同的方式应用它来实现您想要的结果。现在我将不再关注mock，只关注wrapt的实现方式。 So, depending on the requirements there are a couple of ways one could do this with wrapt.所以，根据需求，有几种方法可以用wrapt来实现。 The first approach is to replace the method on the instance directly with a wrapper which encapsulates the original method.第一个方法是用封装原始方法的包装器直接替换实例上的方法。123456789101112131415161718192021222324252627from wrapt import transient_function_wrapper, function_wrapperclass StorageClass(object): def run(self): passstorage = StorageClass()class ProductionClass(object): def method(self, a, b, c, key): return storage@function_wrapperdef run_method_wrapper(wrapped, instance, args, kwargs): return wrapped(*args, **kwargs)@transient_function_wrapper(__name__, &apos;ProductionClass.method&apos;)def apply_ProductionClass_method_wrapper(wrapped, instance, args, kwargs): storage = wrapped(*args, **kwargs) storage.run = run_method_wrapper(storage.run) return storage@apply_ProductionClass_method_wrapperdef test_method(): real = ProductionClass() data = real.method(3, 4, 5, key=&apos;value&apos;) result = data.run() This will create the desired result but in this example actually turns out to be a bad way of doing it.这样可以得到想要的结果，但在本例中，实际上是一种糟糕的方法。 The problem in this case is that the object being returned is one which has a life time beyond the test. That is, we are modifying an object stored at global scope and which might be used for a different test. By simply replacing the method on the instance, we have made a permanent change.在这种情况下，问题是返回的对象是一个在测试之外有生命时间的对象。也就是说，我们正在修改一个存储在全局范围内的对象，该对象可能用于其他测试。通过简单地替换实例上的方法，我们进行了永久性的更改。 This would be okay if it was a temporary instance of a class created on demand just for that one call, but not where it is persistent like in this case.如果它是一个仅为一次调用而按需创建的类的临时实例，那么这是可以的，但是在这种情况下，它是持久的。 We can’t therefore modify the instance itself, but need to wrap the instance in some other way to intercept the method call.因此，我们不能修改实例本身，但需要以其他方式封装实例来拦截方法调用。 To do this we make use of what is called an object proxy. This is a special object type which we can create an instance of to wrap another object. When accessing the proxy object, any attempts to access attributes will actually return the attribute from the wrapped object. Similarly, calling a method on the proxy will call the method on the wrapped object.为此，我们使用了所谓的对象代理。这是一个特殊的对象类型，我们可以创建一个实例来包装另一个对象。当访问代理对象时，任何访问属性的尝试都会从包装对象返回属性。类似地，调用代理上的方法将调用包装对象上的方法。 Having a distinct proxy object though allows us to change the behaviour on the proxy object and so change how code interacts with the wrapped object. We can therefore avoid needing to change the original object itself.但是，拥有一个不同的代理对象允许我们更改代理对象上的行为，从而更改代码与包装对象的交互方式。因此，我们可以避免更改原始对象本身。 For this example what we can therefore do is:因此，对于这个例子，我们可以做的是:1234567891011121314151617181920212223242526from wrapt import transient_function_wrapper, ObjectProxyclass StorageClass(object): def run(self): passstorage = StorageClass()class ProductionClass(object): def method(self, a, b, c, key): return storageclass StorageClassProxy(ObjectProxy): def run(self): return self.__wrapped__.run()@transient_function_wrapper(__name__, &apos;ProductionClass.method&apos;)def apply_ProductionClass_method_wrapper(wrapped, instance, args, kwargs): storage = wrapped(*args, **kwargs) return StorageClassProxy(storage)@apply_ProductionClass_method_wrapperdef test_method(): real = ProductionClass() data = real.method(3, 4, 5, key=&apos;value&apos;) result = data.run() That is, we define the ‘run()’ method on the proxy object to intercept the call of the same method on the original object. We can then proceed to return fake values, validate arguments or results, or modify them as necessary.也就是说，我们在代理对象上定义“run()”方法，以拦截原始对象上相同方法的调用。然后我们可以继续返回假值，验证参数或结果，或者根据需要修改它们。 With the proxy we can even intercept access to an attribute of the original object by adding a property to the proxy object.通过代理，我们甚至可以通过向代理对象添加属性来拦截对原始对象属性的访问。123456789101112131415161718192021222324252627from wrapt import transient_function_wrapper, ObjectProxyclass StorageClass(object): def __init__(self): self.name = &apos;name&apos;storage = StorageClass()class ProductionClass(object): def method(self, a, b, c, key): return storageclass StorageClassProxy(ObjectProxy): @property def name(self): return self.__wrapped__.name@transient_function_wrapper(__name__, &apos;ProductionClass.method&apos;)def apply_ProductionClass_method_wrapper(wrapped, instance, args, kwargs): storage = wrapped(*args, **kwargs) return StorageClassProxy(storage)@apply_ProductionClass_method_wrapperdef test_method(): real = ProductionClass() data = real.method(3, 4, 5, key=&apos;value&apos;) assert data.name == &apos;name&apos; Building a better MockYou might be saying at this point that Mock does a lot more than this. You might even want to point out how Mock can save away details about the call which can be checked later at the level of the test harness, rather than having to resort to raising assertion errors down in the wrappers themselves which can be an issue if code catches the exceptions before you see them.这时你可能会说Mock做的远不止这些。你甚至可能想指出 mock 如何保存了调用的细节。。。。。。。。 This is all true, but the goal at this point for wrapt has been to provide monkey patching mechanisms which do respect introspection, the descriptor protocol and other things besides. That I can use it for the type of testing I do is a bonus.这是正确的，但是wrapt的目标是提供猴补丁机制，它尊重内省、描述符协议和其他东西。我可以将它用于我所做的测试类型，这是一种奖励。 You aren’t limited to using just the basic building blocks themselves though and personally I think wrapt could be a great base on which to build a better Mock library for testing.您不仅限于使用基本的构建块本身，而且我个人认为wrapt可能是构建更好的模拟库进行测试的一个很好的基础。 I therefore leave you with one final example to get you thinking about the ways this might be done if you are partial to the way that Mock does things.因此，我留给你们最后一个例子来让你们思考，如何使用 mock 来实现12345678910111213141516171819202122232425262728from wrapt import transient_function_wrapperclass ProductionClass(object): def method(self, a, b, c, key): passdef patch(module, name): def _decorator(wrapped): class Wrapper(object): @transient_function_wrapper(module, name) def __call__(self, wrapped, instance, args, kwargs): self.args = args self.kwargs = kwargs return wrapped(*args, **kwargs) wrapper = Wrapper() @wrapper def _wrapper(): return wrapped(wrapper) return _wrapper return _decorator@patch(__name__, &apos;ProductionClass.method&apos;)def test_method(mock_method): real = ProductionClass() result = real.method(3, 4, 5, key=&apos;value&apos;) assert real.method.__name__ == &apos;method&apos; assert mock_method.args == (3, 4, 5) assert mock_method.kwargs.get(&apos;key&apos;) == &apos;value&apos; So that is a quick run down of the main parts of the functionality provided by wrapt for doing monkey patching. There are a few others things, but that is in the main all you usually require. I use monkey patching for actually adding instrumentation into existing code to support performance monitoring, but I have shown here how the same techniques can be used in writing tests for your code as an alternative to a package like Mock.这是 wrapt 包实现猴子补丁的概览。还有一些其他的东西，但这是核心部分。我使用猴子补丁将工具添加到现有代码中以支持性能监视，但是我在这里展示了如何将相同的技术用于编写代码测试，以替代Mock等包。 As I mentioned in my previous post though, one of the big problems with monkey patching is the order in which modules get imported relative to when the monkey patching is done. I will talk more about that issue in the next post.正如我在上一篇文章中提到的，猴子补丁的一个主要问题是模块的导入结果与打补丁完成的时间相关。我将在下一篇文章中进一步讨论这个问题。]]></content>
      <categories>
        <category>函数装饰器</category>
        <category>猴子补订</category>
        <category>wrapt</category>
      </categories>
      <tags>
        <tag>python 标准库</tag>
        <tag>译文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[11 Safely applying monkey patches in Python]]></title>
    <url>%2F2018%2F06%2F02%2Fwrapt%2F11-safely-applying-monkey-patches-in-python%2F</url>
    <content type="text"><![CDATA[本系列 blog 与 python wrat 模块相关，深入介绍了 Python 装饰器，猴子补订等相关内容，翻译于 https://github.com/GrahamDumpleton/wrapt/tree/master/blog 本篇内容: 猴子补丁与装饰器的区别，如何使用 wrapt 创建猴子补丁，以及再应用猴子补丁时可能存在的问题 Safely applying monkey patches in PythonMonkey patching in Python is often see as being one of those things you should never do. Some do regard it as a useful necessity you can’t avoid in order to patch bugs in third party code. Others will argue though that with so much software being Open Source these days that you should simply submit a fix to the upstream package maintainer.通常在Python中永远不应该做的事情之一就是编写猴子补丁。但有些人认为这是一种有用的必需品，你可能无法避免修补第三方代码中的错误。其他人则可能会争辩说，现在有这么多的软件是开源的，所以您应该简单地向上游包维护人员提交一个补丁。 Monkey patching has its uses well beyond just patching bugs though. The two most commonly used forms of monkey patching in Python which you might not even equate with monkey patching are decorators and the use of mocking libraries to assist in performing unit testing. Another not some common case of monkey patching is to add instrumentation to existing Python code in order to add performance monitoring capabilities.猴子补丁除了补丁还有其他用途。在Python中最常用的两种形式的猴子补丁是修饰符和使用模拟库来帮助执行单元测试，甚至你可能不把它与猴子补丁等同起来。另一个不常见的猴子补丁的例子是将插装添加到现有的Python代码中，以添加性能监视功能。 On the issue of decorators I wrote a quite detailed series of blog posts at the start of last year about where decorators can cause problems. The primary problem there was decorators which aren’t implemented in a way which preserve proper introspection capabilities, and which don’t preserve the correct semantics of the Python descriptor protocol when applied to methods of classes.关于装饰器的问题，我在去年年初写了一篇非常详细的博客文章，介绍了装饰器可能会导致什么问题。主要的问题就是，装饰器的实现方式可能没有保留适当的自省能力，当应用于类的方法时，它们可能也没有保留Python描述符协议的正确语义。 When one starts to talk about monkey patching arbitrary code, rather than simply applying decorators to your own code, both of these issues become even more important as you could quite easily interfere with the behaviour of the existing code you are monkey patching in unexpected ways.当人们开始讨论如何修改任意代码，而不是简单地对自己的代码应用装饰器时，这两个问题就变得更加重要了，因为可能很容易地干扰现有代码的行为，或者以意想不到的方式打补丁。 This is especially the case when monkey patching methods of a class. This is because when using decorators they would be applied while the class definition is being constructed. When doing monkey patching you are coming in after the class definition already exists and as a result you have to deal with a number of non obvious problems.典型的案例是，对一个类方法打补丁。与装饰器在类被创建时即运行不同，补丁代码运行时，类已经被创建，因此需要额外处理一些潜在问题。 Now when I went and wrote the blog posts last year on decorators it was effectively the result of what I learnt from implementing the wrapt package. Although that package is known as providing a way for creating well behaved decorators, that wasn’t the primary aim in creating the package. The real reason for creating the package was actually to implement robust mechanisms for monkey patching code. It just so happened that the same underlying principles and mechanism required to safely do monkey patching apply to implementing the function wrappers required for decorators.去年写的博客，实际上是我从执行wrapt包中学到的结果。尽管 wrapt 模块提供了创建装饰器的良好方式，但这并不是创建该包的主要目标。创建wrapt包的真正原因实际上是为猴子补丁代码实现健壮的机制。碰巧，安全执行猴子补丁所需的基本原则和机制也适用于实现装饰器。 What I am going to do with this blog post is start to explain the monkey patching capabilities of the wrapt package.我打算用这篇博文来解释wrapt包的猴补丁功能。 Creating a decoratorBefore we jump into monkey patching of arbitrary code we first need to recap how the wrapt package could be used to create a decorator. The primary pattern for this was:在开始修改任意代码之前，我们首先需要重新复述一下wrapt包如何用于创建装饰器。主要模式是: 12345678910111213141516171819import wraptimport inspect@wrapt.decoratordef universal(wrapped, instance, args, kwargs): if instance is None: if inspect.isclass(wrapped): # Decorator was applied to a class. return wrapped(*args, **kwargs) else: # Decorator was applied to a function or staticmethod. return wrapped(*args, **kwargs) else: if inspect.isclass(instance): # Decorator was applied to a classmethod. return wrapped(*args, **kwargs) else: # Decorator was applied to an instancemethod. return wrapped(*args, **kwargs) A special feature of the decorators that could be created by the wrapt package was that within the decorator you could determine the context the decorator was used in. That is, whether the decorator was applied to a class, a function or static method, a class method or an instance method.wrapt包可以创建装饰器的一个特殊特性是，在装饰器中，您可以确定装饰器所使用的上下文。也就是说，修饰符是否应用于类、函数或静态方法、类方法或实例方法。 For the case where the decorator was applied to an instance method you are provided a separate argument to the instance of the class. For a class method the separate argument is a reference to the class itself. In both cases these are separated from the ‘args’ and ‘kwargs’ argument so you do not need to fiddle around with extracting it yourself.对于将装饰器应用于实例方法的情况，为类的实例提供了一个单独的参数。对于类方法，单独的参数是对类本身的引用。在这两种情况下，它们都与“args”和“kwargs”参数相分离，因此不需要自己动手提取它们。 A decorator created using wrapt is therefore what I call a universal decorator. In other words, it is possible to create a single decorator implementation that can be used across functions, methods and classes and you can tell at the time of the call the scenario and adjust the behaviour of the decorator accordingly. You no longer have to create multiple implementations of a decorator and ensure that you are using the correct one in each scenario.因此，我将使用wrapt创建的装饰器称为通用装饰器。换句话说，可以创建一个单独的装饰器，它可以跨函数、方法和类使用，可以在不同的调用场景中相应地调整装饰器的行为。而不再需要创建一个装饰器的多个实现，并确保在每个场景中都使用了正确的实现。 Using this decorator is then no different to any other way that decorators would be used.这种装饰器的使用与其他方式创建的装饰器无异。 12345class Example(object): @universal def name(self): return &apos;name&apos; For those who have used Python long enough though, you would remember that the syntax for applying a decorator in this way hasn’t always existed. Before the ‘@’ syntax was allowed you could still create and use decorators, but you had to be more explicit in applying them. That is, you had to write:对于那些已经使用Python足够长时间的人来说，应该记得，以这种方式应用装饰器的语法并不总是存在的。在允许使用“@”语法之前，您仍然可以创建和使用装饰器，但在应用它们时必须更加明确。也就是说，你必须写: 12345class Example(object): def name(self): return &apos;name&apos; name = universal(name) This can still be done and when written this way it makes it clearer how decorators are in a way a form of monkey patching. This is because often all they are doing is introducing a wrapper around some existing function which allows the call to the original function to be intercepted. The wrapper function then allows you to perform actions either before or after the call to the original function, or allow you to modify the arguments passed to the wrapped function, or otherwise modify the result in some way, or even substitute the result completely.这么写仍然可行，当以这种方式编写时，它使装饰者在某种程度上成为一种猴子补丁。这是因为猴子补丁通常所做的就是在一些现有函数周围引入一个包装器，这样就可以对原始函数进行拦截。然后，包装器函数允许在调用原始函数之前或之后执行操作，或者允许修改传递给包装函数的参数，或者以某种方式修改结果，或者甚至完全替换结果。 What is an important distinction though with decorators is that the wrapper function is being applied at the time the class containing the method is being defined. In contrast more arbitrary monkey patching involves coming in some time later after the class definition has been created and applying the function wrapper at that point. 与装饰器的一个重要区别是，包装器函数在类被创建时即运行。相比之下，猴子补丁更随意，通常在类创建并在应用包装器的一段时间之后再执行。 In effect you are doing:事实上你所作的是:12345class Example(object): def name(self): return &apos;name&apos;Example.name = universal(Example.name) Although a decorator function created using the wrapt package can be used in this way and will still work as expected, in general I would discourage this pattern for monkey patching an existing method of a class.尽管使用wrapt包创建的装饰器函数可以以这种方式使用，并且仍将按预期工作，但总体而言，我不建议以这种模式，给类的现有方法添加补丁。 This is because it isn’t actually equivalent to doing the same thing within the body of the class when it is defined. In particular the access of ‘Example.name’ actually invokes the descriptor protocol and so is returning an instance method. We can see this by running the code:这是因为当类被定义时，它实际上并不等同于在类的主体内做同样的事情。特别是“Example.name”的访问实际上调用了描述符协议，因此返回了实例方法。我们可以通过运行代码看到这一点:12345678910class Example(object): def name(self): return &apos;name&apos; print type(name)print type(Example.name)which produces:&lt;type &apos;function&apos;&gt;&lt;type &apos;instancemethod&apos;&gt; In general this may not matter, but I have seen some really strange corner cases where the distinction has mattered. To deal with this therefore, the wrapt package provides an alternate way of applying wrapper functions when doing monkey patching after the fact. In the case of adding wrappers to methods of class, this will use a mechanism which avoids any problems caused by this subtle distinction.一般来说，这可能并不重要，但我看到过一些非常奇怪的情况，它们的区别很重要。因此，为了解决这个问题，wrapt包提供了在事后执行猴子补丁时应用包装函数的另一种方法。在为类的方法添加包装器的情况下，将使用一种机制来避免由这种细微差别所引起的任何问题。 Adding function wrappersFor general monkey patching using the wrapt package, rather than using the decorator factory to create a decorator and then apply that to a function, you instead define just the wrapper function and then use a separate function to apply it to the target function.通常情况下，使用wrapt包的猴子补丁创建一个装饰器，而不是使用装饰器工厂函数，只需定义好包装器函数，然后使用一个单独的函数调用将其应用到目标函数即可。 The prototype for the wrapper function is the same as before, but we simply do not apply the ‘@wrapt.decorator’ to it.包装器函数的原型和以前一样，我们只是不使用“@wrapt.decorator”。 12def wrapper(wrapped, instance, args, kwargs): return wrapped(*args, **kwargs) To add the wrapper function to a target function we now use the ‘wrapt.wrap_function_wrapper()’ function.为了将包装函数应用于目标函数，我们现在需要使用 wrapt.wrap_function_wrapper() 函数。 1234567class Example(object): def name(self): return &apos;name&apos;import wraptwrapt.wrap_function_wrapper(Example, &apos;name&apos;, wrapper) In this case we had the class in the same code file, but we could also have done:在这种情况下，我们将类放在同一个代码文件中，但是我们也可以这样做: 12345import exampleimport wraptwrapt.wrap_function_wrapper(example, &apos;Example.name&apos;, wrapper) That is, we provide the first argument as the module the target is defined in, with the second argument being the object path to the method we wished to apply the wrapper to.也就是说，我们将目标所在的模块作为第一参数，第二个参数则是我们希望应用包装器的目标方法对象的路径。 We could also skip importing the module altogether and just used the name of the module.我们也可以完全跳过导入模块，只使用模块的名称。 123import wraptwrapt.wrap_function_wrapper(&apos;example&apos;, &apos;Example.name&apos;, wrapper) Just to prove that just about anything can be simplified by the user of a decorator, we finally could write the whole thing as:为了证明任何东西都可以被使用装饰器的用户简化，我们最终可以把整个东西写成: 12345import wrapt@wrapt.patch_function_wrapper(&apos;example&apos;, &apos;Example.name&apos;)def wrapper(wrapped, instance, args, kwargs): return wrapped(*args, **kwargs) What will happen in this final example is that as soon as the module this is contained in is imported, the specified target function defined in the ‘example’ module will automatically be monkey patched with the wrapper function.在这个最后的示例中，将会发生的事情是，一旦导入了包含上述代码的模块，在“示例”模块中定义的指定目标函数将自动地使用包装器函数进行修补。 Delayed patching is badNow a very big warning is required at this point. Applying monkey patches after the fact like this will not always work.现在需要着重提醒的是。在上述的操作之后应用补丁并不总是有效的。 The problem is that you are trying to apply a patch after the module has been imported. In this case the ‘wrapt.wrap_function_wrapper()’ call will ensure the module is imported if it wasn’t already, but if the module had already been imported previously by some other part of your code or by a third party package you may have issues.问题的核心在于，是否正在对一个已导入的模块应用补丁。如果模块没有导入，“wrap .wrap_function_wrapper()”调用将确保模块被导入，但是如果模块已经被代码的其他部分或第三方包导入，那么可能就会有问题。 In particular, it the target function you were trying to monkey patch was a normal global function of the module, some other code could have grabbed a direct reference to it by doing:特别的是，您尝试打补丁的目标函数是模块的一个正常的全局函数，其他一些代码可以通过以下步骤直接获取对它的引用: from example import function If you come along later and have:如果你后来来了 12345import wrapt@wrapt.patch_function_wrapper(&apos;example&apos;, &apos;function&apos;)def wrapper(wrapped, instance, args, kwargs): return wrapped(*args, **kwargs) then yes the copy of the function contained in the target module will have the wrapper applied, but the reference to it created by the other code will not have the wrapper.最后，目标模块中包含的函数的副本将应用包装器，但是其他代码创建的对它的引用将没有包装器。（读者注: 再打补丁之后导入的目标函数都是被包装的，之前的都是未被包装的） To ensure that your wrapper is always used in this scenario you would need to patch it not just in the original module, but in any modules where a reference had been stored. This would only be practical in very limited circumstances because in reality you are not going to have any idea where the function might be getting used if it is a common function.为了确保在此场景中始终使用包装器，您不仅需要在原始模块中，而且还需要在存储引用的任何模块中对其进行补丁。这只在非常有限的情况下是可行的因为在现实中，如果函数是一个普通的函数，你将不知道函数在哪里被使用。 This exact problem is one of the shortcomings in the way that monkey patching is applied by packages such as gevent or eventlet. Both these packages do delayed patching of functions and so are sensitive to the order in which modules are imported. To get around this problem at least for modules in the Python standard library, the ‘time.sleep()’ function which they need to monkey patch, has to be patched not only in the ‘time’ module, but also in the ‘threading’ module.这个问题的一个确切体现就是对gevent或eventlet等包打补丁时存在的问题。这两个包都延迟了功能的修补，因此对导入模块的顺序非常敏感。要解决这个问题，至少对于Python标准库中的模块来说，要打补丁的“time.sleep()”函数不仅需要在“time”模块中进行修补，还需要在“threading”模块中进行修补。 There are some techniques one can use to try and avoid such problems but I will defer explaining those to some time down the track.有一些技术可以用来尝试和避免这些问题，但我将把这些解释推迟到以后的一段时间。 Instead for my next blog post I want to move onto some examples for where monkey patching could be used by looking at how wrapt can be used as alternative to packages such as the mock package when doing testing.在我的下一篇博客文章中，我想介绍一些使用使用猴子补丁示例，看看如何在进行测试时使用wrapt替代 mock 模块。]]></content>
      <categories>
        <category>函数装饰器</category>
        <category>猴子补订</category>
        <category>wrapt</category>
      </categories>
      <tags>
        <tag>python 标准库</tag>
        <tag>译文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10 Performance overhead when applying decorators to methods]]></title>
    <url>%2F2018%2F06%2F01%2Fwrapt%2F10-performance-overhead-when-applying-decorators-to-methods%2F</url>
    <content type="text"><![CDATA[本系列 blog 与 python wrat 模块相关，深入介绍了 Python 装饰器，猴子补订等相关内容，翻译于 https://github.com/GrahamDumpleton/wrapt/tree/master/blog 本篇内容: 装饰器的各实现，包括函数闭包，wrapt 模块的Python实现与Python C 实现之间，在包装类方法时的性能比较 Performance overhead when applying decorators to methodsThis is the tenth post in my series of blog posts about Python decorators and how I believe they are generally poorly implemented. It follows on from the previous post titled Performance overhead of using decorators, with the very first post in the series being How you implemented your Python decoratoris wrong.这是Python装饰器系列博客的第十篇 In the previous post I started looking at the performance implications of using decorators. In that post I started out by looking at the overheads when applying a decorator to a normal function, comparing a decorator implemented as a function closure to the more robust decorator implementation which has been the subject of this series of posts.在上一篇文章中，我开始研究使用装饰器对性能的影响。并对作为函数闭包实现的装饰器与前文描述的通用装饰器进行了性能比较。 For a 2012 model MacBook Pro the tests yielded for a straight function call:对于2012年的MacBook Pro，直接调用函数的测试结果是: 10000000 loops, best of 3: 0.132 usec per loop When using a decorator implemented as a function closure the result was:使用函数闭包实现的装饰器的测试结果是: 1000000 loops, best of 3: 0.326 usec per loop And finally with the decorator factory described in this series of blog posts:最受，使用装饰器工厂函数的测试结果是: 1000000 loops, best of 3: 0.771 usec per loop This final figure was based on a pure Python implementation. When however the object proxy and function wrapper were implemented as a C extension, it was possible to get this down to:上述是代理对象，和function wrapper 对象的Python实现测试结果，如果将它们以Python C扩展实现，可以降低至: 1000000 loops, best of 3: 0.382 usec per loop This result was not much different to when using a decorator implemented as a function closure.这与使用函数闭包实现的装饰器，性能相差无几。 What now for when decorators are applied to methods of a class?将装饰器应用在类方法会怎样? Overhead of having to bind functionsThe issue with applying decorators to methods of a class is that if you are going to honour the Python execution model, the decorator needs to be implemented as a descriptor and correctly bind methods to a class or class instance when accessed. In the decorator described in this series of posts we actually made use of that mechanism so as to be able to determine when a decorator was being applied to a normal function, instance method or class method.将装饰器应用于类的方法的问题是，如果要遵守Python执行模型，则需要将装饰器实现为描述符，并在访问时正确地将方法绑定到类或类实例。在本系列文章中描述的装饰器中，我们正是实现了此机制，以便能够确定装饰器整被应用于与普通的函数、实例方法或类方法中的哪一个。 Although this process of binding ensures correct operation, it comes at an additional cost in overhead over what a decorator implemented as a function closure, which does not make any attempt to preserve the Python execution model, would do.相比于使用函数闭包实现的装饰器，不会遵守任何的Python 执行模型，这个绑定过程确保了正确的操作，但是也带来了额外的开销。 In order to see what extra steps occur, we can again use the Python profile hooks mechanism to trace execution of the call of our decorated function. In this case the execution of an instance method.为了查看发生了哪些额外的步骤，我们可以再次使用Python profile挂钩机制来跟踪修饰函数调用的执行。当前即跟踪实例方法的调用 First lets check again what we would get for a decorator implemented as a function closure.首先，让我们来跟踪函数闭包实现的装饰器调用了哪些函数:1234567891011121314151617181920def my_function_wrapper(wrapped): def _my_function_wrapper(*args, **kwargs): return wrapped(*args, **kwargs) return _my_function_wrapperclass Class(object): @my_function_wrapper def method(self): passinstance = Class()import sysdef tracer(frame, event, arg): print(frame.f_code.co_name, event)sys.setprofile(tracer)instance.method() The result in running this is effectively the same as when decorating a normal function.结果跟装饰器一个普通函数类似:1234_my_function_wrapper call method call method return_my_function_wrapper return We should therefore expect that the overhead will not be substantially different when we perform actual timing tests.因此，我们应该预期，当我们执行实际的时间测试时，开销不会有很大的不同。 Now for when using our decorator factory. To provide context this time we need to present the complete recipe for the implementation.现在使用我们的装饰器工厂函数。为了提供上下文，我展示了完整的代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677class object_proxy(object): def __init__(self, wrapped): self.wrapped = wrapped try: self.__name__ = wrapped.__name__ except AttributeError: pass @property def __class__(self): return self.wrapped.__class__ def __getattr__(self, name): return getattr(self.wrapped, name)class bound_function_wrapper(object_proxy): def __init__(self, wrapped, instance, wrapper, binding, parent): super(bound_function_wrapper, self).__init__(wrapped) self.instance = instance self.wrapper = wrapper self.binding = binding self.parent = parent def __call__(self, *args, **kwargs): if self.binding == &apos;function&apos;: if self.instance is None: instance, args = args[0], args[1:] wrapped = functools.partial(self.wrapped, instance) return self.wrapper(wrapped, instance, args, kwargs) else: return self.wrapper(self.wrapped, self.instance, args, kwargs) else: instance = getattr(self.wrapped, &apos;__self__&apos;, None) return self.wrapper(self.wrapped, instance, args, kwargs) def __get__(self, instance, owner): if self.instance is None and self.binding == &apos;function&apos;: descriptor = self.parent.wrapped.__get__(instance, owner) return bound_function_wrapper(descriptor, instance, self.wrapper, self.binding, self.parent) return selfclass function_wrapper(object_proxy): def __init__(self, wrapped, wrapper): super(function_wrapper, self).__init__(wrapped) self.wrapper = wrapper if isinstance(wrapped, classmethod): self.binding = &apos;classmethod&apos; elif isinstance(wrapped, staticmethod): self.binding = &apos;staticmethod&apos; else: self.binding = &apos;function&apos; def __get__(self, instance, owner): wrapped = self.wrapped.__get__(instance, owner) return bound_function_wrapper(wrapped, instance, self.wrapper, self.binding, self) def __call__(self, *args, **kwargs): return self.wrapper(self.wrapped, None, args, kwargs)def decorator(wrapper): def _wrapper(wrapped, instance, args, kwargs): def _execute(wrapped): if instance is None: return function_wrapper(wrapped, wrapper) elif inspect.isclass(instance): return function_wrapper(wrapped, wrapper.__get__(None, instance)) else: return function_wrapper(wrapped, wrapper.__get__(instance, type(instance))) return _execute(*args, **kwargs) return function_wrapper(wrapper, _wrapper) With our decorator implementation now being:我们的装饰器实现如下: 123@decoratordef my_function_wrapper(wrapped, instance, args, kwargs): return wrapped(*args, **kwargs) the result we get when executing the decorated instance method of the class is:装饰实例方法的测试输出结果如下:12345678910111213(&apos;__get__&apos;, &apos;call&apos;) # function_wrapper (&apos;__init__&apos;, &apos;call&apos;) # bound_function_wrapper (&apos;__init__&apos;, &apos;call&apos;) # object_proxy (&apos;__init__&apos;, &apos;return&apos;) (&apos;__init__&apos;, &apos;return&apos;)(&apos;__get__&apos;, &apos;return&apos;)(&apos;__call__&apos;, &apos;call&apos;) # bound_function_wrapper (&apos;my_function_wrapper&apos;, &apos;call&apos;) (&apos;method&apos;, &apos;call&apos;) (&apos;method&apos;, &apos;return&apos;) (&apos;my_function_wrapper&apos;, &apos;return&apos;)(&apos;__call__&apos;, &apos;return&apos;) As can be seen, due to the binding of the method to the instance of the class which occurs in __get__(), a lot more is now happening. The overhead can therefore be expected to be significantly more also.可以看到，由于方法与发生在__get__()中的类实例的绑定，现在发生了很多事情。因此，开销也会显著增加。 Timing execution of the method callAs before, rather than use the implementation above, the actual implementation from the wrapt library will again be used.与前面一样，不再使用上面的实现，而是再次使用wrapt库中的实际实现。 This time our test is run as:这次我们的测试代码是: `$ python -m timeit -s ‘import benchmarks; c=benchmarks.Class()’ ‘c.method()’`` For the case of no decorator being used on the instance method, the result is:没有被装饰的实例方法，直接运行的结果是:10000000 loops, best of 3: 0.143 usec per loop This is a bit more than for the case of a normal function call due to the binding of the function to the instance which is occurring.这比普通函数调用的情况要多一点，因为发生的了实例方法的绑定。 Next up is using the decorator implemented as a function closure. For this we get:使用函数闭包实现的装饰器。测试结果如下: 1000000 loops, best of 3: 0.382 usec per loop Again, somewhat more than the undecorated case, but not a great deal more than when the decorator implemented as a function closure was applied to a normal function. The overhead of this decorator when applied to a normal function vs a instance method is therefore not significantly different.再一次，比未修饰的情况稍微多一点，与被应用到函数的装饰器相差无几。因此，当应用于普通函数与实例方法时，装饰器的开销并没有太大的差异。 Now for the case of our decorator factory and function wrapper which honours the Python execution model, by ensuring that binding of the function to the instance of the class is done correctly.现在轮到我们的装饰器工厂函数和function wrapper对象 First up is where a pure Python implementation is used.首先测试Python 实现:100000 loops, best of 3: 6.67 usec per loop Ouch. Compared to when using a function closure to implement the decorator, this is quite an additional hit in runtime overhead.哎哟。与使用函数闭包实现装饰器相比，这在运行时开销上增加了不少负担。 Although this is only about an extra 6 usec per call, you do need to think about this in context. In particular, if such a decorator is applied to a function which is called 1000 times in the process of handing a web request, that is an extra 6 ms added on top of the response time for that web request.虽然每次通话只需要额外的6个usec，但是您需要在上下文中考虑这个问题。特别是，如果在处理web请求的过程中对一个调用了1000次的函数应用了这样的装饰器，那么在该web请求的响应时间之上增加了6 ms。 This is the point where many will no doubt argue that being correct is not worth it if the overhead is simply too much. But then, it also isn’t likely the case that the decorated function, nor the decorator itself are going to do nothing and so the additional overhead incurred may still be a small percentage of the run time cost of those and so not in practice noticeable.在这一点上，许多人无疑会辩称，如果管理费用太高，那么正确是不值得的。但是，装饰函数和装饰器本身也不可能什么都不做，因此所产生的额外开销可能只是运行时成本的一小部分，因此在实践中并不明显。 All the same, can the use of a C extension improve things?同样的，如果使用Python C扩展模块实现呢？ For the case of the object proxy and function wrapper being implemented as a C extension, the result is:对于作为C扩展实现的对象代理和函数包装器，结果是: 1000000 loops, best of 3: 0.836 usec per loop So instead of 6 ms, that is less than 1 ms of additional overhead if the decorated function was called a 1000 times.所以不是6ms，而是小于1ms的额外开销如果修饰函数被调用1000次。 It is still somewhat more than when using a decorator implemented as a function closure, but reiterating again, the use of a function closure when decorating a method of a class is technically broken by design as it does not honour the Python execution model.它仍然比使用作为函数闭包实现的装饰器要多，但再次重申，在修饰类的方法时使用函数闭包不符合Python执行模型。 Who cares if it isn’t quite correctAm I splitting hairs and being overly pedantic in wanting things to be done properly?我是在吹毛求疵、过于迂腐地想把事情做好吗? Sure, for what you are using decorators for you may well get away with using a decorator implemented as a function closure. When you start though moving into the area of using function wrappers to perform monkey patching of arbitrary code, you cannot afford to do things in a sloppy way.当然，对于你现在所使用的装饰器，闭包实现可能工作的很好。但是当您开始使用函数包装器执行任意代码的猴子补丁时，情况就不一样了。 If you do not honour the Python execution model when doing monkey patching, you can too easily break in very subtle and obscure ways the third party code you are monkey patching. Customers don’t really like it when what you do crashes their web application. So for what I need to do at least, it does matter and it matters a lot.如果你在做猴子补丁时不遵守Python的执行模型，那么你很容易以非常微妙和晦涩的方式打破第三方代码。客户可不会喜欢你破坏了他们的web应用程序。所以至少我现在所作的是很重要的。 Now in this post I have only considered the overhead when decorating instance methods of a class. I did not cover what the overheads are when decorating static methods and class methods. If you are curious about those and how they may be different, you can check out the benchmarks for the full range of cases in the wrapt documentation.在本文中，我只考虑了修饰类实例方法时的开销。我没有涵盖在修饰静态方法和类方法时的开销。如果您对它们的不同之处感到好奇，您可以在wrapt文档中查看完整的案例的基准。 In the next post I will touch once again on issues of performance overhead, but also a bit on alternative ways of implementing a decorator so as to try and address the problems raised in my very first post. This will be as a part of a comparison between the approach described in this series of posts and the way in which the decorator module available from PyPi implements its variant of a decorator factory.在下一篇文章中，我将再次讨论性能开销问题，但也将讨论实现装饰器的一些替代方法，以便尝试并解决我在第一篇文章中提出的问题。这些内容将作为，对博客中描述的实现和 PyPi 模块中的实现的对比的一部分]]></content>
      <categories>
        <category>函数装饰器</category>
        <category>猴子补订</category>
        <category>wrapt</category>
      </categories>
      <tags>
        <tag>python 标准库</tag>
        <tag>译文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[09 Performance overhead of using decorators]]></title>
    <url>%2F2018%2F05%2F29%2Fwrapt%2F09-performance-overhead-of-using-decorators%2F</url>
    <content type="text"><![CDATA[本系列 blog 与 python wrat 模块相关，深入介绍了 Python 装饰器，猴子补订等相关内容，翻译于 https://github.com/GrahamDumpleton/wrapt/tree/master/blog 本篇内容: 装饰器的各实现，包括函数闭包，wrapt 模块的Python实现与Python C 实现之间，在包装普通函数时的性能比较 Performance overhead of using decoratorsThis is the ninth post in my series of blog posts about Python decorators and how I believe they are generally poorly implemented. It follows on from the previous post titled The @synchronized decorator as context manager, with the very first post in the series being How you implemented your Python decoratoris wrong.这是Python装饰器系列博客的第九篇 The posts so far in this series were bashed out in quick succession in a bit over a week. Because that was quite draining on the brain and due to other commitments I took a bit of a break. Hopefully I can get through another burst of posts, initially about performance considerations when implementing decorators and then start a dive into how to implement the object proxy which underlies the function wrapper the decorator mechanism described relies on.到目前为止，这个系列的帖子在一周多一点的时间里接连不断地被抨击。因为这对大脑来说是很耗精力的，而且由于其他的承诺，我休息了一会儿。希望我能由这篇关于装饰器的实现性能这篇文章，然后开始深入探讨如何实现代理。它被function wrapper继承，是通用装饰器机制中的基础组件 Overhead in decorating a normal functionIn this post I am only going to look at the overhead of decorating a normal function with the decorator mechanism which has been described. The relevant part of the decorator mechanism which comes into play in this case is:在这篇文章中，我将只讨论用装饰器修饰一个普通函数的开销。相关的装饰器代码如下:123456789101112131415161718192021222324class function_wrapper(object_proxy): def __init__(self, wrapped, wrapper): super(function_wrapper, self).__init__(wrapped) self.wrapper = wrapper ... def __get__(self, instance, owner): ... def __call__(self, *args, **kwargs): return self.wrapper(self.wrapped, None, args, kwargs) def decorator(wrapper): def _wrapper(wrapped, instance, args, kwargs): def _execute(wrapped): if instance is None: return function_wrapper(wrapped, wrapper) elif inspect.isclass(instance): return function_wrapper(wrapped, wrapper.__get__(None, instance)) else: return function_wrapper(wrapped, wrapper.__get__(instance, type(instance))) return _execute(*args, **kwargs) return function_wrapper(wrapper, _wrapper) If you want to refresh your memory of the complete code that was previously presented you can check back to the last post where it was described in full.如果你想回忆完整的代码，你可以去查看之前的文章，那里有完整描述。 With our decorator factory, when creating a decorator and then decorating a normal function with it we would use:使用装饰器工厂函数，创建装饰器，并装饰器一个普通函数可以像下面这样:1234567@decoratordef my_function_wrapper(wrapped, instance, args, kwargs): return wrapped(*args, **kwargs) @my_function_wrapperdef function(): pass This is in contrast to the same decorator created in the more traditional way using a function closure.这与使用函数闭包以更传统的方式创建的decorator不同。 12345678def my_function_wrapper(wrapped): def _my_function_wrapper(*args, **kwargs): return wrapped(*args, **kwargs) return _my_function_wrapper@my_function_wrapperdef function(): pass Now what actually occurs in these two different cases when we make the call:在我们调用函数时，这两种情况各自会发生什么?function() Tracing the execution of the functionIn order to trace the execution of our code we can use Python’s profile hooks mechanism.为了跟踪代码的执行，我们可以使用Python的profile hook机制。 1234567import sysdef tracer(frame, event, arg): print(frame.f_code.co_name, event)sys.setprofile(tracer)function() The purpose of the profile hook is to allow you to register a callback function which is called on the entry and exit of all functions. Using this was can trace the sequence of function calls that are being made.profile hook的目的是允许您注册一个回调函数，该函数在所有函数的入口和出口调用。这样就可以追踪正在进行的函数调用的序列。 For the case of a decorator implemented as a function closure this yields:对于函数闭包，输出如下:1234_my_function_wrapper call function call function return_my_function_wrapper return So what we see here is that the nested function of our function closure is called. This is because the decorator in the case of a using a function closure is replacing function with a reference to that nested function. When that nested function is called, it then in turn calls the original wrapped function.我们在这里看到的是函数闭包的嵌套函数被调用。这是因为在使用函数闭包的情况下，装饰器将函数替换为对嵌套函数的引用。当这个嵌套函数被调用时，它将依次调用原来的包装函数。 For our implementation using our decorator factory, when we do the same thing we instead get:对于我们的工厂函数，输出如下:123456__call__ call my_function_wrapper call function call function return my_function_wrapper return__call__ return The difference here is that our decorator replaces function with an instance of our function wrapper class. Being a class, when it is called as if it was a function, the __call__() method is invoked on the instance of the class. The __call__() method is then invoking the user supplied wrapper function, which in turn calls the original wrapped function.这里的区别是，decorator用function wrapper类的实例替换了函数。作为一个类，当它作为一个函数被调用时，__call__()方法在类的实例上被调用。__call__()方法随后调用用户提供的包装器函数，该函数反过来调用原始包装函数。 The result therefore is that we have introduced an extra level of indirection, or in other words an extra function call into the execution path.因此，结果是我们引入了额外的间接级别，或者换句话说，在执行路径中引入了额外的函数调用。 Keep in mind though that __call__() is actually a method though and not just a normal function. Being a method that means there is actually a lot more work going on behind the scenes than a normal function call. In particular, the unbound method needs to be bound to the instance of our function wrapper class before it can be called. This doesn’t appear in the trace of the calls, but it is occurring and that will incur additional overhead.记住，__call__()实际上是一个方法，而不仅仅是一个普通的函数。作为一种方法，实际上在幕后进行的工作要比普通的函数调用多得多。特别是，在调用未绑定方法之前，需要将其绑定到函数包装器类的实例。这不会出现在调用的跟踪中，但是它正在发生，并且会产生额外的开销。 Timing the execution of the functionBy performing the trace above we know that our solution incurs an additional method call overhead. How much actual extra overhead is this resulting in though?通过执行上面的跟踪，我们知道我们的解决方案会带来额外的方法调用开销。但是这会产生多少额外的开销呢? To try and measure the increase in overhead in each solution we can use the timeit module to time the execution of our function call. As a baseline, we first want to time the call of a function without any decorator applied.为了尝试度量每个解决方案中开销的增加，我们可以使用timeit模块来执行我们的函数调用。作为基线，我们首先需要知道在不应用任何修饰符的情况下对函数进行调用的时间开销。 123# benchmarks.pydef function(): pass To time this we use the command:为记录时间，我们需要使用以下命令: $ python -m timeit -s &#39;import benchmarks&#39; &#39;benchmarks.function()&#39; The timeit module when used in this way will perform a suitable large number of iterations of calling the function, divide the resulting total time for all calls with the count of the number and end up with a time value for a single call.以这种方式使用的timeit模块时，它将执行适当的大量函数调用，将所有调用的总时间除以调用次数，最后得到单个调用的时间值。 For a 2012 model MacBook Pro this yields:对于2012年款的MacBook Pro来说，输出如下: 10000000 loops, best of 3: 0.132 usec per loop Next up is to try with a decorator implemented as a function closure. For this we get:接下来测试函数闭包，输出如下:1000000 loops, best of 3: 0.326 usec per loop And finally with our decorator factory:最后测试我们的装饰器工厂函数: 1000000 loops, best of 3: 0.771 usec per loop In this final case, rather than use the exact code as has been presented so far in this series of blog posts, I have used the wrapt module implementation of what has been described. This implementation works slightly differently as it has a few extra capabilities over what has been described and the design is also a little bit different. The overhead will still be roughly equivalent and if anything will cast things as being slightly worse than the more minimal implementation.在这个最后的例子中，我使用的是wrapt模块实现，而不是本系列博文中迄今为止给出的代码。这个实现的工作方式略有不同，因为它在描述的内容上有一些额外的功能，设计也有一些不同。即便是最轻量级的实现，性能开销也差不多。 Speeding up execution of the wrapperAt this point no doubt there will be people wanting to point out that this so called better way of implementing a decorator is too slow to be practical to use, even if it is more correct as far as properly honouring things such as the descriptor protocol for method invocation.在这一点上毫无疑问会有人们想要指出,即使对于方法调用而言，它更加正确的实现了描述符协议，但是这所谓的的更好的方法实在是太慢，难以在实际生产环境中使用。 Is there therefore anything that can be done to speed up the implementation?因此，是否可以做些什么来加速实现呢? That is of course a stupid question for me to be asking because you should realise by now that I would find a way. :-)这当然是一个愚蠢的问题，因为你现在应该意识到我会找到办法。:-) The path that can be taken at this point is to implement everything that has been described for the function wrapper and object proxy as a Python C extension module. For simplicity we can keep the decorator factory itself implemented as pure Python code as execution of that is not time critical as it would only be invoked once when the decorator is applied to the function and not on every call of the decorated function.此时可以采用的方法是将函数包装器和对象代理实现为Python C扩展模块。为了简单起见，我们可以将装饰器工厂函数本身作为纯Python代码来实现，因为工厂函数只在修饰符应用到函数时才调用，而不是修饰函数的每次调用时都会调用，因此它的时间开销并不重要。 One thing I am definitely not going to do is blog about how to go about implementing the function wrapper and object proxy as a Python C extension module. Rest assured though that it works in the same way as the parallel pure Python implementation. It does obviously though run a lot quicker due to being implemented as C code using the Python C APIs rather than as pure Python code.我绝对不会做的一件事是写博客，讨论如何将函数包装器和对象代理作为Python C扩展模块实现。不过请放心，它的工作方式与纯Python实现相同。显然，它的运行速度要快得多，因为它是使用Python C api实现的C代码，而不是纯粹的Python代码。 What is the result then by implementing the function wrapper and object proxy as a Python C extension module? It is:将函数包装器和对象代理作为Python C扩展模块实现的开销如何呢?测试如下:1000000 loops, best of 3: 0.382 usec per loop So although a lot more effort was required in actually implementing the function wrapper and object proxy as a Python C extension module, the effort was well worth it, with the results now being very close to the implementation of the decorator that used a function closure.因此，尽管将函数包装器和对象代理作为Python C扩展模块实现需要付出更多的努力，但这些努力是值得的，结果时现在非常接近使用函数闭包的装饰器实现。 Normal functions vs methods of classesSo far we have only considered the case of decorating a normal function. As expected, due to the introduction of an extra level of indirection as well as the function wrapper being implemented as a class, overhead was notably more. Albeit, that it was still in the order of only half a microsecond.到目前为止，我们只考虑了装饰一个普通函数的情况。正如预期的那样，与function wrapper作为一个类实现类似，由于引入了额外的间接层，因此开销明显更多。尽管如此，它仍然只有半微秒。 All the same, we were able to speed things up to a point, by implementing our function wrapper and object proxy as C code, where the overhead above that of a decorator implemented as a function closure was negligible.尽管如此，通过实现我们的函数包装器和对象代理作为C代码，我们还是能够将性能达到同一量级，在这里，作为函数闭包实现的装饰器工厂函数的开销可以忽略不计。 What now about where we decorate methods of a class. That is, instance methods, class methods and static methods. For that you will need to wait until the next blog post in this series on decorators.那么装饰类方法的性能如何呢。将在下一篇博客揭晓。]]></content>
      <categories>
        <category>函数装饰器</category>
        <category>猴子补订</category>
        <category>wrapt</category>
      </categories>
      <tags>
        <tag>python 标准库</tag>
        <tag>译文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[08 The @synchronized decorator as context manager]]></title>
    <url>%2F2018%2F05%2F28%2Fwrapt%2F08-the-synchronized-decorator-as-context-manager%2F</url>
    <content type="text"><![CDATA[本系列 blog 与 python wrat 模块相关，深入介绍了 Python 装饰器，猴子补订等相关内容，翻译于 https://github.com/GrahamDumpleton/wrapt/tree/master/blog 本篇内容: 将 synchronized 同步原语装饰器实现为上下文管里器 The @synchronized decorator as context managerThis is the eight post in my series of blog posts about Python decorators and how I believe they are generally poorly implemented. It follows on from the previous post titled The missing @synchronized decorator, with the very first post in the series being How you implemented your Python decoratoris wrong这是Python装饰器系列博客的第八篇 In the previous post I described how we could use our new universal decorator pattern to implement a better @synchronized decorator for Python. The intent in doing this was to come up with a better approximation of the equivalent synchronization mechanisms in Java.在前一篇文章中，我描述了如何使用新的通用装饰器模式来实现Python的 @synchronized 同步原语装饰器。这样做的目的是为了更好地了解Java中等效的同步机制。 Of the two synchronization mechanisms provided by Java, synchronized methods and synchronized statements, we have however so far only implemented an equivalent to synchronized methods.在Java提供的两个同步机制中，同步方法和同步原语，目前为止我们只实现了同步方法。 In this post I will describe how we can take our @synchronized decorator and extend it to also be used as a context manager, thus providing an an equivalent of synchronized statements in Java.在本文中，我将描述如何使用@synchronized 装饰器，并将其扩展为上下文管理器，从而等效的实现Java的同步原语。 The original @synchronized decoratorThe implementation of our @synchronized decorator so far is:到目前为止，我们的@synchronized 装饰器的实现是。123456789101112131415161718192021@decoratordef synchronized(wrapped, instance, args, kwargs): if instance is None: owner = wrapped else: owner = instance lock = vars(owner).get(&apos;_synchronized_lock&apos;, None) if lock is None: meta_lock = vars(synchronized).setdefault( &apos;_synchronized_meta_lock&apos;, threading.Lock()) with meta_lock: lock = vars(owner).get(&apos;_synchronized_lock&apos;, None) if lock is None: lock = threading.RLock() setattr(owner, &apos;_synchronized_lock&apos;, lock) with lock: return wrapped(*args, **kwargs) By determining whether the decorator is being used to wrap a normal function, a method bound to a class instance or a class, and with the decorator changing behaviour as a result, we are able to use the one decorator implementation in a number of scenarios.通过确定装饰器被用于包装普通函数、实例方法或类的方法中的哪一个，我们可以在许多场景中使用同一一个装饰器。123456789101112131415161718192021222324@synchronized # lock bound to function1def function1(): pass@synchronized # lock bound to function2def function2(): pass@synchronized # lock bound to Classclass Class(object): @synchronized # lock bound to instance of Class def function_im(self): pass @synchronized # lock bound to Class @classmethod def function_cm(cls): pass @synchronized # lock bound to function_sm @staticmethod def function_sm(): pass What we now want to do is modify the decorator to also allow:我们现在想要实现的是让同步装饰器也能完成如下操作:123456789class Object(object): @synchronized def function_im_1(self): pass def function_im_2(self): with synchronized(self): pass That is, as well as being able to be used as a decorator, we enable it to be used as a context manager in conjunction with the with statement. By doing this it then provides the ability to only acquire the corresponding lock for a selected number of statements within a function rather than the whole function.也就是说，除了可以用作装饰器之外，它还能与with语句一起用作上下文管理器。通过这样做，它就能够对函数中的部分语句加锁，而不是整个函数。 For the case of acquiring the same lock used by instance methods, we would pass the self argument or instance object into synchronized when used as a context manager. It could instead also be passed the class type if needing to synchronize with class methods.用作上下文管理器时，如果需要与实例方法同步，我们需要将把self参数或类实例传递给synchronized。如果需要与类方法同步，也可以传递类类型。 The function wrapper as context managerRight now with how the decorator is implemented, when we use synchronized as a function call, it will return an instance of our function wrapper class.在现有的synchronized实现上，当使用synchronized作为函数调用时，它将返回函数包装器类的一个实例。12&gt;&gt;&gt; synchronized(None)&lt;__main__.function_wrapper object at 0x107b7ea10&gt; This function wrapper does not implement the enter() and exit() functions that are required for an object to be used as a context manager. Since the function wrapper type is our own class, all we need to do though is create a derived version of the class and use that instead. Because though the creation of that function wrapper is bound up within the definition of @decorator, we need to bypass @decorator and use the function wrapper directly.这个函数包装器没有实现作为上下文管理器的对象所需的enter()和exit()函数。由于函数包装器类型是我们自己的类，所以我们只需要创建子类并使用它。因为尽管这个函数包装器的创建是在@decorator的定义中绑定的，但是我们需要绕过@decorator并直接使用函数包装器。 The first step therefore is to rewrite our @synchronized decorator so it doesn’t use @decorator.因此，第一步是重写我们的@synchronized decorator，不使用@decorator。123456789101112131415161718192021def synchronized(wrapped): def _synchronized_lock(owner): lock = vars(owner).get(&apos;_synchronized_lock&apos;, None) if lock is None: meta_lock = vars(synchronized).setdefault( &apos;_synchronized_meta_lock&apos;, threading.Lock()) with meta_lock: lock = vars(owner).get(&apos;_synchronized_lock&apos;, None) if lock is None: lock = threading.RLock() setattr(owner, &apos;_synchronized_lock&apos;, lock) return lock def _synchronized_wrapper(wrapped, instance, args, kwargs): with _synchronized_lock(instance or wrapped): return wrapped(*args, **kwargs) return function_wrapper(wrapped, _synchronized_wrapper) This works the same as our original implementation but we now have access to the point where the function wrapper was created. With that being the case, we can now create a class which derives from the function wrapper and adds the required methods to satisfy the context manager protocol.这与我们最初的实现相同，但是我们现在可以访问创建函数包装器的点。在这种情况下，我们现在可以创建一个从函数包装器派生的类，并添加所需的方法来满足上下文管理器协议。12345678910111213141516171819202122232425262728293031def synchronized(wrapped): def _synchronized_lock(owner): lock = vars(owner).get(&apos;_synchronized_lock&apos;, None) if lock is None: meta_lock = vars(synchronized).setdefault( &apos;_synchronized_meta_lock&apos;, threading.Lock()) with meta_lock: lock = vars(owner).get(&apos;_synchronized_lock&apos;, None) if lock is None: lock = threading.RLock() setattr(owner, &apos;_synchronized_lock&apos;, lock) return lock def _synchronized_wrapper(wrapped, instance, args, kwargs): with _synchronized_lock(instance or wrapped): return wrapped(*args, **kwargs) class _synchronized_function_wrapper(function_wrapper): def __enter__(self): self._lock = _synchronized_lock(self.wrapped) self._lock.acquire() return self._lock def __exit__(self, *args): self._lock.release() return _synchronized_function_wrapper(wrapped, _synchronized_wrapper) We now have two scenarios for what can happen.In the case of synchronized being used as a decorator still, our new derived function wrapper will wrap the function or method it was applied to. When that function or class method is called, the existing call() method of the function wrapper base class will be called and the decorator semantics will apply with the wrapper called to acquire the appropriate lock and call the wrapped function.当synchronized继续作为装饰器使用时，新的function wrapper的衍生类被用于包装被包装函数和方法。当函数或类方法被调用时，function wrapper基类中的call 方法被调用。装饰器将在尝试获取锁之后执行被包装函数。 In the case where is was instead used for the purposes of a context manager, our new derived function wrapper would actually be wrapping the class instance or class type. Nothing is being called though and instead the with statement will trigger the execution of the enter() and exit() methods to acquire the appropriate lock around the context of the statements to be executed.当synchronized作为上下文管里器使用时。新的衍生类将用于包装类实例或类本身。没有方法会被调用，取而代之的是在进入上下文时，enter()会获取锁，离开上下文时，exit()会释放锁。 So all nice and neat and not even that complicated compared to previous attempts at doing the same thing which were referenced in the prior post on this topic.与在之前的文章中形容的复杂度相比，现在的实现简单明了。 It isn’t just about @decoratorNow one of the things that this hopefully shows is that although @decorator can be used to create your own custom decorators, this isn’t always the most appropriate way to go. The separate existence of the function wrapper gives a great deal of flexibility in what one can do as far as wrapping objects to modify the behaviour. One can also drop down and use the object proxy directly in certain circumstances.希望这能说明的一点是，尽管@decorator被用来创建自定义装饰器，但这并不总是最合适的方式。function wrapper 对象的单独存在为修改被包装对象的行为提供了很大的灵活性。在某些情况下，还可以直接删除和使用对象代理。 All together these provide a general purpose set of tools for doing any sort of wrapping or monkey patching and not just for use in decorators. I will now start to shift the focus of this series of blog posts to look more at the more general area of wrapping and monkey patching.所有这些都提供了一个通用的工具集，用于进行任何类型的包装或修补，而不仅仅是用于装饰。现在，我将开始将这一系列博客文章的焦点转移到更一般的包装和猴子补丁上。 Before I do get into that, in my next post I will first talk about the performance implications implicit in using the function wrapper which has been described when compared to the more traditional way of using function closures to implement decorators. This will include overhead comparisons where the complete object proxy and function wrapper classes are implemented as a Python C extension for added performance.在此之前，在下一篇文章中，我将首先讨论与使用函数闭包实现装饰器的更传统方式相比，使用function wrapper隐含的性能影响。以及使用Python C扩展实现完整的对象代理和function wrapper后，性能改善的大小。]]></content>
      <categories>
        <category>函数装饰器</category>
        <category>猴子补订</category>
        <category>wrapt</category>
      </categories>
      <tags>
        <tag>python 标准库</tag>
        <tag>译文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[07 The missing @synchronized decorator]]></title>
    <url>%2F2018%2F05%2F26%2Fwrapt%2F07-the-missing-synchronized-decorator%2F</url>
    <content type="text"><![CDATA[本系列 blog 与 python wrat 模块相关，深入介绍了 Python 装饰器，猴子补订等相关内容，翻译于 https://github.com/GrahamDumpleton/wrapt/tree/master/blog 本篇内容: 使用通用装饰器接口实现类似 Java 的 synchronized 同步原语 The missing @synchronized decoratorThis is the seventh post in my series of blog posts about Python decoratorsand how I believe they are generally poorly implemented. It follows on fromthe previous post titled Maintaining decorator state using aclass, with the veryfirst post in the series being How you implemented your Python decoratoris wrong.这是Python装饰器系列博客的第七篇 In the previous post I effectively rounded out the discussion on the implementation of the decorator pattern, or at least the key parts that I care to cover at this point. I may expand on a few other things that can bedone at a later time.在之前的博客中，我着重讨论了装饰器的实现模式，在接下来的时间我将对此做一些扩展。 At this point I want to start looking at ways this decorator pattern can be used to implement better decorators. For this post I want to look at the @synchronized decorator.我将开始研究如何使用这个装饰模式来实现更好的装饰器。在这篇文章中，将以@synchronized 装饰器为例进行说明。 The concept of the @synchronized decorator originates from Java and theidea of being able to write such a decorator in Python was a bit of aposter child when decorators were first added to Python. Despite this,there is no standard @synchronized decorator in the Python standardlibrary. If this was such a good example of why decorators are so useful,why is this the case? @synchronized装饰器的来自 Java，当装饰器被第一次引进Python 时，它也被作为使用装饰器的经典示例。尽管如此，在Python 标准库中并没有 @synchronized的标准实现。如果它是装饰器如此易用的经典示例，为什么会出现这种情况呢？ Stealing ideas from the Java languageThe equivalent synchronization primitive from Java comes in two forms. These are synchronized methods and synchronized statements.java 的同步原语有两种形式，分别是同步方法和同步状态 In Java, to make a method synchronized, you simply add the synchronized keyword to its declaration:在Java 中创建同步方法，只需要在其定义时添加synchronized关键字即可。 123456789101112public class SynchronizedCounter &#123; private int c = 0; public synchronized void increment() &#123; c++; &#125; public synchronized void decrement() &#123; c--; &#125; public synchronized int value() &#123; return c; &#125;&#125; Making a method synchronized means it is not possible for two invocationsof synchronized methods on the same object to interleave. When one threadis executing a synchronized method for an object, all other threads thatinvoke synchronized methods for the same object block (suspend execution)until the first thread is done with the object.使一个方法同步意味着不可能在同一个对象上同时调用多个同步方法。当一个线程正在执行一个对象的同步方法时，所有其他调用相同对象块的同步方法的线程(暂停执行)直到第一个线程完成对象。 In other words, each instance of the class has an intrinsic lock object and upon entering a method the lock is being acquired, with it subsequently being released when the method returns. The lock is what is called a re-entrant lock, meaning that a thread can while it holds the lock, acquire it again without blocking. This is so that from one synchronized method it is possible to call another synchronized method on the same object.换句话说，类的每个实例都有一个内在的锁对象，并且在进入一个方法时，锁会被获取，当方法返回时它会被释放。锁是所谓的重入锁，这意味着线程可以在它持有锁的同时，再次获得它，而不会阻塞。正因为如此，一个同步的方法可以调用同一个对象上的另一个同步方法。 The second way to create synchronized code in Java is with synchronized statements. Unlike synchronized methods, synchronized statements must specify the object that provides the intrinsic lock:在Java中创建同步代码的第二种方法是同步语句。与同步方法不同，同步语句必须指定提供内在锁的对象1234567public void addName(String name) &#123; synchronized(this) &#123; lastName = name; nameCount++; &#125; nameList.add(name);&#125; Of note is that in Java one can use any object as the source of the lock, it is not necessary to create an instance of a specific lock type to synchronize on. If more fined grained locking is required within a class one can simply create or use an existing arbitrary object to synchronize on.值得注意的是，在Java中，可以使用任何对象作为锁的源，不需要创建特定锁类型的实例来同步。如果在类中需要更细粒度的锁，那么可以简单地创建或使用现有的任意对象进行同步。 12345678910111213141516public class MsLunch &#123; private long c1 = 0; private long c2 = 0; private Object lock1 = new Object(); private Object lock2 = new Object(); public void inc1() &#123; synchronized(lock1) &#123; c1++; &#125; &#125; public void inc2() &#123; synchronized(lock2) &#123; c2++; &#125; &#125;&#125; These synchronization primitives looks relatively simple to use, so how close did people come to actually achieving the level of simplicity by using decorators to do the same in Python.这些同步原语使用起来相对简单，因此，如何才能通过装饰器在Python中让类似操作以同样简单的方式实现呢。 Synchronizing off a thread mutex同步线程的互斥锁 In Python it isn’t possible to synchronize off an arbitrary object. Instead it is necessary to create a specific lock object which internally holds a thread mutex. Such a lock object provides an acquire() and release() method for manipulating the lock.在Python中，不可能使用任意对象做同步。相反，有必要创建一个特定的锁对象，该对象内部持有一个线程互斥锁。这样的锁对象提供了一个 acquire()和release()方法来操作锁。 Since context managers were introduced to Python however, locks also support being used in conjunction with the with statement. Using this specific feature, the typical recipe given for implementing a @synchronized decorator for Python is:但是，由于上下文管理器被引入到Python中，所以锁也支持与with语句一起使用。使用这个特定的特性，用于实现Python的@synchronized 装饰器的典型实现是:1234567891011121314def synchronized(lock=None): def _decorator(wrapped): @functools.wraps(wrapped) def _wrapper(*args, **kwargs): with lock: return wrapped(*args, **kwargs) return _wrapper return _decoratorlock = threading.RLock()@synchronized(lock)def function(): pass Using this approach becomes annoying after a while because for every distinct function that needs to be synchronized, you have to first create a companion thread lock to go with it.使用此方法在一段时间后变得很烦人，因为对于需要同步的每个不同的函数，必须首先创建一个线程锁。 The alternative to needing to pass in the lock object each time, is to create one automatically for each use of the decorator.每次需要传入锁对象的替代方法是，为每个装饰器自动创建一个。 1234567891011def synchronized(wrapped): lock = threading.RLock() @functools.wraps(wrapped) def _wrapper(*args, **kwargs): with lock: return wrapped(*args, **kwargs) return _wrapper@synchronizeddef function(): pass We can even use the pattern described previously for allowing optional decorator arguments to permit either approach.我们甚至可以使用前面描述的模式，为每次调用提供一个可选的参数1234567891011121314151617181920def synchronized(wrapped=None, lock=None): if wrapped is None: return functools.partial(synchronized, lock=lock) if lock is None: lock = threading.RLock() @functools.wraps(wrapped) def _wrapper(*args, **kwargs): with lock: return wrapped(*args, **kwargs) return _wrapper@synchronizeddef function1(): passlock = threading.Lock()@synchronized(lock=lock)def function2(): pass Whatever the approach, the decorator being based on a function closure suffers all the problems we have already outlined. The first step we can therefore take is to update it to use our new decorator factory instead.无论方法如何，基于函数闭包的装饰器都会遇到我们已经列出的所有问题。因此，我们可以采取的第一步是使用我们新的装饰器工厂函数替代它。 12345678910111213def synchronized(wrapped=None, lock=None): if wrapped is None: return functools.partial(synchronized, lock=lock) if lock is None: lock = threading.RLock() @decorator def _wrapper(wrapped, instance, args, kwargs): with lock: return wrapped(*args, **kwargs) return _wrapper(wrapped) Because this is using our decorator factory, it also means that the same code is safe to use on instance, class or static methods as well.因为使用了我们的装饰器工厂函数，这意味着相同的代码可以安全的应在实例、类或静态方法上。 Using this on methods of a class though starts to highlight why this simplistic approach isn’t particularly useful. This is because the locking only applies to calls made to the specific method which is wrapped. Plus that it will be across that one method on all instances of the class. This isn’t really want we want and doesn’t mirror how synchronized methods in Java work.需要强调的是在类方法上使用此装饰器看似简单，但并不是很有用。因为锁仅仅对被装饰的方法有用，并且会对类的所有实例在同一方法上施加同步锁。这并不是我们想要的，也不能同java的同步方法相对应。 Reiterating what we are after again, for all instance methods of a specific instance of a class, if they have been decorated as being synchronized, we want them to synchronize off a single lock object associated with the class instance.在次重申我们要实现的目标是，被装饰器标识为同步的所有实例方法，我们希望每个类实例都有一个独立的同步锁来实现实例内的方法同步。(读者注:不同类实例之间不要同步) Now there have been posts describing how to improve on this in the past, including for example this quite involved attempt. Personally though I find the way in which it is done is quite clumsy and even suspect it isn’t actually thread safe, with a race condition over the creation of some of the locks.过去已经有一些文章描述了如何改进这一点，包括这个很复杂的尝试。个人觉得它的实现方式是相当笨拙的，甚至怀疑它实际上不是线程安全的，因为在创建一些锁的过程中有一个竞争条件。 Because it used function closures and didn’t have our concept of a universal decorator, it was also necessary to create a multitude of different decorators and then try and plaster them together under a single decorator entry point. Obviously, we should now be able to do a lot better than this.因为它使用了函数闭包，并且没有我们的通用装饰器的概念，所以还需要创建大量不同的装饰器，然后在一个装饰器入口点上尝试将它们整合在一起。显然，我们现在应该能够做得更好。 Storing the thread mutex on objectsStarting over, lets take a fresh look at how we can manage the thread locks we need to have. Rather than requiring the lock be passed in, or creating it within a function closure which is then available to the nested wrapper, lets try and manage the locks within the wrapper itself.重新开始，让我们重新审视一下如何管理我们需要的线程锁。相对于需要传入锁，或者在函数闭包中创建锁，让我们尝试在包装器本身中的创建和管理锁。 In doing this the issue is where can we store the thread lock. The only options for storing any data between invocations of the wrapper are going to be on the wrapper itself, on the wrapped function object, in the case of wrapping an instance method, on the class instance, or for a class method, on the class.解决这个问题的关键在于我们可以在哪里存储线程锁。在被包装对象调用之间存储任何数据的惟一选项将是被包装对象本身，包括被包装的函数，类实例方法和类方法。 Lets first consider the case of a normal function. In that case what we can do is store the required thread lock on the wrapped function object itself.首先考虑一个正常函数的情况。在这种情况下，我们所能做的就是将所需的线程锁存储在包装的函数对象本身上。 123456789101112131415@decoratordef synchronized(wrapped, instance, args, kwargs): lock = vars(wrapped).get(&apos;_synchronized_lock&apos;, None) if lock is None: lock = vars(wrapped).setdefault(&apos;_synchronized_lock&apos;, threading.RLock()) with lock: return wrapped(*args, **kwargs)@synchronizeddef function(): pass&gt;&gt;&gt; function()&gt;&gt;&gt; function._synchronized_lock&lt;_RLock owner=None count=0&gt; A key issue we have to deal with in doing this is how to create the thread lock the first time it is required. To do that the first thing we need do is to see if we already have created a thread lock.我们要处理的一个关键问题是如何第一次创建线程锁。为此我们需要做的是查看线程锁是否已被创建。 lock = vars(wrapped).get(&#39;_synchronized_lock&#39;, None) If this returns a valid thread lock object we are fine and can continue on to attempt to acquire the lock. If however it didn’t exist we need to create it, but we have to be careful how we do this in order to avoid a race condition when two threads have entered this section of code at the same time and both believe it is responsible for creating the thread lock.如果返回一个有效的线程锁对象，那么我们就可以继续尝试获取锁。如果锁不存在我们需要创建锁,但是我们必需小心避免竞态条件，因为当两个线程同时进入这部分代码时，它们都会判断需要第一次创建锁。 The trick we use to solve this is to use:我们用来解决这个问题的窍门是: lock = vars(wrapped).setdefault(&#39;_synchronized_lock&#39;, threading.RLock()) In the case of two threads trying to set the lock at the same time, they will both actually create an instance of a thread lock, but by virtue of using dict.setdefault(), only one of them will win and actually be able to set it to the instance of the thread lock it created.当两个线程同时尝试创建锁时，它们都可能创建一个锁实例，但是由于使用了dict.setdefault()，只会有一个进程会成功。 As dict.setdefault() then returns whichever is the first value to be stored, both threads will then continue on and attempt to acquire the same thread lock object. It doesn’t matter here that one of the thread objects gets thrown away as it will only occur at the time of initialisation and only if there was actually a race to set it.因为 dict.setdefault() 总是返回它第一次存储的值。所以所有的线程都会继续运行并且尝试获取相同的锁对象。其中一个线程对象会被丢弃也不存在任何问题，因为这只会在初始化并出现竞争条件时才会发生。 We have therefore managed to replicate what we had originally, the difference though being that the thread lock is stored on the wrapped function, rather than on the stack of an enclosing function. We still have the issue that every instance method will have a distinct lock.因此，我们已经成功地复制了最初的内容，不同之处在于线程锁存储在被包装的函数上，而不是存储在一个封闭函数的堆栈上。我们仍然有一个问题，即每个实例方法都有一个不同的锁。(而不是一个实例内的所有同步方法共用一个锁) The simple solution is that we use the fact that this is what we are calling a universal decorator and use the ability to detect in what context the decorator was used.简单的解决方案是利用我们的通用装饰器，它提供了判断装饰器被使用的上下文的能力。 Specifically, what we want to do is detect when we are being used on an instance method or class method, and store the lock on the object passed as the instance argument instead.具体点说，我们需要判断当前是否在装饰一个类方法或实例方法，如果是，则将锁对象存储在 instance 参数上12345678910111213141516171819202122232425262728293031323334353637383940@decoratordef synchronized(wrapped, instance, args, kwargs): if instance is None: context = vars(wrapped) else: context = vars(instance) lock = context.get(&apos;_synchronized_lock&apos;, None) if lock is None: lock = context.setdefault(&apos;_synchronized_lock&apos;, threading.RLock()) with lock: return wrapped(*args, **kwargs)class Object(object): @synchronized def method_im(self): pass @synchronized @classmethod def method_cm(cls): passo1 = Object()o2 = Object()&gt;&gt;&gt; o1.method_im()&gt;&gt;&gt; o1._synchronized_lock&lt;_RLock owner=None count=0&gt;&gt;&gt;&gt; id(o1._synchronized_lock)4386605392&gt;&gt;&gt; o2.method_im()&gt;&gt;&gt; o2._synchronized_lock&lt;_RLock owner=None count=0&gt;&gt;&gt;&gt; id(o2._synchronized_lock)4386605456 This simple change has actually achieved the result we desired. If the synchronized decorator is used on a normal function then the thread lock will be stored on the function itself and it will stand alone and only be synchronized with calls to the same function.这个简单的改变实际上已经达到了我们想要的结果。如果同步的装饰器被用于一个正常的函数，那么线程锁将被存储在函数本身上，并且它将单独存在，并且只在调用相同的函数之间进行同步。 For the case of the instance method, the thread lock will be stored on the instance of the class the instance methods are bound too and any instance methods marked as being synchronized on that class will all synchronize on that single thread lock, thus mimicking how Java behaves.对于实例方法，线程锁将被存储在类的实例上，实例方法会绑定到类，因此在该类上标记为同步的任何实例方法都将在该线程锁上同步，从而模拟Java的行为。 Now what about that class method. In this case the instance argument is actually the class type. If the thread lock is stored on the type, then the result would be that if there were multiple class methods and they were all marked as synchronized, they would exclude each other. The thread lock in this case is distinct from any used by instance methods, but that is also actually what we want.那类方法呢。在这种情况下，instance 参数实际上是类。如果线程锁被存储在类上，那么结果将是，如果有多个类方法，并且它们都被标记为synchronized，那么它们将相互排斥。这种情况下线程锁的使用方式将不同于实例方法，但这实际上也是我们想要的。 Does the code work though for a class method?代码是否对类方法有效? 12345678&gt;&gt;&gt; Object.method_cm()Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; File &quot;test.py&quot;, line 38, in __call__ return self.wrapper(self.wrapped, instance, args, kwargs) File &quot;synctest.py&quot;, line 176, in synchronized lock = context.setdefault(&apos;_synchronized_lock&apos;,AttributeError: &apos;dictproxy&apos; object has no attribute &apos;setdefault&apos; Unfortunately not.很不幸，无效。 The reason this is the case is that the __dict__ of a class type is not a normal dictionary, but a dictproxy. A dictproxy doesn’t share the same methods as a normal dict and in particular, it does not provide the setdefault() method.这种情况的原因是，类__dict__不是一个普通的字典，而是一个dictproxy。一个dictproxy不与普通的dict共享相同的方法，特别是它不提供setdefault()方法。 We therefore need a different way of synchronizing the creation of the thread lock the first time for the case where instance is a class.因此，我们需要一种不同的方法来为类创建同步线程锁。 We also have another issue due to a dictproxy being used. That is that dictproxy doesn’t support item assignment.dictproxy 还导致了另一个问题，即它不支持属性设置1234&gt;&gt;&gt; vars(Object)[&apos;_synchronized_lock&apos;] = threading.RLock()Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: &apos;dictproxy&apos; object does not support item assignment What it does still support though is attribute assignment.但是类本身支持属性设置。123&gt;&gt;&gt; setattr(Object, &apos;_synchronized_lock&apos;, threading.RLock())&gt;&gt;&gt; Object._synchronized_lock&lt;_RLock owner=None count=0&gt; and since both function objects and class instances do as well, we will need to switch to that method of updating attributes.由于函数对象和类实例都可以，所以我们需要切换更新属性的方法。 Storing a meta lock on the decoratorAs to an alternative for using dict.setdefault() as an atomic way of setting the lock the first time, what we can do instead is use a meta thread lock stored on the @synchronized decorator itself. With this we still have the issue though of ensuring that only one thread can get to set it. We therefore use dict.setdefault() to control creation of the meta lock at least.作为dict.setdefault()第一次设置锁的原子方式的替代方法，我们可以做的是使用存储在@synchronized 装饰器本身上的元线程锁。由于元线程锁的创建仍存在竞争条件，因此需要使用dict.setdefault()实现元线程锁的原子性创建。123456789101112131415161718192021@decoratordef synchronized(wrapped, instance, args, kwargs): if instance is None: owner = wrapped else: owner = instance lock = vars(owner).get(&apos;_synchronized_lock&apos;, None) if lock is None: meta_lock = vars(synchronized).setdefault( &apos;_synchronized_meta_lock&apos;, threading.Lock()) with meta_lock: lock = vars(owner).get(&apos;_synchronized_lock&apos;, None) if lock is None: lock = threading.RLock() setattr(owner, &apos;_synchronized_lock&apos;, lock) with lock: return wrapped(*args, **kwargs) Note that because of the gap between checking for the existence of the lock for the wrapped function and creating the meta lock, after we have acquired the meta lock we need to once again check to see if the lock exists. This is to handle the case where two threads came into the code at the same time and are racing to be the first to create the lock.请注意，由于对封装函数的锁存在的检查与创建元锁之间的间隙，在我们获得了元锁之后，我们需要再次检查锁是否存在。这是为了避免两个线程同时在尝试创建锁而发生竞争条件。 Now one thing which is very important in this change is that we only swapped to using attribute access for updating the lock for the wrapped function. We have not changed to using getattr() for looking up the lock in the first place and are still looking it up in __dict__ as returned by vars().这里有一点很重要，我们仅仅在更新被包装对象上的锁时使用了属性访问方法。而在查找被包装对象上是否存在锁时，没有使用getattr()方法，而是继续在vars()返回的__dict__中查找它 This is necessary because when getattr() is used on an instance of a class, if that attribute doesn’t exist on the instance of the class, then the lookup rules mean that if the attribute instead existed on the class type, then that would be returned instead.这是必要的，因为当在类的实例上使用getattr()时，如果该属性在类的实例中不存在，那么查找规则意味着如果该属性在类类型上存在，那么将返回该属性。 This would cause problems if a synchronized class method was the first to be called, because it would then leave a lock on the class type. When the instance method was subsequently called, if getattr() were used, it would find the lock on the class type and return it and it would be wrongly used. Thus we stay with looking for the lock via __dict__ as that will only contain what actually exists in the instance.如果一个同步的类方法是第一个被调用的，这会导致问题，因为它会在类类型上留下一个锁。当随后调用实例方法时，如果使用了getattr()，它会找到类类型的锁并返回它，并且会被错误地使用。因此，我们继续通过__dict__寻找锁，因为它只包含实例中实际存在的内容。 With these changes we are now all done and all lock creation is now completely automatic, with an appropriate lock created for the different contexts the decorator is used in.有了这些修改，所有锁的创建都可以自动完成，并在不同的上下文中创建一个适当的锁。12345678910111213141516171819202122232425262728@synchronizeddef function(): passclass Object(object): @synchronized def method_im(self): pass @synchronized @classmethod def method_cm(cls): passo = Object()&gt;&gt;&gt; function()&gt;&gt;&gt; id(function._synchronized_lock)4338158480&gt;&gt;&gt; Object.method_cm()&gt;&gt;&gt; id(Object._synchronized_lock)4338904656&gt;&gt;&gt; o.method_im()&gt;&gt;&gt; id(o._synchronized_lock)4338904592 The code also works for where @synchronized is used on a static method or class type. In summary, the result for the different places @synchronized can be placed is:代码也适用于在静态方法或类中使用@synchronized。综上所述，@synchronized可以被应用的场景如下:123456789101112131415161718192021222324@synchronized # lock bound to function1def function1(): pass@synchronized # lock bound to function2def function2(): pass@synchronized # lock bound to Classclass Class(object): @synchronized # lock bound to instance of Class def function_im(self): pass @synchronized # lock bound to Class @classmethod def function_cm(cls): pass @synchronized # lock bound to function_sm @staticmethod def function_sm(): pass Implementing synchronized statementsSo we are all done with implementing support for synchronized methods, but what about those synchronized statements. The goal here is that we want to be able to write:所以，我们已经完成了对同步方法的支持，如何实现同步原语呢。要实现的目标是能按照下面的方式编写代码:123456789class Object(object): @synchronized def function_im_1(self): pass def function_im_2(self): with synchronized(self): pass That is, we need for synchronized to not only be usable as a decorator, but for it also be able to be used as a context manager.也就是说，我们需要 synchronized 装饰器不仅可以用作装饰器，而且还可以作为上下文管理器使用。 In this role, similar to with Java, it would be supplied the object on which synchronization is to occur, which for instance methods would be the self object or instance of the class.在synchronized作为上下文管理器时，类似于Java，需要提供给它执行同步操作的对象，对于实例方法而言，这个对象是 self 参数或者类的实例。 For an explanation of how we can do this though, you will need to wait for the next instalment in this series of posts.为了解释我们如何做到这一点，您将需要等待下一篇文章。]]></content>
      <categories>
        <category>函数装饰器</category>
        <category>猴子补订</category>
        <category>wrapt</category>
      </categories>
      <tags>
        <tag>python 标准库</tag>
        <tag>译文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[06 Maintaining decorator state using a class]]></title>
    <url>%2F2018%2F05%2F25%2Fwrapt%2F06-maintaining-decorator-state-using-a-class%2F</url>
    <content type="text"><![CDATA[本系列 blog 与 python wrat 模块相关，深入介绍了 Python 装饰器，猴子补订等相关内容，翻译于 https://github.com/GrahamDumpleton/wrapt/tree/master/blog 本篇内容: 使用类实现通用的装饰器模式 Maintaining decorator state using a classThis is the sixth post in my series of blog posts about Python decorators and how I believe they are generally poorly implemented. It follows on from the previous post titled Decorators which accept arguments, with the very first post in the series being How you implemented your Python decorator is wrong.这是有关装饰器使用系列博客文章中的第六篇。 In the previous post I described how to implement decorators which accept arguments. This covered mandatory arguments, but also how to have a decorator optionally accept arguments. I also touched on how one can maintain state between invocations of the decorator wrapper function for a specific wrapped function.上一篇文章中，我们讨论了如何实现一个带参数的装饰器，以及如何让装饰器可选的接收参数而不是必需输入参数。也讨论了如何让装饰器能在被包装函数的不同调用之间保持状态。 One of the approaches described for maintaining state was to implement the decorator as a class. Using this approach though resulted in an unexpected error.保持状态的一种可用方法是使用类实现装饰器。然而使用这个方式会导致一些问题 This post will explore the source of the error when attempting to implement our decorator as a class using our new decorator factory and function wrapper, and then see if any other issues crop up.本文将探讨在利用我们新的工厂函数和包装函数通过类创建装饰器时，产生错误的根源，以及是否还存在其他一些问题 Single decorator for functions and methodsAs described in the previous post, the pattern we were trying to use so as to allow us to use a class as a decorator was:正如前文所述，我们通过类实现装饰器的模式如下123456789101112class with_arguments(object): def __init__(self, arg): self.arg = arg @decorator def __call__(self, wrapped, instance, args, kwargs): return wrapped(*args, **kwargs)@with_arguments(arg=1)def function(): pass The intent here is that the application of the decorator, with arguments supplied, would result in an instance of the class being created. In the next phase where that is called with the wrapped function, the__call__() method with @decorator applied will be used as a decorator on the function to be wrapped. The end result should be that the __call__() method of the class instance created ends up being our wrapper function.这里的实现方式是，当应用带参数的装饰器时，将导致一个类实例被创建。在被包装函数被调用的第二阶段，使用@decorator的__call__()方法作为包装函数应用在被包装函数上。最终结果是__call__()实例方法将称为真正的包装函数。 When the decorated function is now called, the __call__() method of the class would be called with it in turn calling the wrapped function. As the __call__() method at that point is bound to an instance of the class, it would have access to the state that it contained.当被包装函数被调用时，__call__()类方法被调用，并在内部调用被包装函数。因为__call__()被绑定到类，因此它能够访问到，类保持的状态属性 When we tried this though we got, at the time that the decorator was being applied, the error:当我们这么做时，装饰器在被应用时发生了如下错误: 1234Traceback (most recent call last): File &quot;test.py&quot;, line 483, in &lt;module&gt; @with_arguments(1)TypeError: _decorator() takes exactly 1 argument (2 given) The _decorator() function in this case is the inner function from our decorator factory._decorator()是我们装饰器工厂函数的内部函数。 12345def decorator(wrapper): @functools.wraps(wrapper) def _decorator(wrapped): return function_wrapper(wrapped, wrapper) return _decorator The mistake that has been made here is that we are using a function closure to implement our decorator factory, yet we were expecting it to work on both normal functions and methods of classes.错误的原因是我们使用函数闭包实现装饰器工厂函数，却希望它能同时工作在普通函数和类方法上。 The reason this will not work is due to the binding that occurs when a method of a class is accessed. This process was described in a previous post in this series and is the result of the descriptor protocol being applied. This binding results in the reference to the instance of the class being automatically passed as the first argument to the method.不能正常工作的原因是当类方法被访问时，绑定将会发生。在之前的文章中有说过，这是描述符协议作用的结果。绑定的结果是类实例的引用将自动作为第一个参数传递给类方法。 Now as the _decorator() function was acting as a wrapper for the method call, and because _decorator() was not defined so as to accept both self and wrapped as arguments, the call would fail.因为_decorator()作为一个类方法的包装函数被使用，但是它却没有被定义成同时接收 self和wrapped 作为参数，所以调用失败。 We could create a special variant of the decorator factory to be used just on instance methods, but that goes against the specific complaint expressed earlier in regard to how people create multiple variants of decorators for use on normal functions and instance methods.我们可以创建一个仅用于类实例的装饰器工厂函数。但是这与我们之前要为类方法和函数创建统一的装饰器的初衷相违背。 To resolve this issue, what we can do is use our function wrapper for the decorator returned by the decorator factory, instead of a function closure.解决问题的方法是，使用我们的 function_wrapper 作为装饰器工厂的返回对象，而不是函数闭包。123456def decorator(wrapper): def _wrapper(wrapped, instance, args, kwargs): def _execute(wrapped): return function_wrapper(wrapped, wrapper) return _execute(*args, **kwargs) return function_wrapper(wrapper, _wrapper) Explicit binding of methods requiredThis above change now means we do not have to worry about whether @decorator is being applied to a normal function, instance method or even a class method. This is because in all cases, any reference to the instance being bound to is never passed through in args. Thus any wrapper function doesn’t need to worry about the distinction.上述改变意味着我们现在不必担心@decorator被应用在普通函数，实例方法还是一个类方法上。这是因为在所有的情况下，被绑定的实例对象不会通过 args被传递。因此所有的包装的函数无需进行区分。 Trying again with this change though, we are confronted with a further problem. This time at the point that the wrapped function is called.更改之后，重新进行测试，我们遇到了一个新的问题。这次发生在被被包装函数被调用的时候。123456&gt;&gt;&gt; function()Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; File &quot;test.py&quot;, line 243, in __call__ return self.wrapper(self.wrapped, None, args, kwargs)TypeError: __call__() takes exactly 5 arguments (4 given) The issue this time is that when @decorator is applied to the __call__() method, the reference it is passed is that of the unbound method. This is because this occurs during the processing of the class definition, long before any instance of the class has been created.现在这个问题是__call__()方法传递给@decorator发生在 类初始化，此时它是未绑定方法，任何类实例远还没被创建。 Normally the reference to the instance would be supplied later when the method is bound, but because our decorator is actually a factory there are two layers involved. The target instance is available to the upper factory as the ‘instance’ argument, but that isn’t being used in any way when the inner function wrapper object is being created which associates the function to be wrapped with our wrapper function.通常情况下，类实例的引用在方法被绑定时被提供，但是因为我们的装饰器实际是一个工厂函数，因此这里涉及到了两层绑定。外部包装函数的类实例被传递给工厂函数内部的 _wrapper 函数的instance参数。但是它在 function wrapper 对象被创建的时候，完全没有被使用。 To solve this problem we need for the case where we are being bound to aninstance, to explicitly bind the wrapper function ourselves against theinstance.为了解决这个问题，我们需要根据是否绑定了一个实例方法，显示使用类实例绑定我们的包装函数1234567891011def decorator(wrapper): def _wrapper(wrapped, instance, args, kwargs): def _execute(wrapped): if instance is None: return function_wrapper(wrapped, wrapper) elif inspect.isclass(instance): return function_wrapper(wrapped, wrapper.__get__(None, instance)) else: return function_wrapper(wrapped, wrapper.__get__(instance, type(instance))) return _execute(*args, **kwargs) return function_wrapper(wrapper, _wrapper) So what we are using here is the feature of our function wrapper that allows us to implement a universal decorator. That is, one which can change its behaviour dependent upon the context it is used in.所以我们正在使用的函数装饰器特性，允许我们实现一个通用的装饰器。它可以依给定的上下文自动发生改变。 In this case we had three cases we needed to deal with.在这个示例中，有三种情况需要我们处理。 The first is where the instance was None. This corresponds to a normal function, a static method or where the decorator was applied to a class type.第一种情况是 instance 为 None。这对应于decorator函数被应用在普通函数，类静态方法或一个类上 The second is where the instance was not None, but where it referred to a class type. This corresponds to a class method. In this case we need to bind the wrapper function to the class type by calling the __get__() method of the wrapper function explicitly.第二种情况是 instance 不为 None，但是是一个类对象。这对应用于一个类方法。这种情况下，我们需要通过包装函数的__get__()将包装函数显示绑定到一个类对象。 The third and final case is where the instance was not None, but whereit was not referring to a class type. This corresponds to an instancemethod. In this case we again need to bind the wrapper function, this timeto the instance.第三种即最后一种情况下，instance 不是None，也不是一个类对象。这对应于实例方法。在这种情况我们仍然需要绑定包装函数，只不过这次绑定的是类实例。 With these changes, we are now all done with addressing this issue, and to a large degree with filling out our new decorator pattern.改进之后，我们解决了所有问题，而且很大程度上完善了我们的装饰器模式 Do not try and reproduce thisSo the complete solution we now have at this point is:目前我们的解决方案如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475class object_proxy(object): def __init__(self, wrapped): self.wrapped = wrapped try: self.__name__ = wrapped.__name__ except AttributeError: pass @property def __class__(self): return self.wrapped.__class__ def __getattr__(self, name): return getattr(self.wrapped, name)class bound_function_wrapper(object_proxy): def __init__(self, wrapped, instance, wrapper, binding, parent): super(bound_function_wrapper, self).__init__(wrapped) self.instance = instance self.wrapper = wrapper self.binding = binding self.parent = parent def __call__(self, *args, **kwargs): if self.binding == &apos;function&apos;: if self.instance is None: instance, args = args[0], args[1:] wrapped = functools.partial(self.wrapped, instance) return self.wrapper(wrapped, instance, args, kwargs) else: return self.wrapper(self.wrapped, self.instance, args, kwargs) else: instance = getattr(self.wrapped, &apos;__self__&apos;, None) return self.wrapper(self.wrapped, instance, args, kwargs) def __get__(self, instance, owner): if self.instance is None and self.binding == &apos;function&apos;: descriptor = self.parent.wrapped.__get__(instance, owner) return bound_function_wrapper(descriptor, instance, self.wrapper, self.binding, self.parent) return self class function_wrapper(object_proxy): def __init__(self, wrapped, wrapper): super(function_wrapper, self).__init__(wrapped) self.wrapper = wrapper if isinstance(wrapped, classmethod): self.binding = &apos;classmethod&apos; elif isinstance(wrapped, staticmethod): self.binding = &apos;staticmethod&apos; else: self.binding = &apos;function&apos; def __get__(self, instance, owner): wrapped = self.wrapped.__get__(instance, owner) return bound_function_wrapper(wrapped, instance, self.wrapper, self.binding, self) def __call__(self, *args, **kwargs): return self.wrapper(self.wrapped, None, args, kwargs)def decorator(wrapper): def _wrapper(wrapped, instance, args, kwargs): def _execute(wrapped): if instance is None: return function_wrapper(wrapped, wrapper) elif inspect.isclass(instance): return function_wrapper(wrapped, wrapper.__get__(None, instance)) else: return function_wrapper(wrapped, wrapper.__get__(instance, type(instance))) return _execute(*args, **kwargs) return function_wrapper(wrapper, _wrapper) Take heed though of what was said in prior posts though. The object proxy implementation given here is not a complete solution. As a result, do not take this code and try and use it yourself as is. If you do you will findthat some aspects of performing introspection on the wrapped function will not work as indicated they should.尽管在之前的文章中提到过。这里给出的对象代理实现并不是一个完美实现。因此，不要使用这段代码。如果你使用了，就会发现。在被包装函数上的部分内省操作不会按照我们所说的执行。 In particular, access to the function __doc__ string will always yield None. Various attributes such as __qualname__ in Python 3 and __module__ are not propagated either.特别的，访问函数的__doc__属性总是返回 None。类似Python3中的新增变量 __qualname__和__module__也不能正确显示。 Handling an attribute such as __doc__ string correctly is actually a bit of a pain. This is because you cannot use a __doc__ property in an object proxy base class that returns the value from the wrapped functionand have it then work when you derive another class from it. This is because the separate __doc__ string attribute from the derived class, even if no documentation string were specified in the derived class, willoverride that of the base class.正确处理像__doc__这样的属性是比较费劲的。因为代理对象从被包装函数提取并返回属性值，其他从代理对象继承的类也会如此执行。但是却不能从代理对象返回适当的__doc__属性。这是因为即便子类没有覆盖__doc__，它也同样会覆盖子类的__doc__(读者注:__doc__属性获取方式比较特殊) So the object proxy as shown here was intended to be illustrative only ofwhat was required.所以这里展示的代理对象仅仅是一个参照实现。 In some respects all the code here is meant to be illustrative only. It is not here to say use this code but to show you the general path to implementing a more robust decorator implementation. It is to provide a narrative from which you can learn. If you were expecting a one line TLDR summary on how to do it, then you can forget it, things just aren’t that simple.大体上说，这里所有的代码都仅仅是参照实现。目的不是使用而是展示如何实现一个更加通用的装饰器。它只是提供给你一个学习的途径。不要期望通过简单的几行代码就能实现，事情不会那么简单。 Introducing the wrapt decorator moduleIf I am telling you not to use this code, what are you supposed to do then?如果我告诉你不要使用这里的代码，那你应该怎么做呢？ The answer to that already exists in the form of the wrapt module on PyPi.答案是在PyPi上已经有现成的 wrapt 模块。 The wrapt package has been available for a number of months already, but isn’t widely known of at this point. It implements all of what is described but also more. The module has a complete implementation of the object proxyrequired to make all this work correctly. The module also provides a range of other features related to the decorator factory as well as other separate features related to monkey patching in general.wrapt 模块已经上线几个月了，但是目前为止并没有广为人知。它实现了这里描述的所有细节，甚至更多。这个模块实现了一个完整的代理对象，能使所有代码正确执行。并且提供了很多和装饰器工厂函数相关的特性，也提供了很多和猴子补丁相关的特性。 Although I am now finally pointing out that this module exists, I will not be stopping the blog posts at this point as there is a range of topics I still want to cover. These include examples of how a universal decorator can be used, enabling/disabling of decorators, performance issues, the remaining parts of the implementation of the object proxy, monkey patching and much more.虽然我指出了wrapt 模块的存在，但是博客内容不会就此停止，因为我还有其他一些主题想要阐述。这些内容包括通用装饰器的应用，启用和关闭装饰器，装饰器执行性能问题，以及代理对象，猴子补丁的实现问题等等。 In the next post in this series I will look at one specific example of using a universal decorator by posing the question of if Python decorators are so wonderful, why does Python not provide a @synchronized decorator?接下来的博客，我将举一个通用装饰器应用的特殊示例，来说明Python 装饰器如此强大，为什么Pyhton不提供一个@synchronized装饰器。 Such a decorator was held up as a bit of a poster child as to what could be done with decorators when they were first introduced to the language, yet all the implementations I could find are half baked and not very practical in the real world. I believe that a universal decorator can help here and we can actually have a usable @synchronized decorator. I will therefore explore that possibility in the next post.在装饰器第一次被引入编程语言时，这个装饰器被当作是如何使用装饰器的经典示例。然而我能找到的所有实现都是半成品，很少在现实世界中被使用。我相信这里的通用装饰器能帮助我们实现一个可用的@synchronized装饰器。我将在下一篇博客中详述它。]]></content>
      <categories>
        <category>函数装饰器</category>
        <category>猴子补订</category>
        <category>wrapt</category>
      </categories>
      <tags>
        <tag>python 标准库</tag>
        <tag>译文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[05 Decorators which accept arguments]]></title>
    <url>%2F2018%2F05%2F24%2Fwrapt%2F05-decorators-which-accept-arguments%2F</url>
    <content type="text"><![CDATA[本系列 blog 与 python wrat 模块相关，深入介绍了 Python 装饰器，猴子补订等相关内容，翻译于 https://github.com/GrahamDumpleton/wrapt/tree/master/blog 本篇内容: 向装饰器传递参数 Decorators which accept arguments带参数的装饰器 This is the fifth post in my series of blog posts about Python decorators and how I believe they are generally poorly implemented. It follows on from the previous post titled Implementing a universal decorator, with the very first post in the series being How you implemented your Python decorator is wrong.这是第 5 篇博客 So far in this series of posts I have explained the short comings of implementing a decorator in the traditional way they are done in Python. I have shown an alternative implementation based on an object proxy and a descriptor which solves these issues, as well as provides the ability to implement what I call a universal decorator. That is, a decorator which understands the context it was used in and can determine whether it was applied to a normal function, an instance method, a class method or a class type.目前为止，我阐述了使用闭包实现装饰器的不足之处。展示了另一种使用代理对象和描述符实现装饰器的方式，它解决了诸多问题，并提供了一个我称之为通用装饰器的能力。即一个装饰器具能自适应它所在的上下文，自动应用在函数，实例方法，类方法和类本身上 In this post, I am going to take the decorator factory which was described in the previous posts and describe how one can use that to implement decorators which accept arguments. This will cover mandatory arguments, but also how to have the one decorator optionally except arguments.在这篇文章中，我将使用前面文章中描述的装饰器工厂函数，并描述如何使用它来实现接受参数的装饰器。这将包括强制参数，也包括如何让一个装饰器有选择地除去参数。 Pattern for creating decoratorsThe key component of what was described in the prior posts was a function wrapper object. I am not going to replicate the code for that here so see the prior posts. In short though, it was a class type which accepted the function to be wrapped and a user supplied wrapper function. The instance of the resulting function wrapper object was used in place of the wrapped function and when called, would delegate the calling of the wrapped function to the user supplied wrapper function. This allows a user to modify how the call was made, performing actions before or after the wrapped function was called, or modify input arguments or the result.前面文章中描述的关键组件是一个函数包装器对象。我不打算复制代码，所以请参阅前面的帖子。简而言之，它是一个类类型，它接受要被包装的函数和一个用户提供的包装器函数。所得到的函数包装器对象的实例被用来代替被包装函数，当调用时，会将被包装函数的调用委托给用户提供的包装器函数。这允许用户修改调用的方式，在调用被包装函数之前或之后执行操作，或者修改输入参数或结果。 This function wrapper was used in conjunction with the decorator factory which was also described:function wrapper 和装饰器工厂一起使用如下:12345def decorator(wrapper): @functools.wraps(wrapper) def _decorator(wrapped): return function_wrapper(wrapped, wrapper) return _decorator allowing a user to define their own decorator as:用户自定义装饰器的方式如下12345678910@decoratordef my_function_wrapper(wrapped, instance, args, kwargs): print(&apos;INSTANCE&apos;, instance) print(&apos;ARGS&apos;, args) print(&apos;KWARGS&apos;, kwargs) return wrapped(*args, **kwargs)@my_function_wrapperdef function(a, b): pass In this example, the final decorator which is created does not accept any arguments, but if we did want the decorator to be able to accept arguments, with the arguments accessible at the time the user supplied wrapper function was called, how would we do that?在本例中，创建的最终装饰器不接受任何参数，但如果我们希望装饰器能够接受参数，在调用用户提供的包装器函数时可访问传入的参数，那么我们该如何做呢? Using a function closure to collect arguments使用函数闭包收集参数 The easiest way to implement a decorator which accepts arguments is using a function closure.最早的实现一个能接收参数的装饰器的方式是使用函数闭包:123456789def with_arguments(arg): @decorator def _wrapper(wrapped, instance, args, kwargs): return wrapped(*args, **kwargs) return _wrapper@with_arguments(arg=1)def function(): pass In effect the outer function is a decorator factory in its own right, where a distinct decorator instance will be returned which is customised according to what arguments were supplied to the outer decorator factory function.实际上，外部函数本身是一个工厂函数，将根据传入的参数，返回不同的装饰器实例。 So, when this outer decorator factory function is applied to a function with the specific arguments supplied, it returns the inner decorator function and it is actually that which is applied to the function to be wrapped. When the wrapper function is eventually called and it in turn calls the wrapped function, it will have access to the original arguments to the outer decorator factory function by virtue of being part of the function closure.因此，当外部工厂函数被应用到一个具有特定参数的函数时，它返回内部装饰器函数，实际上它是应用于被包装的函数。当包装器函数最终被调用时，它会调用被包装函数，并通过作为函数闭包的一部分来访问传递给外部工厂函数的原始参数。 Positional or keyword arguments can be used with the outer decorator factory function, but I would suggest that keyword arguments are perhaps a better convention to adopt as I will show later.位置或关键字参数可以与外部decorator工厂函数一起使用，但是我认为关键字参数可能是一个更好的惯例，我稍后会展示 What now if a decorator with arguments had default values and as such they could be left out from the call. With this way of implementing the decorator, even though one would not need to pass the argument, one cannot avoid needing to still write it out as a distinct call. That is, you still need to supply empty parentheses.现在，如果带有参数的装饰器具有默认值，并且它们可以从调用中删除。使用这种方法来实现装饰器，即使不需要传递参数，也必需将其作为一个不同的调用来写出来。也就是说，仍然需要提供空括号。123456789def with_arguments(arg=&apos;default&apos;): @decorator def _wrapper(wrapped, instance, args, kwargs): return wrapped(*args, **kwargs) return _wrapper@with_arguments()def function(): pass Although this is being specific and would dictate there be only one way to do it, it can be felt that this looks ugly. As such some people like to have a way that the parentheses are optional if the decorator arguments all have default values and none are being supplied explicitly. In other words, the desire is that when there are no arguments to be passed, that one can write:尽管这只是一个特例，但看起来不优雅。大多数更喜欢当所有参数都是可选，并没有被显示传递参数时，括号时可选的。换句话说，当没有参数被传递时，可以被写成:123@with_argumentsdef function(): pass There is actually some merit in this idea when looked at the other way around. That is, if a decorator originally accepted no arguments, but it was determined later that it needed to be changed to optionally accept arguments, then if the parentheses could be optional, it would allow arguments to now be accepted, without needing to go back and change all prior uses of the original decorator where no arguments were supplied.当我们从另一个角度看问题时，这个想法实际上是有价值的。如果一个装饰器最初不接收参数，但是之后又需要可选的接收参数。如果括号是可选的，那么原来不带参数调用装饰器的代码也无需改变 Optionally allowing decorator argumentsTo allow the decorator arguments to be optionally supplied, we can change the above recipe to:允许装饰器添加可选参数，可以将上面的方法更改为:12345678910111213141516def optional_arguments(wrapped=None, arg=1): if wrapped is None: return functools.partial(optional_arguments, arg=arg) @decorator def _wrapper(wrapped, instance, args, kwargs): return wrapped(*args, **kwargs) return _wrapper(wrapped)@optional_arguments(arg=2)def function1(): pass@optional_argumentsdef function2(): pass With the arguments having default values, the outer decorator factory would take the wrapped function as first argument with None as a default. The decorator arguments follow. Decorator arguments would need to be passed as keyword arguments. On the first call, wrapped will be None, and a partial is used to return the decorator factory again. On the second call, wrapped is passed and this time it is wrapped with the decorator.当具有默认的可选参数时，外部工厂函数将被包装函数作为第一个参数并默认为 None。后面时其他参数。工厂函数的参数必需是关键词参数。第一次调用时，被包装函数是 None，通过 partical 函数再一次返回装饰器工厂函数。第二次调用，被包装函数将被传入并被装饰器包装。(读者注: 多看几遍代码就懂了) Because we have default arguments though, we don’t actually need to pass the arguments, in which case the decorator factory is applied direct to the function being decorated. Because wrapped is not None when passed in, the decorator is wrapped around the function immediately, skipping the return of the factory a second time.将装饰器被直接装饰函数时，因为默认参数的存在，我们不需要显示传递参数。因为 wrapped 惨数值不是None，装饰器将跳过第二次返回工厂函数，直接装饰函数。 Now why I said a convention of having keyword arguments may perhaps be preferable, is that Python 3 allows you to enforce it using the new keyword only argument syntax.现在，为什么我说一个具有关键字参数的约定可能更可取，那就是Python 3允许您使用新的关键字参数语法来强制执行它。 123456789def optional_arguments(wrapped=None, *, arg=1): if wrapped is None: return functools.partial(optional_arguments, arg=arg) @decorator def _wrapper(wrapped, instance, args, kwargs): return wrapped(*args, **kwargs) return _wrapper(wrapped) This way you avoid the problem of someone accidentally passing in a decorator argument as the positional argument for wrapped. For consistency, keyword only arguments can also be enforced for required arguments even though it isn’t strictly necessary.这样，就可以避免有人不小心将装饰器参数作为位置参数传递给 wrapped。对于一致性，关键字参数也可以被强制执行，即使它不是必需的。12345def required_arguments(*, arg): @decorator def _wrapper(wrapped, instance, args, kwargs): return wrapped(*args, **kwargs) return _wrapper Maintaining state between wrapper callsQuite often a decorator doesn’t perform an isolated task for each invocation of a function it may be applied to. Instead it may need to maintain state between calls. A classic example of this is a cache decorator.通常，装饰器不会为每次调用的函数执行单独的任务。相反，它可能需要在调用之间保持状态。一个典型的例子是缓存装饰器。 In this scenario, because no state information can be maintained within the wrapper function itself, any state object needs to be maintained in an outer scope which the wrapper has access to.在这种情况下，因为没有状态信息可以在包装器函数本身中维护，所以任何状态对象都需要在包装器能够访问的外部范围内进行维护。 There are a few ways in which this can be done.有几种方法可以做到这一点。 The first is to require that the object which maintains the state, be passed in as an explicit argument to the decorator.第一种方法是要求保持状态的对象作为显式参数传递给decorator。 12345678910111213141516def cache(d): @decorator def _wrapper(wrapped, instance, args, kwargs): try: key = (args, frozenset(kwargs.items())) return d[key] except KeyError: result = d[key] = wrapped(*args, **kwargs) return result return _wrapper_d = &#123;&#125;@cache(_d)def function(): return time.time() Unless there is a specific need to be able to pass in the state object, a second better way is to create the state object on the stack within the call of the outer function.除非有特定的需要能够传入状态对象，否则第二个更好的方法是在外部函数的调用中在堆栈上创建状态对象。1234567891011121314151617def cache(wrapped): d = &#123;&#125; @decorator def _wrapper(wrapped, instance, args, kwargs): try: key = (args, frozenset(kwargs.items())) return d[key] except KeyError: result = d[key] = wrapped(*args, **kwargs) return result return _wrapper(wrapped)@cachedef function(): return time.time() In this case the outer function rather than taking a decorator argument, is taking the function to be wrapped. This is then being explicitly wrapped by the decorator defined within the function and returned.这种情况下，外部包装函数在函数内部自定状态对象，而不是通过参数显示传递。 If this was a reasonable default, but you did in some cases still need to optionally pass the state object in as an argument, then optional decorator arguments could instead be used.如果这是一个合理的默认值，但是在某些情况下，仍然需要将状态对象作为参数传递进来，那么可以使用可选的装饰数参数。12345678910111213141516171819202122232425262728293031def cache(wrapped=None, d=None): if wrapped is None: return functools.partial(cache, d=d) if d is None: d = &#123;&#125; @decorator def _wrapper(wrapped, instance, args, kwargs): try: key = (args, frozenset(kwargs.items())) return d[key] except KeyError: result = d[key] = wrapped(*args, **kwargs) return result return _wrapper(wrapped)@cachedef function1(): return time.time()_d = &#123;&#125;@cache(d=_d)def function2(): return time.time()@cache(d=_d)def function3(): return time.time() Decorators as a classNow way back in the very first post in this series of blog posts, a way in which a decorator could be implemented as a class was described.现在回到本系列博文的第一篇文章中，描述了一个装饰器可以作为一个类实现的方式。1234567class function_wrapper(object): def __init__(self, wrapped): self.wrapped = wrapped def __call__(self, *args, **kwargs): return self.wrapped(*args, **kwargs) Although this had short comings which were explained and which resulted in the alternate decorator pattern being presented, this original approach is also able to maintain state. Specifically, the constructor of the class can save away the state object as an attribute of the instance of the class, along with the reference to the wrapped function.就像之前已经阐述的，这种通过类实现的装饰器存在缺陷，但是作为一种替代模式，这种原始的方法也能保持状态。具体地说，类的构造函数可以将状态对象连同被包装函数保存为类实例的属性1234567891011121314151617class cache(object): def __init__(self, wrapped): self.wrapped = wrapped self.d = &#123;&#125; def __call__(self, *args, **kwargs): try: key = (args, frozenset(kwargs.items())) return self.d[key] except KeyError: result = self.d[key] = self.wrapped(*args, **kwargs) return result@cachedef function(): return time.time() Use of a class in this way had some benefits in that where the work of the decorator was quite complex, it could all be encapsulated in the class implementing the decorator itself.在装饰器逻辑特别复杂时，这种通过类实现的装饰器也存在一些好处。可以拆分封装在不同的类方法中 With our new function wrapper and decorator factory, the user can only supply the wrapper as a function, which would appear to limit being able to implement a direct equivalent.使用我们的新函数包装器和装饰器工厂，用户只能将装饰器实现为函数，这似乎限制了装饰器作为类的实现方式。 One could still use a class to encapsulate the required behaviour, with an instance of the class created within the scope of a function closure for use by the wrapper function, and the wrapper function then delegating to that, but it isn’t self contained as it was before.一种实现实现时，仍然使用类封装所需的逻辑，并在函数闭包类创建实例供包装函数使用。装饰器将功能委托给类实例，但是本身不是作为类实现的 The question is, is there any way that one could still achieve the same thing with our new decorator pattern. Turns out there possibly is.问题是，我们的新装饰器模式是否可以实现同样的功能。结果可能是。 What one should be able to do, at least for where there are required arguments, is do:一个应该能做的，至少是在必需传入参数的情况下，可以这样做:123456789101112class with_arguments(object): def __init__(self, arg): self.arg = arg @decorator def __call__(self, wrapped, instance, args, kwargs): return wrapped(*args, **kwargs)@with_arguments(arg=1)def function(): pass What will happen here is that application of the decorator with arguments being supplied, will result in an instance of the class being created. In the next phase where that is called with the wrapped function, the __call__() method with @decorator applied will be used as a decorator on the wrapped function. The end result should be that the __call__() method of the class instance created ends up being our wrapper function.执行逻辑是这样的，带参数的装饰器被使用时，一个类实例被创建。在被包装函数被调用时，使用 @decorator 装饰的 __call__()作为包装函数被调用。最终结果是类实例的 __call__()方法称为了我们的包装函数。 When the decorated function is now called, the __call__() method of the class would be called to then in turn call the wrapped function. As the __call__() method at that point is bound to an instance of the class, it would have access to the state that it contained.被装饰函数调用时，类实例的 __call__()被调用进而调用被包装函数。因为__call__()是实例的绑定方法，所以能够访问到类实例拥有的状态对象。What actually happens when we do this though?事实上运行结果会怎么样呢？1234Traceback (most recent call last): File &quot;test.py&quot;, line 483, in &lt;module&gt; @with_arguments(1)TypeError: _decorator() takes exactly 1 argument (2 given) So nice idea, but it fails.理想很丰满，显示很骨干。 Is it game over? The answer is of course not, because if it isn’t obvious by now, I don’t give up that easily.游戏结束了吗?答案当然是否定的，因为如果现在还不明显，我不会轻易放弃。 Now the reason this failed is actually because of how our decorator factory is implemented.失败的原因就在于装饰器工厂函数的实现方式12345def decorator(wrapper): @functools.wraps(wrapper) def _decorator(wrapped): return function_wrapper(wrapped, wrapper) return _decorator I will not describe in this post what the problem is though and will leave the solving of this particular problem to a short followup post as the next in this blog post series on decorators.我不会在这篇文章中描述问题的原因，并将把解决这个特别的问题留在下一篇文章中。]]></content>
      <categories>
        <category>函数装饰器</category>
        <category>猴子补订</category>
        <category>wrapt</category>
      </categories>
      <tags>
        <tag>python 标准库</tag>
        <tag>译文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[04 Implementing a universal decorator]]></title>
    <url>%2F2018%2F05%2F22%2Fwrapt%2F04-Implementing%20a%20universal%20decorator%2F</url>
    <content type="text"><![CDATA[本系列 blog 与 python wrat 模块相关，深入介绍了 Python 装饰器，猴子补订等相关内容，翻译于 https://github.com/GrahamDumpleton/wrapt/tree/master/blog 本篇内容: 创建一个通用的装饰器 Implementing a universal decoratorThis is the fourth post in my series of blog posts about Python decorators and how I believe they are generally poorly implemented. It follows on from the previous post titled Implementing a factory for creating decorators, with the very first post in the series being How you implemented your Python decorator is wrong.这是Python 装饰器系列博客中的第三篇。 In the second post of this series I described a better way of building a decorator which avoided a number of issues I outlined with the typical way in which decorators are coded. This entailed a measure of boiler plate code which needed to be replicated each time. In the previous post to this one I described how we could use a decorator as a decorator factory, and a bit of delegation to hide the boiler plate code and reduce what a user needed to actually declare for a new decorator.第二篇博客中，我描述了一种创建装饰器的更好的方法，它避免了传统方式创建装饰器存在的几个问题。但是会出现重复代码，并需要编写重复的样板代码。在上一篇博客中，我进一步阐述了如何使用装饰器工厂函数和代理降低创建一个新装饰器的代码量。 In the prior post I also started to walk through some customisations which could be made to the decorator pattern which would allow the decorator wrapper function provided by a user to ascertain in what context it was used in. That is, for the wrapper function to be able to determine whether it was applied to a function, an instance method, a class method or a class type. The ability to determine the context in this way is what I called a universal decorator, as it avoided the need to have separate decorator implementations for use in each circumstance as is done now with a more traditional way of implementing a decorator.在之前的博客中，我也简单了讨论了如何实现装饰器，以让用户提供的装饰函数能够确定其被使用的上下文。即让包装函数能确定，它是被应用在函数，实例方法，类方法，类对象中的哪一个。我把这种能确定上下文的能力称为通用装饰器，因为装饰器不是在各个环境种被单独实现，而是以一种更加统一的方式创建。 The walk through got as far as showing how one could distinguish between when the decorator was used on a normal function vs an instance method. Unfortunately the change required to be able to detect when an instance method was called via the class would cause problems for a class method or static method, so we still have a bit more work to do.通过演示，我们可以看到，如何区分decorator被用于普通函数和实例方法。遗憾的是，当通过类调用类方法和静态方法时将出现问题，因而需要调整。我们还有更多的工作要做 In this post I will describe how we can accommodate the cases of a class method and a static method as well as explore other use cases which may give us problems in trying to come up with this pattern for a universal decorator.在本文中，我将描述如何适应类方法和静态方法的案例，以及探索其他可能会给我们带来问题的用例，以便找到实现通用装饰器的模式。 Normal functions vs instance methodsThe pattern for our universal decorator as described so far was as follows:通用装饰器模式描述如下:1234567891011121314151617181920212223242526class bound_function_wrapper(object_proxy): def __init__(self, wrapped, instance, wrapper): super(bound_function_wrapper, self).__init__(wrapped) self.instance = instance self.wrapper = wrapper def __call__(self, *args, **kwargs): if self.instance is None: instance, args = args[0], args[1:] wrapped = functools.partial(self.wrapped, instance) return self.wrapper(wrapped, instance, args, kwargs) return self.wrapper(self.wrapped, self.instance, args, kwargs)class function_wrapper(object_proxy): def __init__(self, wrapped, wrapper): super(function_wrapper, self).__init__(wrapped) self.wrapper = wrapper def __get__(self, instance, owner): wrapped = self.wrapped.__get__(instance, owner) return bound_function_wrapper(wrapped, instance, self.wrapper) def __call__(self, *args, **kwargs): return self.wrapper(self.wrapped, None, args, kwargs) This was used in conjunction with our decorator factory:这将和装饰器工厂函数一起使用12345def decorator(wrapper): @functools.wraps(wrapper) def _decorator(wrapped): return function_wrapper(wrapped, wrapper) return _decorator To test whether everything is working how we want we used our decorator factory to create a decorator which would dump out the values of any instance the wrapped function is bound to, and the arguments passed to the call when executed.为了测试当前的模式能在任何情况下都能工作，我们需要使用装饰器工厂创建一个装饰器，它能在执行时打印绑定的 instance对像，以及传递进来的 参数12345@decoratordef my_function_wrapper(wrapped, instance, args, kwargs): print(&apos;INSTANCE&apos;, instance) print(&apos;ARGS&apos;, args) return wrapped(*args, **kwargs) This gave us the desired results for when the decorator was applied to a normal function and instance method, including when an instance method was called via the class and the instance passed in explicitly.这给我们提供了想要的结果，当decorator被应用到一个正常的函数和实例方法时，包括通过显式传入实例调用实例方法时12345678910111213141516171819202122@my_function_wrapperdef function(a, b): pass&gt;&gt;&gt; function(1, 2)INSTANCE NoneARGS (1, 2)class Class(object): @my_function_wrapper def function_im(self, a, b): passc = Class()&gt;&gt;&gt; c.function_im(1, 2)INSTANCE &lt;__main__.Class object at 0x1085ca9d0&gt;ARGS (1, 2)&gt;&gt;&gt; Class.function_im(c, 1, 2)INSTANCE &lt;__main__.Class object at 0x1085ca9d0&gt;ARGS (1, 2) The change to support the latter however, broke things for the case of the decorator being applied to a class method. Similarly for a static method.装饰起被应用到类方法以及静态方法时，参数传递发生了变化(读者注:翻译不出来)12345678910111213141516171819class Class(object): @my_function_wrapper @classmethod def function_cm(self, a, b): pass @my_function_wrapper @staticmethod def function_sm(a, b): pass&gt;&gt;&gt; Class.function_cm(1, 2)INSTANCE 1ARGS (2,)&gt;&gt;&gt; Class.function_sm(1, 2)INSTANCE 1ARGS (2,) Class methods and static methodsThe point we are at therefore, is that in the case where the instance is passed as None, we need to be able to distinguish between the three cases of:因此，我们要指出的是，在实例被传递为None的情况下，我们需要能够区分这三种情况: an instance method being called via the class 通过类直接调用实例方法a class method being called 类方法被调用a static method being called 静态方法被调用 One way this can be done is by looking at the __self__ attribute of the bound function. This attribute will provide information about the type of object which the function was bound to at that specific point in time. Lets first check this out for where a method is called via the class.可以这样做的一种方法是查看绑定函数的__self__属性。该属性将提供关于该函数在特定时间点绑定到的对象类型的信息。让我们先来看看通过类调用不同方法时，此属性的值。123456789101112&gt;&gt;&gt; print(Class.function_im.__self__)None&gt;&gt;&gt; print(Class.function_cm.__self__)&lt;class &apos;__main__.Class&apos;&gt;&gt;&gt;&gt; print(Class.function_sm.__self__)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; File &quot;test.py&quot;, line 19, in __getattr__ return getattr(self.wrapped, name)AttributeError: &apos;function&apos; object has no attribute &apos;__self__&apos; So for the case of calling an instance method via the class, __self__ will be None, for a class method it will be the class type and in the case of a static method, there will not even be a __self__ attribute. This would therefore appear to give us a way of detecting the different cases.因此，对于通过类调用实例方法的情况，__self__将是None，对于类方法，它将是类类型，在静态方法的情况下，甚至不会有__self__属性。因此，这似乎给我们提供了一种检测不同病例的方法。 Before we code up a solution based on this though, lets check with Python 3 just to be sure we are okay there and that nothing has changed.在我们编写一个基于此的解决方案之前，我们先检查一下Python 3，以确保我们在那里没问题，并且没有任何变化。 12345678910111213141516&gt;&gt;&gt; print(Class.function_im.__self__)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; File &quot;dectest.py&quot;, line 19, in __getattr__ return getattr(self.wrapped, name)AttributeError: &apos;function&apos; object has no attribute &apos;__self__&apos;&gt;&gt;&gt; print(Class.function_cm.__self__)&lt;class &apos;__main__.Class&apos;&gt;&gt;&gt;&gt; print(Class.function_sm.__self__)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; File &quot;test.py&quot;, line 19, in __getattr__ return getattr(self.wrapped, name)AttributeError: &apos;function&apos; object has no attribute &apos;__self__&apos; That isn’t good, Python 3 behaves differently to Python 2, meaning we aren’t going to be able to use this approach. Why is this case?这不是很好，Python 3对Python 2的行为是不同的，这意味着我们不能使用这种方法。为什么会出现这种情况? The reason for this is that in Python 3 they decided to eliminate the idea of an unbound method and this check was relying on the fact that when accessing an instance method via the class, it would actually return an instance of an unbound method for which the __self__ attribute was None. So although we can distinguish the case for a class method still, we can now no longer distinguish the case of calling an instance method via the class, from the case of calling a static method.发生这种情况的原因是，Python3决定移除未绑定方法，并且当通过类直接调用实例方法时，是否返回一个未绑定对象取决于 __self__ 是否为None。因此，尽管我们仍然可以区分类方法的情况，但我们现在不能区分通过类调用实例方法和调用静态方法这两种情况。(读者注:Pyhton3 已经没有未绑定对象这个对象，通过类直接调用实例方法时返回的也是函数。而Python2种通过类调用实例的返回值类型依赖于 __self__是否为None，所以Python3种删除了此属性) The lack of this ability therefore leaves us with a bit of a problem for Python 3 and the one alternative isn’t necessarily a completely fool proof way of doing it.因此，在Python3 中，这种检查存在一定问题，而另一种看似愚蠢的方法并不一定完全不行。 This alternative is in the constructor of the function wrapper, to look at the type of the wrapped object and determine if it is an instance of a class method or static method. This information can then be passed through to the bound function wrapper and checked.这个替代方法是在 function wrapper 构造函数内，检查被包装对象的类型，并确定它是类方法还是静态方法。然后，将判定信息传递到 bound function wrapper 并进行进一步检查。12345678910111213141516171819202122232425262728293031323334class bound_function_wrapper(object_proxy): def __init__(self, wrapped, instance, wrapper, binding): super(bound_function_wrapper, self).__init__(wrapped) self.instance = instance self.wrapper = wrapper self.binding = binding def __call__(self, *args, **kwargs): if self.binding == &apos;function&apos; and self.instance is None: instance, args = args[0], args[1:] wrapped = functools.partial(self.wrapped, instance) return self.wrapper(wrapped, instance, args, kwargs) return self.wrapper(self.wrapped, self.instance, args, kwargs)class function_wrapper(object_proxy): def __init__(self, wrapped, wrapper): super(function_wrapper, self).__init__(wrapped) self.wrapper = wrapper if isinstance(wrapped, classmethod): self.binding = &apos;classmethod&apos; elif isinstance(wrapped, staticmethod): self.binding = &apos;staticmethod&apos; else: self.binding = &apos;function&apos; def __get__(self, instance, owner): wrapped = self.wrapped.__get__(instance, owner) return bound_function_wrapper(wrapped, instance, self.wrapper, self.binding) def __call__(self, *args, **kwargs): return self.wrapper(self.wrapped, None, args, kwargs) Now this test is a bit fragile, but as I showed before though, the traditional way that a decorator is written will fail if wrapped around a class method or static method as it doesn’t honour the descriptor protocol. As such it is a pretty safe bet right now that I will only ever find an actual class method or static method object because no one would be using decorators around them.这样测试貌似有些脆弱，但正如我之前展示的，传统方式下，使用装饰器包装类方法和静态方法时将会失败，因为它不支持描述符协议。因此现在这样做是十分安全的。因为构造函数内不会出现被包装的类方法对象和静态方法 If someone is actually implementing the descriptor protocol in their decorator, hopefully they would also be using an object proxy as is done here. Because the object proxy implements __class__ as a property, it would return the class of the wrapped object, this should mean that an isinstance() check will still be successful as isinstance() gives priority to what __class__ yields rather than the actual type of the object.如果有人实际上在他们的decorator中实现了描述符协议，那么希望他们也可以在这里使用对象代理。因为对象代理拥有class属性，它将返回被包装对象的类，这意味着isinstance()检查仍然会成功，因为isinstance()会优先考虑class的返回结果，而不是对象的实际类型。 Anyway, trying out our tests again with this change we get:无论如何，更改后，我们重新测试如下1234567891011121314151617181920212223&gt;&gt;&gt; c.function_im(1,2)INSTANCE &lt;__main__.Class object at 0x101f973d0&gt;ARGS (1, 2)&gt;&gt;&gt; Class.function_im(c, 1, 2)INSTANCE &lt;__main__.Class object at 0x101f973d0&gt;ARGS (1, 2)&gt;&gt;&gt; c.function_cm(1,2)INSTANCE &lt;__main__.Class object at 0x101f973d0&gt;ARGS (1, 2)&gt;&gt;&gt; Class.function_cm(1, 2)INSTANCE NoneARGS (1, 2)&gt;&gt;&gt; c.function_sm(1,2)INSTANCE &lt;__main__.Class object at 0x101f973d0&gt;ARGS (1, 2)&gt;&gt;&gt; Class.function_sm(1, 2)INSTANCE NoneARGS (1, 2) Success, we have fixed the issue with the argument list when both a class method and a static method are called.成功，我们已经修复了调用类方法和静态方法时参数列表问题 The problem now is that although the instance argument is fine for the case of an instance method call, whether that be via the instance or the class, the instance as passed for a class method and static method aren’t particularly useful as we can’t use it to distinguish them from other cases.现在的问题是，虽然对通过实例调用方法时， instance 参数没有问题。但是无论时通过实例还是类，传递给类方法和静态方法的 instance 参数都没有什么用。并且我们不能将它同其他情形区别开。 Ideally what we want in this circumstance is that for a class method call we want the instance argument to always be the class type, and for the case of a static method call, for it to always be None.理想情况下，我们希望调用类方法时 instance 参数始终为类对象，而调用静态方法时，则使用为 None For the case of a static method, we could just check for ‘staticmethod’ from when we checked the type of object which was wrapped.对于静态方法，我们只需要在检查被包装类型时，判断 ‘staticmethod’ 即可 For the case of a class method, if we look back at our test to see if we could use the __self__ attribute, what we found was that for the class method, __self__ was the class instance and for a static method the attribute didn’t exist.对于类方法的情况，如果我们回头看一下我们的测试，看看是否可以使用__self__属性，我们发现，对于类方法，__self__是类实例，对于静态方法，属性不存在。 What we can therefore do, is if the type of the wrapped object wasn’t a function, then we can lookup up the value of __self__, defaulting to None if it doesn’t exist. This one check will cater for both cases.因此，我们可以做的是，如果包装对象的类型不是一个函数，那么我们可以查找__self__的值，如果它不存在的话，就会默认为None。这将满足这两种情况。 What we now therefore have is:12345678910111213141516171819class bound_function_wrapper(object_proxy): def __init__(self, wrapped, instance, wrapper, binding): super(bound_function_wrapper, self).__init__(wrapped) self.instance = instance self.wrapper = wrapper self.binding = binding def __call__(self, *args, **kwargs): if self.binding == &apos;function&apos;: if self.instance is None: instance, args = args[0], args[1:] wrapped = functools.partial(self.wrapped, instance) return self.wrapper(wrapped, instance, args, kwargs) else: return self.wrapper(self.wrapped, self.instance, args, kwargs) else: instance = getattr(self.wrapped, &apos;__self__&apos;, None) return self.wrapper(self.wrapped, instance, args, kwargs) and if we run our tests one more time, we finally get the result we have been looking for:如果我们重新测试一次，我们将得到我们想要得结果1234567891011121314151617181920212223&gt;&gt;&gt; c.function_im(1,2)INSTANCE &lt;__main__.Class object at 0x10c2c43d0&gt;ARGS (1, 2)&gt;&gt;&gt; Class.function_im(c, 1, 2)INSTANCE &lt;__main__.Class object at 0x10c2c43d0&gt;ARGS (1, 2)&gt;&gt;&gt; c.function_cm(1,2)INSTANCE &lt;class &apos;__main__.Class&apos;&gt;ARGS (1, 2)&gt;&gt;&gt; Class.function_cm(1, 2)INSTANCE &lt;class &apos;__main__.Class&apos;&gt;ARGS (1, 2)&gt;&gt;&gt; c.function_sm(1,2)INSTANCE NoneARGS (1, 2)&gt;&gt;&gt; Class.function_sm(1, 2)INSTANCE NoneARGS (1, 2) Are we able to celebrate yet? Unfortunately not.现在万事大吉了？可惜并不是 Multiple levels of binding多层绑定 There is yet another obscure case we have yet to consider, one that I didn’t even think of initially and only understood the problem when I started to see code breaking in crazy ways.还有一个我们还没有考虑到的模糊的例子，一开始我甚至没有想到，只有当我开始看到代码以疯狂的方式崩溃时才会理解这个问题。 This is when we take a reference to a method and reassign it back again as an attribute of a class, or even an instance of a class, and then call it via the alias so created. I only encountered this one due to some bizarre stuff a meta class was doing.这是我们对一个方法的引用，并将其重新分配为类的属性，甚至是类的实例，然后通过创建的别名调用它。我只遇到了这个，因为元类正在做一些奇怪的事情。1234567891011121314151617181920212223&gt;&gt;&gt; Class.function_rm = Class.function_im&gt;&gt;&gt; c.function_rm(1, 2)INSTANCE 1ARGS (2,)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; File &quot;test.py&quot;, line 132, in __call__ return self.wrapper(wrapped, instance, args, kwargs) File &quot;test.py&quot;, line 58, in my_function_wrapper return wrapped(*args, **kwargs)TypeError: unbound method function_im() must be called with Class instance as first argument (got int instance instead)&gt;&gt;&gt; Class.function_rm = Class.function_cm&gt;&gt;&gt; c.function_rm(1, 2)INSTANCE &lt;class &apos;__main__.Class&apos;&gt;ARGS (1, 2)&gt;&gt;&gt; Class.function_rm = Class.function_sm&gt;&gt;&gt; c.function_rm(1, 2)INSTANCE NoneARGS (1, 2) Things work fine for a class method or static method, but fails badly for an instance method.对于类方法或静态方法来说，一切都很好，但是对于实例方法来说却失败了。 The problem here comes about because in accessing the instance method the first time, it will return a bound function wrapper. That then gets assigned back as an attribute of the class.这里的问题是由于在第一次访问实例方法时，它将返回绑定的bound function wrapper对象。然后把它作为类的属性分配回来。 When a subsequent lookup is made via the new name, under normal circumstances binding would occur once more to bind it to the actual instance. In our implementation of the bound function wrapper, we do not however provide a get() method and thus this rebinding does not occur. The result is that on the subsequent call, it all falls apart.当通过新名称进行后续查找时，在正常情况下，绑定将再次发生，以将其绑定到实际实例。在我们的绑定函数包装器的实现中，我们不提供get()方法，因此不会发生这种重新绑定。结果是，在随后的调用中，它全部崩溃。(读者注: Class.function_rm = Class.function_im 设置别名时，发生第一次描述符协议，function_rm 绑定得是 bound_function_wrapper 对象，第二次通过实例调用会发生第一次描述符协议，进行第二次绑定) The solution therefore is that we need to add a get() method to the bound function wrapper which provides the ability to perform further binding. We only want to do this where the instance was None, indicating that the initial binding wasn’t actually against an instance, and where we are dealing with an instance method and not a class method or static method.因此，解决方案是我们需要向 bound_function_wrapper 添加get()方法，它提供了执行进一步绑定的能力。我们只希望在实例为None的地方执行这个操作，这表明我们处理的是实例方法，而不是类方法或静态方法，并且初始绑定实际上并不是针对一个实例 A further wrinkle is that we need to bind what was the original wrapped function and not the bound one. The simplest way of handling that is to pass a reference to the original function wrapper to the bound function wrapper and reach back into that to get the original wrapped function.另一个问题是，我们需要绑定原始包装的函数，而不是被绑定的函数。最简单的处理方法是将对原始函数包装器的引用传递给绑定的函数包装器，并返回到它以获得原始包装函数。(读者注: Class.function_rm = Class.function_im 第一次绑定时，self.binding 为 function，并且由于时通过类直接调用实例方法，因此 instance 参数是 None。包装普通函数时也符合此类情况，但是不会触发描述符协议，只有通过实例调用发生第二次绑定时，才会调用bound_functionwrapper 的\_get__方法) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class bound_function_wrapper(object_proxy): def __init__(self, wrapped, instance, wrapper, binding, parent): super(bound_function_wrapper, self).__init__(wrapped) self.instance = instance self.wrapper = wrapper self.binding = binding self.parent = parent def __call__(self, *args, **kwargs): if self.binding == &apos;function&apos;: if self.instance is None: instance, args = args[0], args[1:] wrapped = functools.partial(self.wrapped, instance) return self.wrapper(wrapped, instance, args, kwargs) else: return self.wrapper(self.wrapped, self.instance, args, kwargs) else: instance = getattr(self.wrapped, &apos;__self__&apos;, None) return self.wrapper(self.wrapped, instance, args, kwargs) def __get__(self, instance, owner): if self.instance is None and self.binding == &apos;function&apos;: descriptor = self.parent.wrapped.__get__(instance, owner) return bound_function_wrapper(descriptor, instance, self.wrapper, self.binding, self.parent) return selfclass function_wrapper(object_proxy): def __init__(self, wrapped, wrapper): super(function_wrapper, self).__init__(wrapped) self.wrapper = wrapper if isinstance(wrapped, classmethod): self.binding = &apos;classmethod&apos; elif isinstance(wrapped, staticmethod): self.binding = &apos;staticmethod&apos; else: self.binding = &apos;function&apos; def __get__(self, instance, owner): wrapped = self.wrapped.__get__(instance, owner) return bound_function_wrapper(wrapped, instance, self.wrapper, self.binding, self) def __call__(self, *args, **kwargs): return self.wrapper(self.wrapped, None, args, kwargs) Rerunning our most recent test once again we now get:在次运行测试得到如下结果1234567891011121314151617&gt;&gt;&gt; Class.function_rm = Class.function_im&gt;&gt;&gt; c.function_rm(1, 2)INSTANCE &lt;__main__.Class object at 0x105609790&gt;ARGS (1, 2)# 不会发生二次绑定&gt;&gt;&gt; Class.function_rm = Class.function_cm&gt;&gt;&gt; c.function_rm(1, 2)INSTANCE &lt;class &apos;__main__.Class&apos;&gt;ARGS (1, 2)# 不会发生二次绑定&gt;&gt;&gt; Class.function_rm = Class.function_sm&gt;&gt;&gt; c.function_rm(1, 2)INSTANCE NoneARGS (1, 2) Order that decorators are applied装饰器应用顺序 We must be getting close now. Everything appears to be working.我们现在该走了。一切似乎都在运转。 If you had been paying close attention you would have noticed though that in all cases so far our decorator has always been placed outside of the existing decorators marking a method as either a class method or a static method. What happens if we reverse the order?如果您一直密切关注，您可能会注意到，目前为止，我们的装饰器一直被放置在将方法标记为类方法或静态方法的装饰器之外。如果我们颠倒顺序会怎样? 1234567891011121314151617181920212223242526272829class Class(object): @classmethod @my_function_wrapper def function_cm(self, a, b): pass @staticmethod @my_function_wrapper def function_sm(a, b): passc = Class()&gt;&gt;&gt; c.function_cm(1,2)INSTANCE NoneARGS (&lt;class &apos;__main__.Class&apos;&gt;, 1, 2)&gt;&gt;&gt; Class.function_cm(1, 2)INSTANCE NoneARGS (&lt;class &apos;__main__.Class&apos;&gt;, 1, 2)&gt;&gt;&gt; c.function_sm(1,2)INSTANCE NoneARGS (1, 2)&gt;&gt;&gt; Class.function_sm(1, 2)INSTANCE NoneARGS (1, 2) So it works as we would expect for a static method but not for a class method.静态方法按预期运行，但是类方法不行 At this point you gotta be thinking why I am bothering.在这一点上，你一定在想我为什么要打扰你。 As it turns out there is indeed absolutely nothing I can do about this one. But that isn’t actually my fault.事实证明，我对此无能为力。但那不是我的错。 In this particular case, it actually can be seen as being a bug in Python itself. Specifically, the classmethod decorator doesn’t itself honour the descriptor protocol when it calls whatever it is wrapping. This is the exact same problem I faulted decorators implemented using a closure for originally. If it wasn’t for the classmethod decorator doing the wrong thing, everything would be perfect.在这个特殊的例子中，它实际上可以被看作是Python本身的一个bug。具体地说，classmethod decorator本身并不能对它包装的所有对象都遵守描述符协议。这也是为什么当使用闭包实现装饰器会发生错误的原因。如果classmethod decorator能正常工作，一起都是OK 的 For those who are interested in the details, you can check out issue 19072 in the Python bug tracker. If I had tried hard I could well have got it fixed by the time Python 3.4 came out, but I simply didn’t have the time nor the real motivation to satisfy all the requirements to get the fix accepted.对于那些对细节感兴趣的人，您可以在Python bug跟踪器中查看19072。如果我已经努力了，我很可能在Python 3.4发布的时候得到了它，但是我没有时间，也没有真正的动机去满足所有的需求，以获得被接受的修复。 Decorating a classExcluding that one case related to ordering of decorators for class methods, our pattern for implementing a universal decorator is looking good.除了与类方法的装饰器排序相关的一个案例之外，我们实现通用装饰器的模式看起来很好。 I did mention though in the last post that the goal was that we could also distinguish when a decorator was applied to a class. So lets check that.我在上一篇文章中提到过，我们的目标是，我们也可以区分什么时候装饰器被应用到一个类中。所以让我们试试1234567@my_function_wrapperclass Class(object): pass&gt;&gt;&gt; c = Class()INSTANCE NoneARGS () Based on that we aren’t able to distinguish it from a normal function or a class method.基于此，我们无法将其与普通函数或类方法区分开来。 If we think about it though, we are in this case wrapping an actual class, so the wrapped object which is passed to the decorator wrapper function will be the class itself. Lets print out the value of the wrapped argument passed to the decorator wrapper function as well and see whether that can be used to distinguish this case from others.如果我们考虑一下，我们在这个例子中包装了一个实际的类，所以传递给decorator包装器函数的包装对象将是类本身。让我们输出传递给用户包装函数的 wrapped参数，看看是否能区分出这种情景1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374@decoratordef my_function_wrapper(wrapped, instance, args, kwargs): print(&apos;WRAPPED&apos;, wrapped) print(&apos;INSTANCE&apos;, instance) print(&apos;ARGS&apos;, args) return wrapped(*args, **kwargs)@my_function_wrapperdef function(a, b): pass&gt;&gt;&gt; function(1, 2)WRAPPED &lt;function function at 0x10e13bb18&gt;INSTANCE NoneARGS (1, 2)class Class(object): @my_function_wrapper def function_im(self, a, b): pass @my_function_wrapper @classmethod def function_cm(self, a, b): pass @my_function_wrapper @staticmethod def function_sm(a, b): passc = Class()&gt;&gt;&gt; c.function_im(1,2)WRAPPED &lt;bound method Class.function_im of &lt;__main__.Class object at 0x107e90950&gt;&gt;INSTANCE &lt;__main__.Class object at 0x107e90950&gt;ARGS (1, 2)&gt;&gt;&gt; Class.function_im(c, 1, 2)WRAPPED &lt;functools.partial object at 0x107df3208&gt;INSTANCE &lt;__main__.Class object at 0x107e90950&gt;ARGS (1, 2)&gt;&gt;&gt; c.function_cm(1,2)WRAPPED &lt;bound method type.function_cm of &lt;class &apos;__main__.Class&apos;&gt;&gt;INSTANCE &lt;class &apos;__main__.Class&apos;&gt;ARGS (1, 2)&gt;&gt;&gt; Class.function_cm(1, 2)WRAPPED &lt;bound method type.function_cm of &lt;class &apos;__main__.Class&apos;&gt;&gt;INSTANCE &lt;class &apos;__main__.Class&apos;&gt;ARGS (1, 2)&gt;&gt;&gt; c.function_sm(1,2)WRAPPED &lt;function function_sm at 0x107e918c0&gt;INSTANCE NoneARGS (1, 2)&gt;&gt;&gt; Class.function_sm(1, 2)WRAPPED &lt;function function_sm at 0x107e918c0&gt;INSTANCE NoneARGS (1, 2)@my_function_wrapperclass Class(object): passc = Class()&gt;&gt;&gt; c = Class()WRAPPED &lt;class &apos;__main__.Class&apos;&gt;INSTANCE NoneARGS () And the answer is yes, as it is the only case where wrapped will be a type object.答案是肯定的，因为它是唯一一个被包装对象是类型对象的情况。 The structure of a universal decoratorThe goal of a decorator, one decorator, that can be implemented and applied to normal functions, instance methods, class methods and classes is therefore achievable. The odd one out is static methods, but in practice these aren’t really different to normal functions, just being contained in a different scope, so I think I will let that one slide.装饰器的目标是，一个装饰器能同时被应用在普通函数，示例方法，类方法以及类上。比较特殊的是静态方法，但是实践中，静态方法与函数并没有本质上的不同，只是它被放在不同的地方。 The information to identify the static method is actually available in the way the decorator works, but since there is nothing in the arguments passed to a static method that link it to the class it is contained in, there doesn’t seem a point. If that information was required, it probably should have been a class method to begin with.在装饰器的执行过程中区分出静态方法是必要的，但是静态方法不会包含任何连接到它所在的类的参数。如果需要，在开始更应该创建一个类方法。 Anyway, after all this work, our universal decorator then would be written as:最后我们的通用装饰器可以被展示如下:12345678910111213141516@decoratordef universal(wrapped, instance, args, kwargs): if instance is None: if inspect.isclass(wrapped): # Decorator was applied to a class. return wrapped(*args, **kwargs) else: # Decorator was applied to a function or staticmethod. return wrapped(*args, **kwargs) else: if inspect.isclass(instance): # Decorator was applied to a classmethod. return wrapped(*args, **kwargs) else: # Decorator was applied to an instancemethod. return wrapped(*args, **kwargs) Are there actual uses for such a universal decorator? I believe there are some quite good examples and I will cover one in particular in a subsequent blog post.这样的通用装饰器有实际用途吗?我相信有一些很好的例子，我将在随后的博客文章中特别提到其中一个。 You also have frameworks such as Django which already use hacks to allow a decorator designed for use with a function, to be applied to an instance method. Turns out that the method they use is broken because it doesn’t honour the descriptor protocol though. If you are interested in that one, see issue 21247 in the Django bug tracker.您也看到过一些框架，比如Django，它已经使用了一些技巧来允许设计用于使用函数的装饰器，并将其应用于实例方法。事实证明，他们使用的方法是不正确的，因为它不遵守描述符协议。如果您对此感兴趣，请参见Django bug跟踪器中的第21247号问题。 I will not cover this example of a use case for a universal decorator just yet. Instead in my next blog post in this series I will look at issues around having decorators that have optional arguments and how to capture any such arguments so the decorator can make use of them.我将不会介绍一个通用装饰器的示例。在本系列的下一篇博客文章中，我将介绍一些具有可选参数的decorator的问题，以及如何捕获任何此类参数，从而使decorator能够使用它们。]]></content>
      <categories>
        <category>函数装饰器</category>
        <category>猴子补订</category>
        <category>wrapt</category>
      </categories>
      <tags>
        <tag>python 标准库</tag>
        <tag>译文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[03 Implementing a factory for creating decorators]]></title>
    <url>%2F2018%2F05%2F12%2Fwrapt%2F03-implementing-a-factory-for-creating-decorators%2F</url>
    <content type="text"><![CDATA[本系列 blog 与 python wrat 模块相关，深入介绍了 Python 装饰器，猴子补订等相关内容，翻译于 https://github.com/GrahamDumpleton/wrapt/tree/master/blog 本篇内容: 使用代理对象和工厂函数创建装饰器 Implementing a factory for creating decoratorsThis is the third post in my series of blog posts about Python decorators and how I believe they are generally poorly implemented. It follows on from the previous post titled The interaction between decorators and descriptors, with the very first post in the series being How you implemented your Python decorator is wrong.这是Python 装饰器系列博客中的第二篇。 In the very first post I described a number of ways in which the traditional way that Python decorators are implemented is lacking. These were:在第一篇文章中，我描述了一些 Python decorator 传统实现方式存在的缺陷: Preservation of function __name__ and __doc__.(无法保留函数的自省属性) Preservation of function argument specification.(无法获取函数签名信息) Preservation of ability to get function source code.(无法获取函数源代码) Ability to apply decorators on top of other decorators that are implemented as descriptors.(无法将装饰器应用于另一个为实现描述符的装饰器之上) In the followup post I described a pattern for implementing a decorator which built on top of what is called an object proxy, with the object proxy solving the first three issues. The final issue was dealt with by creating a function wrapper using the object proxy, which was implemented as a descriptor, and which performed object binding when a wrapper was used on class methods. This combination of the object proxy and a descriptor ensured that introspection continued to work properly and that the execution model of the Python object model was also respected.在接下来的博客中，我将描述一种基于对象代理创建装饰器的模式，使用代理对象将解决前三个问题。将使用代理对象的装饰器实现为一个描述符将解决最后一个问题，当包装器被用于类方法时，它将执行对象绑定。对象代理和描述符的这种组合确保了内省继续正常工作，并确保Python对象模型的执行模型也得到了维护。 The issue at this point was how to make the solution more usable, eliminating the boiler plate and minimising the amount of code that someone implementing a decorator would need to write.现在的问题是如何使解决方案更有用，消除了样本代码，并最小化了执行装饰器的人需要编写的代码量。 In this post I will describe one such approach to simplifying the task of creating a decorator based on this pattern. This will be done by using a decorator as a factory to create decorators, requiring a user to only have to supply a single wrapper function which does the actual work of invoking the wrapped function, inserting any extra work that the specific decorator is intended to carry out as necessary.在本文中，我将描述一种方法，以简化创建decorator的任务。通过使用装饰工厂函数,用户只需提供一个执行实际工作的包装函数，按需插入执行所需功能的代码即可 Pattern for implementing the decoratorJust to refresh where we got to last time, we had an implementation of an object proxy as:如前所述，我们有一个代理对象的实现，如下123456789101112131415class object_proxy(object): def __init__(self, wrapped): self.wrapped = wrapped try: self.__name__= wrapped.__name__ except AttributeError: pass @property def __class__(self): return self.wrapped.__class__ def __getattr__(self, name): return getattr(self.wrapped, name) As pointed out the last time, this is a minimal representation of what it does. In practice it actually needs to do a lot more than this if it is to serve as a general purpose object proxy usable in the more generic use case of monkey patching.正如最后一次指出的那样，这是对它所做事情的最小表示。实际上，如果它是一个通用的对象代理，可以在猴子补丁的更通用的用例中使用，实际上它需要做更多的工作。 The decorator itself would then be implemented per the pattern:描述符本身将按照如下模式实现12345678910111213141516171819class bound_function_wrapper(object_proxy): def __init__(self, wrapped): super(bound_function_wrapper, self).__init__(wrapped) def __call__(self, *args, **kwargs): return self.wrapped(*args, **kwargs)class function_wrapper(object_proxy): def __init__(self, wrapped): super(function_wrapper, self).__init__(wrapped) def __get__(self, instance, owner): wrapped = self.wrapped.__get__(instance, owner) return bound_function_wrapper(wrapped) def __call__(self, *args, **kwargs): return self.wrapped(*args, **kwargs) When the wrapper is applied to a normal function, the __call__() method of the wrapper is used. If the wrapper is applied to a method of a class, the __get__() method is called when the attribute is accessed, which returns a new bound wrapper and the __call__() method of that is invoked instead when a call is made. This allows our wrapper to be used around descriptors as it propagates the descriptor protocol, also binding the wrapped object as necessary.当将包装器应用于一个正常的函数时，将使用包装器的 __call__()方法。如果将包装器应用于类的方法，则在属性访问时调用__get__()方法，返回一个新的绑定包装器，并在被调用时使用新绑定包装器的__call__()方法。这使得我们的包装器能用作描述符来传递描述符协议，以根据需要对包装的对象进行绑定。 A decorator for creating decoratorsSo we have a pattern for implementing a decorator that appears to work correctly, but as already mentioned, needing to do all that each time is more work than we really want. What we can do therefore is create a decorator to help us create decorators. This would reduce the code we need to write for each decorator to a single function, allowing us to simplify the code to just:因此，我们有一个模式来实现一个看起来正常工作的decorator，但是正如前面提到的，每次都需要做的事情比我们真正想要的要多。因此，我们可以做的是创建一个decorator来帮助我们创建decorator。这将减少我们为每个decorator编写单个函数所需的代码，从而简化了代码:1234567@decoratordef my_function_wrapper(wrapped, args, kwargs): return wrapped(*args, **kwargs)@my_function_wrapperdef function(): pass What would this decorator factory need to look like?这个装饰器工厂函数应该怎么实现呢？ As it turns out, our decorator factory is quite simple and isn’t really much different to using a partial(), combining our new wrapper argument from when the decorator is defined, with the wrapped function when the decorator is used and passing them into our function wrapper object.就像表现的一样，我们的装饰器工厂函数是非常简单的，与partial()函数并没有很大不同，在装饰器定义时接收装饰函数，在装饰器应用时接收被包装函数，并将他们传递到function wrapper对象中12345def decorator(wrapper): @functools.wraps(wrapper) def _decorator(wrapped): return function_wrapper(wrapped, wrapper) return _decorator We now just need to amend our function wrapper implementation to delegate the actual execution of the wrapped object to the user supplied decorator wrapper function.我们现在只需要修改我们的函数包装器实现，将包装对象的实际执行委托给用户提供的装饰器包装器函数。123456789101112131415161718192021class bound_function_wrapper(object_proxy): def __init__(self, wrapped, wrapper): super(bound_function_wrapper, self).__init__(wrapped) self.wrapper = wrapper def __call__(self, *args, **kwargs): return self.wrapper(self.wrapped, args, kwargs)class function_wrapper(object_proxy): def __init__(self, wrapped, wrapper): super(function_wrapper, self).__init__(wrapped) self.wrapper = wrapper def __get__(self, instance, owner): wrapped = self.wrapped.__get__(instance, owner) return bound_function_wrapper(wrapped, self.wrapper) def __call__(self, *args, **kwargs): return self.wrapper(self.wrapped, args, kwargs) The __call__() method of our function wrapper, for when it is used around a normal function, now just calls the user supplied decorator wrapper function with the wrapped function and arguments, leaving the calling of the wrapped function up to the user supplied decorator wrapper function.function wrapper 的__call__ 方法,作为一个正常函数调用时，仅仅使用被包装函数和参数调用用户提供的包装函数。将被包装函数的调用留给用户的包装函数来调用 In the case where binding a function, the wrapper is also passed to the bound wrapper. The bound wrapper is more or less the same, with the __call__() method delegating to the user supplied decorator wrapper function.在绑定函数的情况下，包装器也传递给 bound wrapper对象。bound wrapper或多或少是相同的，使用__call__()方法将其委托给用户提供的包装器函数。 So we can make creating decorators easier using a factory. Lets now check that this will in fact work in all cases in which it could be applied and also see what other problems we can find and whether we can improve on those situations as well.因此，我们可以使用工厂来简化创建decorator的过程。现在让我们来检查一下，在所有的情况下，这将在实际工作中发挥作用，并且看看我们还能找到什么其他的问题，以及我们是否能在这些情况下改进。 Decorating methods of classesThe first such area which can cause problems is creating a single decorator that can work on both normal functions and instance methods of classes.第一个可能导致问题的领域是创建一个单独的decorator，它可以同时处理类的正常函数和实例方法。 To test out how our new decorator works, we can print out the args passed to the wrapper when the wrapped function is called and can compare the results.为了测试我们的新decorator是如何工作的，我们可以在调用包装函数时打印传递给包装器的args，并可以比较结果。1234@decoratordef my_function_wrapper(wrapped, args, kwargs): print(&apos;ARGS&apos;, args) return wrapped(*args, **kwargs) First up lets try wrapping a normal function:首先让我们尝试包装一个普通函数: 123456@my_function_wrapperdef function(a, b): pass&gt;&gt;&gt; function(1, 2)ARGS (1, 2) As would be expected, just the two arguments passed when the function is called are output.正如所期望的那样，在函数被调用时，只有两个参数被输出 What about when wrapping an instance method?包装一个实例方法会如何？ 123456789class Class(object): @my_function_wrapper def function_im(self, a, b): passc = Class()&gt;&gt;&gt; c.function_im()ARGS (1, 2) Once again just the two arguments passed when the instance method is called are displayed. How the decorator works for both the normal function and the instance method is therefore the same.同样，当调用实例方法时传入的两个参数被输出。因此，装饰器对正常函数和实例方法的工作方式是相同的。 The problem here is what if the user within their decorator wrapper function wanted to know what the actual instance of the class was. We have lost that information when the function was bound to the instance of the class as it is now associated with the bound function passed in, rather than the argument list.这里的问题是，用户如何在他们的decorator包装器函数中获取类的实例。当函数被绑定到类的实例时，我们丢失了这个信息，因为类实例现在与传入的绑定函数关联，而不是参数列表。 To solve this problem we can remember what the instance was that was passed to the __get__() method when it was called to bind the function. This can then be passed through to the bound wrapper when it is created.要解决这个问题，我们可以记住在调用绑定函数时传递给__get__()方法的实例是什么。在 bound wrapper被创建，作为参数传递给bound wrapper。 12345678910111213141516171819202122class bound_function_wrapper(object_proxy): def __init__(self, wrapped, instance, wrapper): super(bound_function_wrapper, self).__init__(wrapped) self.instance = instance self.wrapper = wrapper def __call__(self, *args, **kwargs): return self.wrapper(self.wrapped, self.instance, args, kwargs)class function_wrapper(object_proxy): def __init__(self, wrapped, wrapper): super(function_wrapper, self).__init__(wrapped) self.wrapper = wrapper def __get__(self, instance, owner): wrapped = self.wrapped.__get__( instance, owner) return bound_function_wrapper(wrapped, instance, self.wrapper) def __call__(self, *args, **kwargs): return self.wrapper(self.wrapped, None, args, kwargs) In the bound wrapper, the instance pointer can then be passed through to the decorator wrapper function as an extra argument. To be uniform for the case of a normal function, in the top level wrapper we pass None for this new instance argument.在bound wrapper中，类实例作为额外的参数传给用户创建的包装函数。对于普通函数，在顶级包装器中，对于这个新的实例参数，我们没有传递任何内容We can now modify our wrapper function for the decorator to output both the instance and the arguments passed.现在，我们可以修用户的包装函数，以输出实例和传递的参数。 12345678910111213@decoratordef my_function_wrapper(wrapped, instance, args, kwargs): print(&apos;INSTANCE&apos;, instance) print(&apos;ARGS&apos;, args) return wrapped(*args, **kwargs)&gt;&gt;&gt; function(1, 2)INSTANCE NoneARGS (1, 2)&gt;&gt;&gt; c.function_im(1, 2)INSTANCE &lt;__main__.Class object at 0x1085ca9d0&gt;ARGS (1, 2) This change therefore allows us to be able to distinguish between a normal function call and an instance method call within the one decorator wrapper function. The reference to the instance is even passed separately so we don’t have to juggle with the arguments to move it out of the way for an instance method when calling the original wrapped function.因此，这种变化能让我们在包装器函数中区分出一个普通函数调用和一个的实例方法调用。对实例的引用甚至是单独传递的，在调用原始被包装函数时，我们不必为一个实例方法去判断并移除额外的类实例参数(读者注: 对于类，原始的被包装函数已经是绑定对象，所以不能在传入类实例对象) Now there is one final scenario in which an instance method can be called which we still need to check. This is calling an instance method by calling the function on the class and passing the object instance explicitly as the first argument.最后一种调用实例方法的情况，我们仍然需要检查它。即通过类并显示传递类实例的方式调用实例方法。123&gt;&gt;&gt; Class.function_im(c, 1, 2)INSTANCE NoneARGS (&lt;__main__.Class object at 0x1085ca9d0&gt;, 1, 2) Unfortunately passing in the instance explicitly as an argument against the function from the class, results in the instance passed to the decorator wrapper function being None, with the reference to the instance getting passed through as the first argument instead. This isn’t really a desirable outcome.不幸的是，将实例显式地传递给类中的函数作为参数时，类实例没有通过 instance 传递给包装函数，而是作为 arg 的第一个参数被传递。这并不是一个理想的结果 To deal with this variation, we can check for instance being None before calling the decorator wrapper function and pop the instance off the start of the argument list. We then use a partial to bind the instance to the wrapped function ourselves and call the decorator wrapper function.为了处理这种变化，我们可以在调用decorator包装器函数之前检查实例，并从参数列表的开头弹出实例。然后使用 partcial 函数将实例绑定到被包装函数上，并调用用户的包装器函数。(读者注:看下面的代码更清晰)12345678910111213class bound_function_wrapper(object_proxy): def __call__(self, *args, **kwargs): if self.instance is None: instance, args = args[0], args[1:] wrapped = functools.partial(self.wrapped, instance) return self.wrapper(wrapped, instance, args, kwargs) return self.wrapper(self.wrapped, self.instance, args, kwargs)We then get the same result no matter whether the instance method is called via the class or not.&gt;&gt;&gt; Class.function_im(c, 1, 2)INSTANCE &lt;__main__.Class object at 0x1085ca9d0&gt;ARGS (1, 2) So everything works okay for instance methods, with the argument list seen by the decorator wrapper function being the same as if a normal function had been wrapped. At the same time though, by virtue of the new instance argument, we can if need be act on the instance of a class where the decorator was applied to an instance method of a class.对于实例方法，一切都可以正常执行，被包装函数无论是实例方法和还是普通函数接收参数完全相同。得益与 instance 参数，在将装饰器应用于实例方法时，我们可以按需调用类方法 What about other method types that a class can have, specifically class method and static methods.对于类可以拥有的其他方法类型，特别是类方法和静态方法会怎样。12345678910class Class(object): @my_function_wrapper @classmethod def function_cm(cls, a, b): pass&gt;&gt;&gt; Class.function_cm(1, 2)INSTANCE 1ARGS (2,) As can be seen, this fiddle has though upset things for when we have a class method, also causing the same issue for a static method. In both those cases the instance would initially have been passed as None when the function was bound. The result is that the real first argument ends up as the instance, which is obviously going to be quite wrong.正如所看见得，装饰器对类方法和静态方法有非常严重得问题。这两种情况下，在函数被绑定时，instance 参数将为空。arg 中第一个位置参数包含了，本应该由 instance 传递的参数。这显然是不正确的。 What to do?应该怎么做 A universal decoratorSo we aren’t quite there yet, but what are we trying to achieve in even trying to do this? What was wrong with our initial pattern for the decorator?所以我们并没有完成一个通用的装饰器，但我们到底想要达到什么目的呢?我们最初的装饰模式有什么问题? The ultimate goal here is what I call a universal decorator. A single decorator that can be applied to a normal function, an instance method, a class method, a static method or even a class, with the decorator being able to determine at the point it was called the context in which it was used.这里的终极目标是我所说的“宇宙装饰者”。一个可以应用于普通函数、实例方法、类方法、静态方法甚至是类的修饰符，修饰符能够在指定的时候确定它被使用的上下文。 Right now with the way that decorators are normally implemented this is not possible. Instead different decorators are provided to be used in the different contexts, meaning duplication of the code into each, or the use of hacks to try and convert decorators created for one purpose so they can be used in a different context.目前为止，实现装饰器的所有方法想达到上述目标是不可能了。只能通过复制代码，或者通过某种技巧转换装饰器，以便装饰器能在不同的上下文中使用 What I am instead aiming for is the ability to do:我的目标是能实现如下功能123456789101112@decoratordef universal(wrapped, instance, args, kwargs): if instance is None: if inspect.isclass(wrapped): # class. else: # function or staticmethod. else: if inspect.isclass(instance): # classmethod. else: # instancemethod. At this point we have got things working for normal functions and instance methods, we just now need to work out how to handle class methods, static methods and the scenario where a decorator is applied to a class.本文中，我们已经实现了让装饰器在普通函数和实例方法上正确执行，我们现在需要了解如何处理类方法、静态方法以及将decorator应用于类的场景。 The next post in this series will continue to pursue this goal and describe how our decorator can be tweaked further to get there.本系列的下一篇文章将继续追求这个目标，并描述如何进一步调整我们的decorator。]]></content>
      <categories>
        <category>函数装饰器</category>
        <category>猴子补订</category>
        <category>wrapt</category>
      </categories>
      <tags>
        <tag>python 标准库</tag>
        <tag>译文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[02 The interaction between decorators and descriptors]]></title>
    <url>%2F2018%2F05%2F08%2Fwrapt%2F02-the-interaction-between-decorators-and-descriptors%2F</url>
    <content type="text"><![CDATA[本系列 blog 与 python wrat 模块相关，深入介绍了 Python 装饰器，猴子补订等相关内容，翻译于 https://github.com/GrahamDumpleton/wrapt/tree/master/blog 本篇内容: Python 装饰器与描述符协议 The interaction between decorators and descriptorsThis is the second post in my series of blog posts about Python decorators and how I believe they are generally poorly implemented. It follows on from the first post titled How you implemented your Python decorator is wrong这是Python 装饰器系列博客中的第二篇 In that first post I described a number of ways in which the traditional way that Python decorators are implemented is lacking. These were:在第一篇文章中，我描述了一些 Python decorator 传统实现方式存在的缺陷: Preservation of function __name__ and __doc__.(无法保留函数的自省属性) Preservation of function argument specification.(无法获取函数签名信息) Preservation of ability to get function source code.(无法获取函数源代码) Ability to apply decorators on top of other decorators that are implemented as descriptors.(无法将装饰器应用于另一个为实现描述符的装饰器之上)I described previously how functools.wraps() attempts to solve the problem with preservation of the introspection of the name and doc attributes, but highlight one case in Python 2 where it can fail, and also note that it doesn’t help with the preservation of the function argument specification nor the ability to access the source code.我说过 functools.wraps()可以帮助解决 name, doc 自省属性问题，但是在Python2的某种情况下，它会调用失败，并且它不能解决无法获取函数签名信息以及无法自省源代码问题 In this post I want to focus mainly on the last of the issues above. That is the interaction between decorators and descriptors, where a function wrapper is applied to a Python object which is actually a descriptor.在本文中，我将着眼于之前阐述的最后一个问题。如何在描述符，和装饰器之间进行交互，即将装饰器应用到一个描述符上 What are descriptors?I am not going to give an exhaustive analysis of what descriptors are or how they work so if you want to understand them in depth, I would suggest reading up about them elsewhere.我不打算详细解释描述符是什么以及他们的工作原理，如果你想深入了解他们，我建议你去别处找找看 In short though, a descriptor is an object attribute with binding behaviour, one whose attribute access has been overridden by methods in the descriptor protocol. Those methods are get(), set(), and delete(). If any of those methods are defined for an object, it is said to be a descriptor.简而言之，描述符就是存在绑定行文的对象，即属性访问会描述符协议实现的方法所覆盖。这些方法是 get(), set(), 和 delete()。如果任意一中方法在一个对象中被定义，就可以说该对象是一个描述符 123obj.attribute attribute.__get_(obj.type(obj))obj.attribute = value attribute.__set_(obj, value)del obj.attribute attribute.__delete_(obj, value) What this means is that if an attribute of a class has any of these special methods defined, when the corresponding operation is performed on that attribute of a class, then those methods will be called instead of the default action. This allows an attribute to override how those operations are going to work.上述描述的是，如果一个类的属性包含上述任意一中特殊方法，当相应操作在类属性被执行时，这些特殊方法将取代默认方法被调用。这就允许一个属性去覆盖将发生默认操作 You may well be thinking that you have never made use of descriptors, but fact is that function objects are actually descriptors. When a function is originally added to a class definition it is as a normal function. When you access that function using a dotted attribute path, you are invoking the get() method to bind the function to the class instance, turning it into a bound method of that object.也许你以为你从未使用过描述符，事实上，函数对象就是描述符。当在类中定义函数时，函数就是普通的函数。当你通过’.’属性访问函数时，你将调用函数的 get()方法，将函数与一个类实例绑定，进而返回一个绑定方法对象 123456789101112def f(obj): pass&gt;&gt;&gt; hasattr(f, &apos;__get__&apos;)True&gt;&gt;&gt; f&lt;function f at 0x10e963cf8&gt;&gt;&gt;&gt; obj = object()&gt;&gt;&gt; f.__get__(obj, type(obj))&lt;bound method object.f of &lt;object object at 0x10e8ac0b0&gt;&gt; So when calling a method of a class, it is not the call() method of the original function object that is called, but the call() method of the temporary bound object that is created as a result of accessing the function.所以当你调用类方式时，并不是原始函数的 call() 方法被调用，而是访问函数时临时创建的绑定方法对象的call()方法被调用 You of course don’t usually see all these intermediary steps and just see the outcome.当然，你通常不会看到所有这些中间步骤，只看到结果。* 1234567&gt;&gt;&gt; class Object(object):... def f(self): pass&gt;&gt;&gt; obj = Object()&gt;&gt;&gt; obj.f&lt;bound method Object.f of &lt;__main__.Object object at 0x10abf29d0&gt;&gt; Looking back now at the example given in the first blog post where we wrapped a decorator around a class method, we encountered the error:现在回想一下在第一个博客文章中给出的例子，当我们对一个类方法应用了装饰器时，我们遇到了如下错误:12345678910111213class Class(object): @function_wrapper @classmethod def cmethod(cls): pass&gt;&gt;&gt; Class.cmethod()Traceback (most recent call last): File &quot;classmethod.py&quot;, line 15, in &lt;module&gt; Class.cmethod() File &quot;classmethod.py&quot;, line 6, in _wrapper return wrapped(*args, **kwargs)TypeError: &apos;classmethod&apos; object is not callable The problem with this example was that for the @classmethod decorator to work correctly, it is dependent on the descriptor protocol being applied properly. This is because the call() method only exists on the result returned by get() when it is called, there is no call() method on the @classmethod decorator itself.示例中的问题在于，@classmethod 描述符对象并没有正确工作，它依赖于描述符协议被正确执行。因为call()方法仅存在于get()被调用时返回的结果中，而@classmethod描述符本身并没有 call()方法 More specifically, the simple type of decorator that people normally use is not itself honouring the descriptor protocol and applying that to the wrapped object to yield the bound function object which should actually be called. Instead it is simply calling the wrapped object directly, which will fail if it doesn’t have a call().更具体的说， 人们使用的简单装饰器，并没有对被包装的描述符对象执行描述符协议以产生的一个可调用对象。想反，只是简单的直接调用被包装对象。因为其没有 call() 方法，结果当然会失败 Why then does applying a decorator to a normal instance method still work?那为什么将装饰器应用在普通的实例方法上仍然可以运行呢？ This still works because a normal function still has a call() method. In bypassing the descriptor protocol of the wrapped function it is calling this. Although the binding protocol is side stepped, things still work out because the wrapper will pass the ‘self’ argument for the instance explicitly as the first argument when calling the original unbound function object.它仍能工作是因为，一个普通函数本身具有call()方法。在绕过包装函数的描述符协议时，它调用的是此方法。尽管绑定步骤被跳过，仍能正常工作是因为包装器函数将 self 包含的实例对象通过第一参数显示传递给了原始的未绑定函数对象 For a normal instance method the result in this situation is effectively the same. It only falls apart when the wrapped object, as in the case of @classmethod, are dependent on the descriptor protocol being applied correctly.对于一个普通的实例方法，这种情况下的结果实际上是相同的。只有当被包装的对象(如@classmethod)依赖于正确应用的描述符协议时，它才会崩溃。 Wrappers as descriptorsThe way to solve this problem where the wrapper is not honouring the descriptor protocol and performing binding on the wrapped object in the case of a method on a class, is for wrappers to also be descriptors.解决包装器不能在类方法执行描述符协议获取绑定对象的方法是，让包装器也成为一个描述符对象1234567891011121314class bound_function_wrapper(object): def __init__(self, wrapped): self.wrapped = wrapped def __call__(self, *args, **kwargs): return self.wrapped(*args, **kwargs)class function_wrapper(object): def __init__(self, wrapped): self.wrapped = wrapped def __get__(self, instance, owner): wrapped = self.wrapped.__get__(instance, owner) return bound_function_wrapper(wrapped) def __call__(self, *args, **kwargs): return self.wrapped(*args, **kwargs) If the wrapper is applied to a normal function, the call() method of the wrapper is used. If the wrapper is applied to a method of a class, the get() method is called, which returns a new bound wrapper and the call() method of that is invoked instead. This allows our wrapper to be used around descriptors as it propagates the descriptor protocol.如果将包装器应用于一个正常的函数，则使用包装器的call()方法。如果将包装器应用于类的方法，则调用get()方法，该方法返回一个新的绑定包装器，并调用该方法的call()方法。这样我们的包装器就可以在描述符的传播过程中使用。 So since using a function closure will ultimately fail if used around a decorator which is implemented as a descriptor, the situation we therefore have is that if we want everything to work, then decorators should always use a class based wrapper, where the class implements the descriptor protocol as shown.因为将装饰器实现为一个描述符对象时，使用闭包总是会失败，因此这种情况下为了让所有的事都能正常工作，我们必需总是使用类实现装饰器。装饰器类将实现描述符协议，如上所式 The question now is how do we address the other issues that were listed.现在的问题是，我们如何解决我们列出的其他问题 We solved naming using functools.wrap()/functools.update_wrapper() before, but what do they do and can we still use them.我们使用functools.wrap()/functools.update_wrapper()解决命名问题，现在我们应该怎么做以便继续使用他们 Well wraps() just uses update_wrapper(), so we just need to look at it.因为 wraps() 内部使用 update_wrapper(),所以我们只需要看看它如何实现 12345678910111213141516171819WRAPPER_ASSIGNMENTS = (&apos;__module__&apos;, &apos;__name__&apos;, &apos;__qualname__&apos;, &apos;__doc__&apos;, &apos;__annotations__&apos;)WRAPPER_UPDATES = (&apos;__dict__&apos;,)def update_wrapper(wrapper, wrapped, assigned = WRAPPER_ASSIGNMENTS, updated = WRAPPER_UPDATES): wrapper.__wrapped__ = wrapped for attr in assigned: try: value = getattr(wrapped, attr) except AttributeError: pass else: setattr(wrapper, attr, value) for attr in updated: getattr(wrapper, attr).update( getattr(wrapped, attr, &#123;&#125;)) What is shown here is what is in Python 3.3, although that actually has a bug in it, which is fixed in Python 3.4. :-)如上展示的是Python3.3中的代码，事实上它还存在一个bug，在Python3.4中已经修复 Looking at the body of the function, three things are being done. First off a reference to the wrapped function is saved as wrapped. This is the bug, as it should be done last.在函数体中，3件事需要被做。第一件是将被包装函数保存为包装函数的wrapped属性。这就是那个bug，因为它应该在最后实现 The second is to copy those attributes such as name and doc.第二步，复制诸如name 和 doc属性 Finally the third thing is to copy the contents of dict from the wrapped function into the wrapper, which could actually result in quite a lot of objects needing to be copied.最后一步，复制被包装函数dict属性值到包装函数，结果是很多对象需要被复制 If we are using a function closure or straight class wrapper this copying is able to be done at the point that the decorator is applied.如果我们使用的是一个函数闭包或直接的类包装器，那么这个复制就可以在decorator应用的时候完成。 With the wrapper being a descriptor though, it technically now also needs to be done in the bound wrapper.当装饰器被实现为描述符时，也需要在 bound wrapper 中完成上述工作123456789class bound_function_wrapper(object): def __init__(self, wrapped): self.wrapped = wrapped functools.update_wrapper(self, wrapped)class function_wrapper(object): def __init__(self, wrapped): self.wrapped = wrapped functools.update_wrapper(self, wrapped) As the bound wrapper is created every time the wrapper is called for a function bound to a class, this is going to be too slow. We need a more performant way of handling this.因为bound wrapper 在包装器每次被作为类的绑定方法调用时都会被创建，所有将非常慢。我们需要更高效的方式处理它 Transparent object proxyThe solution to the performance issue is to use what is called an object proxy. This is a special wrapper class which looks and behaves like what it wraps.性能问题的解决方法是，使用代理对象。这是一个特殊的包装类，因为它的行为跟它包装的东西看起来很像 123456789101112131415class object_proxy(object): def __init__(self, wrapped): self.wrapped = wrapped try: self.__name__= wrapped.__name__ except AttributeError: pass @property def __class__(self): return self.wrapped.__class__ def __getattr__(self, name): return getattr(self.wrapped, name) A fully transparent object proxy is a complicated beast in its own right, so I am going to gloss over the details for the moment and cover it in a separate blog post at some point.一个完全透明的对象代理本身就是一个复杂的怪物，所以我打算暂时把细节掩盖起来，并在一个单独的博客文章中讨论它。 The above example though is a minimal representation of what it does. In practice it actually needs to do a lot more than this though if it is to serve as a general purpose object proxy usable in the more generic use case of monkey patching.上面的例子是它所做事情的最小表示。实际上，它实际上需要做更多的工作，但如果它是一个通用的对象代理，可以在更通用的monkey patching用例中使用。 In short though, it copies limited attributes from the wrapped object to itself, and otherwise uses special methods, properties and getattr() to fetch attributes from the wrapped object only when required thereby avoiding the need to copy across lots of attributes which may never actually be accessed.简而言之，它将有限的属性从包装的对象复制到自身，并使用特殊的方法、属性和getattr()来从包装对象中获取属性，从而避免需要复制许多可能永远不会被访问的属性。 What we now do is derive our wrapper class from the object proxy and do away with calling update_wrapper().我们现在要做的是从对象代理中派生出包装器类，并取消调用update_wrapper()。 12345678910111213141516171819class bound_function_wrapper(object_proxy): def __init__(self, wrapped): super(bound_function_wrapper, self).__init__(wrapped) def __call__(self, *args, **kwargs): return self.wrapped(*args, **kwargs) class function_wrapper(object_proxy): def __init__(self, wrapped): super(function_wrapper, self).__init__(wrapped) def __get__(self, instance, owner): wrapped = self.wrapped.__get__(instance, owner) return bound_function_wrapper(wrapped) def __call__(self, *args, **kwargs): return self.wrapped(*args, **kwargs) In doing this, attributes like name and doc, when queried from the wrapper, return the values from the wrapped function. We don’t therefore as a result have the problem we did before where details were being returned from the wrapper instead.在这样做的时候，当从包装器中查询像name和doc这样的属性时，将从被包装函数返回值。因而不会像之前，我们从包装函数返回值而产生问题 Using a transparent object proxy in this way also means that calls like inspect.getargspec() and inspect.getsource() will now work and return what we expect. So we have actually managed to solve those two problems at the same time without any extra effort, which is a bonus.用这种方式使用透明的对象代理也意味着像检查。getargspec()和inspection .getsource()这样的调用将工作并返回我们所期望的。所以我们实际上在没有任何额外努力的情况下同时解决了这两个问题，这是一个额外的好处。 Making this all more usableAlthough this pattern addresses the problems which were originally identified, it consists of a lot of boiler plate code. Further, you now have two places in the code where the wrapped function is actually being called where you would need to insert the code to implement what the decorator was intended to do.尽管这种模式解决了最初确定的问题，但它包含了大量的重复样板代码。此外，在现在的代码中有两个位置，调用被包装函数。因而需要在两个地方重复实现包装逻辑 Replicating this every time you need to implement a decorator would therefore be a bit of a pain.因此，每次需要实现一个装饰器时都要复制这一点，因此会有点痛苦。 What we can instead do is wrap this all up and package it up into a decorator factory, thereby avoiding the need for this all to be done manually each time. How to do that will be the subject of the next blog post in this series.我们可以做的是将其打包并打包到一个装饰器工厂函数中，从而避免每次都需要手工完成这一切。如何做到这一点将成为本系列下一篇博客文章的主题。 From that point we can start to look at how we can further improve the functionality and introduce new capabilities which are generally hard to pull off with the way that decorators are normally implemented.从这一点开始，我们可以开始研究如何进一步改进功能，并引入新的功能，这些都是使用常规的装饰器实现方法难以实现的 And before people start to complain that using this pattern is going to be too slow in the general use case, I will also address that in a future post as well, so just hold your complaints for now.在人们开始抱怨使用这个模式在一般用例中会太慢的时候，我也会在以后的文章中提到这一点，所以现在就暂时不要抱怨了。]]></content>
      <categories>
        <category>函数装饰器</category>
        <category>猴子补订</category>
        <category>wrapt</category>
      </categories>
      <tags>
        <tag>python 标准库</tag>
        <tag>译文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01 How you implemented your Python decorator is wrong]]></title>
    <url>%2F2018%2F05%2F04%2Fwrapt%2F01-how-you-implemented-your-python-decorator-is-wrong%2F</url>
    <content type="text"><![CDATA[本系列 blog 与 python wrat 模块相关，深入介绍了 Python 装饰器，猴子补订等相关内容，翻译于 https://github.com/GrahamDumpleton/wrapt/tree/master/blog 本篇内容: Python 装饰器语法，通过闭包实现装饰器存在的问题内容摘要: 使用常规的函数闭包，类实现装饰器，无法保留函数自省信息 使用 functools.wraps() 和 functools.update_wrapper() 能保留常规的自省属性，但是存在以下问题 无法保留函数签名信息 由于 Python2 的bug，无法将装饰器直接应用于类方法和静态方法(导入时即报错)** Python3 中即便修复了Python2 中的bug，但是由于\@classmethod 返回一个描述符，而非一个直接可调用对象，将装饰器应用于类方法时依旧会报错(导入时正常，运行时异常)** How you implemented your Python decorator is wrongThe rest of the Python community is currently doing lots of navel gazing over the issue of Python 3 adoption and the whole unicode/bytes divide. I am so over that and gave up caring when my will to work on WSGI stuff was leached away by how long it took to get the WSGI specification updated for Python 3.(Python 社区当前的精力集中于 Python3，由于WSGI相关原因，我并没有对此过多的关注) Instead my current favourite gripe these days is about how people implement Python decorators. Unfortunately, it appears to be a favourite topic for blogging by Python developers. It is like how when WSGI was all the rage and everyone wanted to write their own WSGI server or framework. Now it is like a rite of passage that one must blog about how to implement Python decorators as a way of showing that you understand Python. As such, I get lots of opportunity to grumble and wince. If only they did truly understand what they were describing and what problems exist with the approach they use.(相反，我对于人们怎么使用 Python 装饰器很感兴趣。就像当初 WSGI 大火的时候一样，Python 装饰器成为了众多博客的经典话题。很多人通过 Python 装饰器展现 他们对 Python 的理解。然而很遗憾的是，按照他们所说的使用装饰器的方式存在众多问题) So what is my gripe then. My gripe is that although one can write a very simple decorator using a function closure, the scope it can be used in is usually limited. The most basic pattern for implementing a Python decorator also breaks various stuff related to introspection.（尽管可以简单通过闭包实现一个装饰器，但是这种方式存在很多局限，这种最单的使用方式也打断了 Python 内部的自省） Now most people will say who cares, it does the job I want to do and I don’t have time to care whether it is correct in all situations.(大多数人可能会说谁关心呢，只要它按照我预期的方式在工作，我可没有时间关心，它是否在所有情形下都能正常工作) As people will know from when I did care more about WSGI, I am a pedantic arse though and when one does something, I like to see it done correctly.(我是一个学究式的人，当一个人做某事时，我喜欢看它做的正确) Besides my overly obsessive personal trait, it actually does also affect me in my day job as well. This is because I write tools which are dependent upon being able to introspect into code and I need the results I get back to be correct. If they aren’t, then the data I generate becomes useless as information can get grouped against the wrong thing.(除了我个人比较执着外，通过闭包创建装饰器的方式的确影响到了我的工作。因为我编写的工具依赖于能够对代码进行内省) As well as using introspection, I also do lots of evil stuff with monkey patching. As it happens, monkey patching and the function wrappers one applies aren’t much different to decorators, it is just how they get applied which is different. Because though monkey patching entails going in and modifying other peoples code when they were not expecting it, or designing for it, means that when you do go in and wrap a function that how you do it is very important. If you do not do it correctly then you can crash the users application or inadvertently change how it runs.(除了使用内省，我还使用monkey patching(猴子打补丁)。碰巧的是，monkey patching 和通过函数包装一个应用与decorator没有太大区别，只是它们应用的场景不同。因为 monkey patching 会再他人未预期的情况下，进入并修改其他人的代码。所以如果没能以正确的方式使用monkey patching，很可能会使用户应用程序奔溃，或者无意中更改它的运行方式。) The first thing that is vitally important is preserving introspection for the wrapped function. Another not so obvious thing though is that you need to ensure that you do not mess with how the execution model for the Python object model works.(最重要的是保持对包装函数的内省。另一个不太明显的事情是，你需要完全理解 Python 对象模型的执行方式) Now I can in my own function wrappers that are used when performing monkey patching ensure that these two requirements are met so as to ensure that the function wrapper is transparent, but it can all fall in a heap when one needs to monkey patch functions which already have other decorators applied.(为了能同时使用函数包装器和猴子补丁，函数包装器必需是透明的，并且内部维护了一个堆，以便多个装饰器，猴子补订能按照预期的顺序执行) So when you implement a Python decorator and do it poorly it can affect me and what I want to do. If I have to subsequently work around when you do it wrong, I get somewhat annoyed and grumpy as more often than not that entails a lot of pain.(所以当你错误的使用装饰器并影响到我时。我就会变得有些生气和暴躁，因为这通常会带来很多痛苦) To cover everything there is to know about what is wrong with your typical Python decorators and wrapping of functions, plus how to fix it, will take a lot of explaining, so one blog post isn’t going to be enough. See this blog post therefore as just part one of an extended discussion.(为了涵盖所有的内容，我们需要了解闭包方式的装饰器错误在哪里，以及如何修复它，这需要大量的解释，所以一个博客帖子是不够的。因此，请把这篇博文看作是扩展讨论的一部分。) For this first instalment I will simply go through the various ways in which your typical Python decorator can cause problems.(在第一期中，我将简单介绍闭包方式的装饰器可能导致的各种问题。) Basics of a Python decoratorEveryone should know what the Python decorator syntax is.(python 装饰器语法如下) 123@function_wrapperdef function(): pass The @ annotation to denote the application of a decorator was only added in Python 2.4. It is actually though only fancy syntactic sugar. It is actually equivalent to writing:and what you would have done prior to Python 2.4.(@ 符应用一个装饰器在Python2.4 中被加入。它仅仅是如下方式的语法糖，并且在 Python2.4 之前，你必须这么做)1234def function(): passfunction = function_wrapper(function)** The decorator syntax is therefore just a short hand way of being able to apply a wrapper around an existing function, or otherwise modify the existing function in place, while the definition of the function is being setup.(因此，装饰器语法只是一种将包装器应用于现有的函数的简单方式，或者在其他地方修改现有的函数。包装器作用于函数定义完成之后) What is referred to as monkey patching achieves pretty much the same outcome, the difference being that when monkey patching the wrapper isn’t being applied at the time the definition of the function is being setup, but is applied retrospectively from a different context after the fact.(所谓的“猴子补丁”的实现的效果几乎是相同的，不同的是，猴子补订作用的时间不是函数定义完成之后，而是应用在不同的上下文环境中)(读者理解: 猴子补订在函数导入模块时被应用) Anatomy of a function wrapperAlthough I mentioned using function closures to implement a decorator, to understand how the more generic case of a function wrapper works it is more illustrative to show how to implement it using a class.(虽然我之前提到使用函数闭包实现装饰器，但是能展示它工作原理的更好的示例是使用一个类实现它) 123456789class function_wrapper(object): def __init__(self, wrapped): self.wrapped = wrapped def __call__(self, *args, **kwargs): return self.wrapped(*args, **kwargs)**@function_wrapperdef function(): pass The class instance in this example is initialised with and records the original function object. When the now wrapped function is called, it is actually the __call__() method of the wrapper object which is invoked. This in turn would then call the original wrapped function.(示例中的类实例被初始化，并记录了被包装函数，当被包装函数被调用时，包装类的 __call__ 方法被调用，并进而调用原始的被包装函数) Simply passing through the call to the wrapper alone isn’t particularly useful, so normally you would actually want to do some work either before or after the wrapped function is called. Or you may want to modify the input arguments or the result as they pass through the wrapper. This is just a matter of modifying the __call__() method appropriately to do what you want.(简单的传递被包装函数并没有什么作用，所以通常情况下，你可能会再被包装函数被调用之前或之后做一些其他有用的事。比如，修改输入的参数或被包装函数的返回结果。这些只需要你按需适当修改 __call__ 方法即可) Using a class to implement the wrapper for a decorator isn’t actually that popular. Instead a function closure is more often used. In this case a nested function is used as the wrapper and it is that which is returned by the decorator function. When the now wrapped function is called, the nested function is actually being called. This in turn would again then call the original wrapped function.(使用函数闭包实现一个装饰器，比使用类更加常用。在这个实例中，包装函数创建并返回一个内嵌函数，当被包装函数被调用时，内嵌的函数被调用，进而调用原始的被包装函数)12345678def function_wrapper(wrapped): def _wrapper(*args, **kwargs): return wrapped(*args, **kwargs)** return _wrapper@function_wrapperdef function(): pass In this example the nested function doesn’t actually get passed the original wrapped function explicitly. But it will still have access to it via the arguments given to the outer function call. This does away with the need to create a class to hold what was the wrapped function and thus why it is convenient and generally more popular.(在这个实例中，内嵌函数不需要显示获取被包装函数，但是仍然可以通过外部函数访问到它。这和类必需包含被包装函数不同，也是函数闭包更便利常用的原因) Introspecting a function(内省一个函数) Now when we talk about functions, we expect them to specify properties which describe them as well as document what they do. These include the __name__ and __doc__ attributes. When we use a wrapper though, this no longer works as we expect as in the case of using a function closure, the details of the nested function are returned.(当我们讨论函数闭包时，我们会预期函数的自省属性和函数的外在表现相一致。这些包括__name__ and __doc__ 属性。但是当使用函数闭包时，原函数的自省属性会被内嵌函数所替代，因为函数闭包返回的是内嵌函数)(函数闭包使的被包装函数自省属性丢失)1234567891011def function_wrapper(wrapped): def _wrapper(*args, **kwargs): return wrapped(*args, **kwargs)** return _wrapper@function_wrapperdef function(): pass&gt;&gt;&gt; print(function.__name__)**_wrapper If we use a class to implement the wrapper, as class instances do not normally have a __name__ attribute, attempting to access the name of the function will actually result in an AttributeError exception.(当使用类实现闭包时，类实例没有 __name__属性，访问此属性时，会导致 AttributeError 异常)1234567891011121314class function_wrapper(object): def __init__(self, wrapped): self.wrapped = wrapped def __call__(self, *args, **kwargs): return self.wrapped(*args, **kwargs)**@function_wrapperdef function(): pass&gt;&gt;&gt; print(function.__name__)**Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;AttributeError: &apos;function_wrapper&apos; object has no attribute &apos;__name__&apos; The solution here when using a function closure is to copy the attributes of interest from the wrapped function to the nested wrapper function. This will then result in the function name and documentation strings being correct.(此处的解决方式是，在函数闭包内，将被包装函数的内省属性复制到内嵌函数上。这样函数名称和文档字符串属性就能表现正常) 12345678910111213def function_wrapper(wrapped): def _wrapper(*args, **kwargs): return wrapped(*args, **kwargs)** _wrapper.__name__ = wrapped.__name__ _wrapper.__doc__ = wrapped.__doc__ return _wrapper@function_wrapperdef function(): pass&gt;&gt;&gt; print(function.__name__)**function Needing to manually copy the attributes is laborious, and would need to be updated if any further special attributes were added which needed to be copied. For example, we should also copy the __module__ attribute, and in Python 3 the __qualname__ and __annotations__ attributes were added. To aid in getting this right, the Python standard library provides the functools.wraps() decorator which does this task for you.(手动复制属性是费劲的，如果未来扩展了其他自省属性，代码需要被更新。例如需要复制 __module__ 属性，在Python3 中需要复制 __qualname__ 和 __annotations__属性。为了避免这么做，Python 标准库为我们提供了 functools.wraps() 装饰器，完成自省属性的复制)1234567891011121314import functoolsdef function_wrapper(wrapped): @functools.wraps(wrapped)** def _wrapper(*args, **kwargs): return wrapped(*args, **kwargs)** return _wrapper@function_wrapperdef function(): pass&gt;&gt;&gt; print(function.__name__)**function If using a class to implement the wrapper, instead of the functools.wraps() decorator, we would use the functools.update_wrapper() function.(使用类实现装饰器时，我们需要使用 functools.update_wrapper() 函数)12345678import functoolsclass function_wrapper(object): def __init__(self, wrapped): self.wrapped = wrapped functools.update_wrapper(self, wrapped)** def __call__(self, *args, **kwargs): return self.wrapped(*args, **kwargs)** So we might have a solution to ensuring the function name and any documentation string is correct in the form of functools.wraps(), but actually we don’t and this will not always work as I will show below.(我们或许认为通过 functolls.wraps 函数我们能确保函数的自省属性是正确的，但事实上如我接下来展示的，它并不能一直有效) Now what if we want to query the argument specification for a function. This also fails and instead of returning the argument specification for the wrapped function, it returns that of the wrapper. In the case of using a function closure, this is the nested function. The decorator is therefore not signature preserving.(假如我们去访问函数的参数信息，返回的将是包装函数的参数信息而不是被包装函数的。即，在使用闭包的方式中，内嵌函数的参数信息被返回。因此包装器没能保留函数签名信息)123456789import inspectdef function_wrapper(wrapped): ...@function_wrapperdef function(arg1, arg2): pass&gt;&gt;&gt; print(inspect.getargspec(function))**ArgSpec(args=[], varargs=&apos;args&apos;, keywords=&apos;kwargs&apos;, defaults=None)** A worse situation again occurs with the class based wrapper. This time we get an exception complaining that the wrapped function isn’t actually a function. As a result it isn’t possible to derive an argument specification at all, even though the wrapped function is actually still callable.(类包装器更加严重，因为会触发异常，并解释称被包装函数不是一个函数。我们完全不能获取函数签名信息，即使被包装函数是可调用的)123456789101112class function_wrapper(object): ...@function_wrapperdef function(arg1, arg2): pass&gt;&gt;&gt; print(inspect.getargspec(function))**Traceback (most recent call last): File &quot;...&quot;, line XXX, in &lt;module&gt; print(inspect.getargspec(function))** File &quot;.../inspect.py&quot;, line 813, in getargspec raise TypeError(&apos;&#123;!r&#125; is not a Python function&apos;.format(func))**TypeError: &lt;__main__.function_wrapper object at 0x107e0ac90&gt; is not a Python function Another example of introspection one can do is to use inspect.getsource() to get back the source code related to a function. This also will fail, with it giving the source code for the nested wrapper function in the case of a function closure and again failing outright with an exception in the case of the class based wrapper.(另外一个自省的示例是使用 inspect.getsource() 获取函数源代码。闭包装饰器返回的是内嵌函数的源代码，而类装饰器则会触发异常) Wrapping class methodsNow, as well as normal functions, decorators can also be applied to methods of classes. Python even includes a couple of special decorators called \@classmethod and \@staticmethod for converting normal instance methods into these special method types. Methods of classes do provide a number of potential problems though.(同函数类似，装饰器也可以应用于类方法。Python 包含了两个特殊的装饰器\@classmethod 和 \@staticmethod 将实例方法转换为特殊的类方法。装饰器应用于类方法同样隐含着几个问题)12345678910111213class Class(object): @function_wrapper def method(self): pass @classmethod def cmethod(cls): pass @staticmethod def smethod(): pass The first is that even if using functools.wraps() or functools.update_wrapper() in your decorator, when the decorator is applied around \@classmethod or \@staticmethod, it can fail with an exception. This is because the wrappers created by these, do not have some of the attributes being copied.(第一即使使用了 functools.wraps 或者 functools.update_wrapper，当装饰器被用在 \@classmethod or \@staticmethod 上时，仍然会导致异常。这是因为这两个特殊的装饰器没能将一些必要的属性复制过来) 12345678910111213class Class(object): @function_wrapper @classmethod def cmethod(cls): passTraceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; File &quot;&lt;stdin&gt;&quot;, line 3, in Class File &quot;&lt;stdin&gt;&quot;, line 2, in wrapper File &quot;.../functools.py&quot;, line 33, in update_wrapper setattr(wrapper, attr, getattr(wrapped, attr))**AttributeError: &apos;classmethod&apos; object has no attribute &apos;__module__&apos; As it happens, this is a Python 2 bug and it is fixed in Python 3 by ignoring missing attributes.(这是一个Python2 的bug，并在Python3中通过忽略丢失的属性修复了) Even when we run it under Python 3, we still hit trouble though. This is because both wrapper types assume that the wrapped function is directly callable. This need not actually be the case. A wrapped function can actually be what is called a descriptor, meaning that in order to get back a callable, the descriptor has to be correctly bound to the instance first.(即使我们运行在 Python3 上，我们依然会遇到问题。这是因为所有类型的装饰器都假设被包装函数是直接可调用的。事实上并非如此。一个被包装函数，本质上是一个描述符，即描述符只有在正确绑定了一个实例后，才能被调用)(读者理解: Python classmethod 装饰器返回一个描述符，这个描述符不是直接可调用的，但是装饰器假设被包装函数直接可调用，因此会出错)12345678910111213class Class(object): @function_wrapper @classmethod def cmethod(cls): pass&gt;&gt;&gt; Class.cmethod()**Traceback (most recent call last): File &quot;classmethod.py&quot;, line 15, in &lt;module&gt; Class.cmethod()** File &quot;classmethod.py&quot;, line 6, in _wrapper return wrapped(*args, **kwargs)**TypeError: &apos;classmethod&apos; object is not callable Simple does not imply correctnessSo although the usual way that people implement decorators is simple, that doesn’t mean they are necessarily correct and will always work.(虽然实现一个装饰器很简单，但并不意味着它总是正确并能一直正常运行) The issues highlighted so far are:(主要问题如下) Preservation of function __name__ and __doc__.(无法保留函数的自省属性) Preservation of function argument specification.(无法获取函数签名信息) Preservation of ability to get function source code.(无法获取函数源代码) Ability to apply decorators on top of other decorators that are implemented as descriptors.(无法将装饰器应用于另一个为实现描述符的装饰器之上)The functools.wraps() function is given as a solution to the first but doesn’t always work, at least in Python 2. It doesn’t help at all though with preserving the introspection of a functions argument specification and ability to get the source code for a function.(functools.wraps 函数可以解决部分第一类问题，但并不是总能正常运行，至少在Pyhton2中如此。也不帮助解决第二类问题和第三类问题) Even if one could solve the introspection problem, the simple decorator implementation that is generally offered up as the way to do things, breaks the execution model for the Python object model, not honouring the descriptor protocol of anything which is wrapped by the decorator.(即使可以解决内省问题，简单的装饰器实现不会遵守被包装对象的描述符协议，因而破坏了Python对象的执行模型) Third party packages do exist which try and solve these issues, such as the decorator module available on PyPi. This module in particular though only helps with the first two and still has potential issues with how it works that may cause problems when trying to dynamically apply function wrappers via monkey patching.(确实存在第三方包，尝试解决这些问题，例如PyPi上的decorator模块。这个模块虽然对前两类问题有所帮助，但仍然存在一些潜在的问题，当尝试通过猴子补丁动态应用函数包装时，可能会导致问题。) This doesn’t mean these problems aren’t solvable, and solvable in a way that doesn’t sacrifice performance. In my search at least, I could not actually find any one who has described a comprehensive solution or offered up a package which performs all the required magic so you don’t have to worry about it yourself.(这并不意味着这些问题是不可解决的，而且可以以一种不牺牲性能的方式解决。但是至少在我的搜索中，我没有找到一个全面的解决方案，或者一个能解决所有问题的包) This blog post is therefore the first step in me explaining how it can be all made to work. I have stated the problems to be solved and in subsequent posts I will explain how they can be solved and what extra capabilities that gives you which enables the ability to write even more magic decorators than what is possible now with traditional ways that decorators have been implemented.(因此，这篇博客文章是我第一步，解释它是如何运作的。我已经说明了要解决的问题，在随后的文章中，我将解释如何解决这些问题，以及提供哪些额外的功能，使您能够编写更多的具有魔力的装饰器) So stay tuned for the next instalment. Hopefully I can keep the momentum up and keep them coming. Pester me if I don’t.(请继续收看下一期文章。希望我能保持势头，尽快写出接下来的文章。如果没有，就去找我。)]]></content>
      <categories>
        <category>函数装饰器</category>
        <category>猴子补订</category>
        <category>wrapt</category>
      </categories>
      <tags>
        <tag>python 标准库</tag>
        <tag>译文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[virtualenv]]></title>
    <url>%2F2017%2F09%2F04%2Flinux_operations%2Fvirtualenv%2F</url>
    <content type="text"><![CDATA[virtualenv 基本使用 1. 环境创建virtualenv dirname – 创建虚拟环境source dirname/bin/activate – 启用虚拟环境 virtualenv 可用选项 作用 –distribute dirname 创建新的虚拟环境，并安装 pip –no-site-packages 使系统环境的包对虚拟环境不可见 2.virtualenvwrapper作用：virtualenv 管理工具，方便的创建/激活/管理/销毁虚拟环境 命令 作用 mkvirtualenv virname 新建虚拟环境 workon virname 激活 deactivate 关闭 rmvirtualenv virname 删除]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tornado 与 Python 异步编程概述]]></title>
    <url>%2F2017%2F09%2F04%2Fpython_frame%2Ftornado_summary%2F</url>
    <content type="text"><![CDATA[本篇内容: 简单总结了一下学习 tornado 和 Python 异步编程需要了解的知识点 Python 异步编程与 tornado内容摘要: tornado, flask, Django 对比 Python 协程，线程 进程 IO 模型 同步，异步，阻塞，非阻塞 IO 事件驱动模型 异步IO 基于事件的编程 回调 协程 tornado 异步编程接口 gen.coroutine gen.runner httpserver ioloop.IOLoop 接口示例 1. tornado, flask, Django 对比作用对比: tornado 是一个 web 编程框架，同时也是一个高性能的 web 应用程序服务器 flask，Django 只是一个web 编程框架，不是一个web 应用程序服务器 部署对比: http/nginx —–&gt; uWSGI(应用程序服务器) ——&gt; flask/Djaong http/nginx ——–&gt; tornado 性能对比(C10K): fask,Django 都是基于线程/进程做并发，操作系统能够创建的线程，进程数量是有限的 进程/线程切换性能耗费比较大 tornado 使用的协程更加轻量，能够处理的并发连接更多 缺点: 异步代码导致代码复用更加快难 tornado 异步数据库驱动要么少，要么老 作为 web 框架而言提供的功能相对 Django 少很多，Django 依旧是最火的 发展: Python 标准库 asyncio 提供了完整的异步编程接口 aiohttp 实现了 tcp, http 协议的异步库 uvloop: Cython编写的，基于 libuv 的 IO 事件循环，性能跟 Go 差不多 sanic: Python 最新的 web 框架 2. Python 协程1234567891011121314151617def simple_coro2(a): print(&apos;-&gt; Started: a =&apos;, a) b = yield a print(&apos;-&gt; Received: b =&apos;, b) c = yield a + b print(&apos;-&gt; Received: c =&apos;, c)coro = simple_coro2(1)next(coro) # == coro.send(None)coro.send(2)coro.send(3)coro.send(4)coro.close()coro.throw(ValueError())from inspect import getgeneratorstategetgeneratorstate(coro) GIL 全局解释器锁 Python 线程切换发生在阻塞的系统调用上，适合IO 密集型任务 Python 进程，能利用多核CPU，主要用在CPU 密集型任务 Python 协程: 无需锁，更轻量，切换更迅速 3. IO 模型 阻塞/非阻塞: 程序的执行模式 同步/异步: 应用程序与操作系统的交互方式 IO 事件模型: select + poll + epool 参考连接: https://songlee24.github.io/2016/07/19/explanation-of-5-IO-models/ https://blog.csdn.net/wuzhengfei1112/article/details/78242004 4. 基于事件的编程func —&gt; (fd, (rd,wt), callback)io_cycle —-&gt; register(fd, rd|wt)io_cycle —-&gt; callback(coro) 回调: callback(function) 协程: callback(coro.send(value)) 5. tornado 异步编程接口 IOLoop: 事件循环 Application: 应用 HttpsServer: Http server TCP server 1234567891011121314151617181920212223import tornado.ioloopimport tornado.webfrom tornado.gen import coroutineclass MainHandler(tornado.web.RequestHandler): def get(self): self.write(&quot;Hello, world&quot;)class SleepHandler(tornado.web.RequestHandler): @coroutine def get(self): yield gen.sleep(5) self.write(&quot;sleep over&quot;)if __name__ == &quot;__main__&quot;: application = tornado.web.Application([ (r&quot;/&quot;, MainHandler), (r&quot;/sleep&quot;, SleepHandler) ]) application.listen(8888) tornado.ioloop.IOLoop.current().start() 6. 接口示例https://github.com/bueda/tornado-boilerplate 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455.├── app.py # web 应用入口├── cal_control│ └── search_rank│ ├── cal_search_rank.py│ ├── get_es_search.py├── db_tools # 数据库操作接口│ ├── es_async.py│ ├── es_base.py│ ├── es_body.py│ ├── es_sync.py│ ├── mysql.py│ └── redis.py├── dev.py├── environment.py├── fabfile.py├── handlers # request handler│ ├── base.py│ └── rank.py├── local_dev.py├── local.py├── logconfig # 日志模块│ ├── conf_parse.py│ ├── logconfig.py├── media # 静态文件模块│ ├── css│ │ └── reset.css│ ├── images│ │ └── favicon.ico│ └── js│ └── vendor│ └── jquery-1.4.4.js├── Pipfile # pipenv 环境部署工具├── Pipfile.lock├── prod.py├── setting.cfg├── settings.py # 配置文件├── sync_job # 定时任务│ ├── get_name_id.py│ ├── rank.py│ └── rank_setting.py├── templates│ └── base.html├── tests # 测试│ ├── mysql_sync.py│ ├── run_test.py│ ├── test_es_query.py│ ├── test_mysql.py│ ├── test_mysql_transaction.py│ ├── test_post.py│ ├── test_redis.py│ └── test_sync_rank.py├── urls.py # 路由└── vendor └── comrade 添加新接口1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# app.pyclass AnalyticApiApplication(tornado.web.Application): def __init__(self): super().__init__(handlers=url_patterns, **settings) # self.add_handlers(&apos;^pycgi.enlightent\.com$&apos;, url_patterns) self.mysql_pool = tormysql.ConnectionPool( max_connections=100, # max open connections idle_seconds=7200, # conntion idle timeout time, 0 is not timeout wait_connection_timeout=10, # wait connection timeout host=MYSQL_HOST, user=MYSQL_USER, passwd=MYSQL_PASSWD, db=MYSQL_DB_ONLINE, charset=&quot;utf8&quot; ) self.redis_conn = redis.Redis(host=REDIS_HOST, port=REDIS_PORT, db=REDIS_DB_DAY, password=REDIS_PASSWD) es_sync = Elasticsearch(hosts=ES_HOST, port=ES_PORT, http_auth=ES_AUTH) self.es_obj = EsSync(conn_get=self.get_es_conn, conn=es_sync)# handlers.base# 每个 RequestHandler 初始化的时候都会接收到 Application,继而可以访问到所有配置信息class BaseHandler(RequestHandler): def __init__(self, application, request, **kwargs): super().__init__(application, request, **kwargs) self.mysql_pool = self.application.mysql_pool # 及时释放连接 self.redis_conn = self.application.redis_conn # 非异步 self.es_obj = self.application.es_obj # 内部使用了线程池# 1. 在 urls.py 内配置路由url_patterns = [ (r&apos;/&apos;, HelloHandler), (r&apos;/rank&apos;, RankHandler)]# 2. 编写 Request Handler，实现 get 方法from handlers.base import BaseHandlerclass RankHandler(BaseHandler): @gen.coroutine def get(self, *args, **kwargs): self.write(0)# 3. 线程池from concurrent.futures import ThreadPoolExecutor 7. asyncio123456789101112131415161718192021222324252627import asynciofrom asyncio import get_event_loopasync def sleep_a(): print(&apos;------&gt;a&apos;) await asyncio.sleep(1) print(&apos;a close&apos;)async def sleep_b(): print(&apos;------&gt;b&apos;) await asyncio.sleep(1) print(&apos;b close&apos;)async def main(): f_a = sleep_a() f_b = sleep_b() f = await asyncio.wait([f_a, f_b]) return fif __name__ == &apos;__main__&apos;: io_loop = get_event_loop() f = main() # f_a = sleep_a() # f_b = sleep_b() # f = asyncio.wait([f_a, f_b]) io_loop.run_until_complete(f)]]></content>
      <tags>
        <tag>tornado</tag>
        <tag>asyncio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[supervisor 安装与概述]]></title>
    <url>%2F2017%2F09%2F04%2Fpython_frame%2Fsupervisor_01%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>部署工具</category>
      </categories>
      <tags>
        <tag>supervisor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[supervisor 配置文件详解]]></title>
    <url>%2F2017%2F09%2F04%2Fpython_frame%2Fsupervisor_02%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>部署工具</category>
      </categories>
      <tags>
        <tag>supervisor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python library of threading]]></title>
    <url>%2F2017%2F09%2F03%2Fpython_library%2Fthreading%2F</url>
    <content type="text"><![CDATA[python 多线程 threading]]></content>
      <categories>
        <category>python 标准库</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python library of heapq]]></title>
    <url>%2F2017%2F09%2F03%2Fpython_library%2Fheapq%2F</url>
    <content type="text"><![CDATA[Python 实现的最小堆 摘要： What: 是什么 Why: 为什么会出现 When：什么会用到 Where：用到哪 Who：谁在用 How：如何使用 heapq]]></content>
      <categories>
        <category>python 标准库</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo github blog]]></title>
    <url>%2F2017%2F09%2F03%2Fblog_some%2Fhexo-github%2F</url>
    <content type="text"><![CDATA[使用 githup pages 和 hexo搭建 blog，本文不是完整教程，只是整个流程概览和常用命令备忘 1. github blog 搭建 安装node.js node -v 安装 hexo npm install hexo-cli -g 注册 github 帐号 新建xxx.github.io仓库，xxx 为帐号名称 初始化 hexo blog 123hexo init blogcd blognpm install 配置 hexo github 安装 hexo-deployer-gitnpm install hexo-deployer-git --save 在网站的_config.yml中配置deploy 123deploy:type: git repo: &lt;repository url&gt; branch: [branch] 提交git 12hexo d -ghexo d 2. hexo 常用命令 命令 作用 hexo init dir_name 创建博客目录 hexo clean …. hexo g(generate) 生成静态文件 hexo s(server) 启动本地web服务，用于博客的预览 hexo d(deploy) 部署播客到远端 hexo d -g 生成部署 hexo s -g 生成预览 hexo new “name” 新建文章 hexo new page “name” 新建页面 Quick StartHexo HomedocumentationtroubleshootingHexo GitHub. Create a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
</search>
